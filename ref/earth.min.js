!function (t) { var e = {}; function n(i) { if (e[i]) return e[i].exports; var r = e[i] = { i: i, l: !1, exports: {} }; return t[i].call(r.exports, r, r.exports, n), r.l = !0, r.exports } n.m = t, n.c = e, n.d = function (t, e, i) { n.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: i }) }, n.r = function (t) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var i = Object.create(null); if (n.r(i), Object.defineProperty(i, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var r in t) n.d(i, r, function (e) { return t[e] }.bind(null, r)); return i }, n.n = function (t) { var e = t && t.__esModule ? function () { return t.default } : function () { return t }; return n.d(e, "a", e), e }, n.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, n.p = "", n(n.s = 3) }([function (t) { t.exports = JSON.parse("[[-70,-66],[-68,-66],[-72,-64],[-70,-64],[-74,-62],[-72,-62],[-74,-60],[-72,-60],[-70,-60],[50,-60],[-74,-58],[-72,-58],[-70,-58],[-74,-56],[-72,-56],[-70,-56],[-68,-56],[136,-56],[138,-56],[-74,-54],[-72,-54],[-70,-54],[-68,-54],[118,-54],[140,-54],[-74,-52],[-72,-52],[-70,-52],[-68,-52],[-66,-52],[142,-52],[144,-52],[-74,-50],[-72,-50],[-70,-50],[-68,-50],[-66,-50],[144,-50],[-74,-48],[-72,-48],[-70,-48],[-68,-48],[-66,-48],[-64,-48],[-62,-48],[114,-48],[116,-48],[118,-48],[120,-48],[144,-48],[-74,-46],[-72,-46],[-70,-46],[-68,-46],[-66,-46],[-64,-46],[-62,-46],[112,-46],[114,-46],[116,-46],[118,-46],[120,-46],[122,-46],[-72,-44],[-70,-44],[-68,-44],[-66,-44],[-64,-44],[-62,-44],[-60,-44],[-58,-44],[6,-44],[8,-44],[10,-44],[12,-44],[14,-44],[92,-44],[94,-44],[96,-44],[98,-44],[110,-44],[112,-44],[114,-44],[116,-44],[118,-44],[120,-44],[122,-44],[-74,-42],[-72,-42],[-70,-42],[-68,-42],[-66,-42],[-64,-42],[-62,-42],[-60,-42],[-58,-42],[-56,-42],[6,-42],[8,-42],[10,-42],[12,-42],[14,-42],[16,-42],[92,-42],[94,-42],[96,-42],[98,-42],[100,-42],[102,-42],[104,-42],[106,-42],[108,-42],[110,-42],[112,-42],[114,-42],[116,-42],[118,-42],[120,-42],[122,-42],[124,-42],[-74,-40],[-72,-40],[-70,-40],[-68,-40],[-66,-40],[-64,-40],[-62,-40],[-60,-40],[-58,-40],[-56,-40],[6,-40],[8,-40],[10,-40],[12,-40],[14,-40],[16,-40],[92,-40],[94,-40],[96,-40],[98,-40],[100,-40],[102,-40],[104,-40],[106,-40],[108,-40],[110,-40],[112,-40],[114,-40],[116,-40],[118,-40],[120,-40],[122,-40],[124,-40],[-72,-38],[-70,-38],[-68,-38],[-66,-38],[-64,-38],[-62,-38],[-60,-38],[-58,-38],[-56,-38],[-54,-38],[4,-38],[6,-38],[8,-38],[10,-38],[12,-38],[14,-38],[16,-38],[18,-38],[92,-38],[94,-38],[96,-38],[98,-38],[100,-38],[102,-38],[104,-38],[106,-38],[108,-38],[110,-38],[112,-38],[114,-38],[116,-38],[118,-38],[120,-38],[122,-38],[124,-38],[-72,-36],[-70,-36],[-68,-36],[-66,-36],[-64,-36],[-62,-36],[-60,-36],[-58,-36],[-56,-36],[-54,-36],[4,-36],[6,-36],[8,-36],[10,-36],[12,-36],[14,-36],[16,-36],[18,-36],[30,-36],[92,-36],[94,-36],[96,-36],[98,-36],[100,-36],[102,-36],[104,-36],[106,-36],[108,-36],[110,-36],[112,-36],[114,-36],[116,-36],[118,-36],[120,-36],[122,-36],[124,-36],[-72,-34],[-70,-34],[-68,-34],[-66,-34],[-64,-34],[-62,-34],[-60,-34],[-58,-34],[-56,-34],[-54,-34],[-52,-34],[-50,-34],[4,-34],[6,-34],[8,-34],[10,-34],[12,-34],[14,-34],[16,-34],[18,-34],[20,-34],[30,-34],[92,-34],[94,-34],[96,-34],[98,-34],[100,-34],[102,-34],[104,-34],[106,-34],[108,-34],[110,-34],[112,-34],[114,-34],[116,-34],[118,-34],[120,-34],[122,-34],[-72,-32],[-70,-32],[-68,-32],[-66,-32],[-64,-32],[-62,-32],[-60,-32],[-58,-32],[-56,-32],[-54,-32],[-52,-32],[-50,-32],[-48,-32],[2,-32],[4,-32],[6,-32],[8,-32],[10,-32],[12,-32],[14,-32],[16,-32],[18,-32],[20,-32],[30,-32],[32,-32],[94,-32],[96,-32],[98,-32],[100,-32],[102,-32],[104,-32],[106,-32],[108,-32],[110,-32],[112,-32],[114,-32],[116,-32],[118,-32],[120,-32],[122,-32],[-72,-30],[-70,-30],[-68,-30],[-66,-30],[-64,-30],[-62,-30],[-60,-30],[-58,-30],[-56,-30],[-54,-30],[-52,-30],[-50,-30],[-48,-30],[2,-30],[4,-30],[6,-30],[8,-30],[10,-30],[12,-30],[14,-30],[16,-30],[18,-30],[20,-30],[30,-30],[32,-30],[100,-30],[102,-30],[104,-30],[106,-30],[108,-30],[110,-30],[112,-30],[114,-30],[116,-30],[118,-30],[120,-30],[-74,-28],[-72,-28],[-70,-28],[-68,-28],[-66,-28],[-64,-28],[-62,-28],[-60,-28],[-58,-28],[-56,-28],[-54,-28],[-52,-28],[-50,-28],[-48,-28],[-46,-28],[0,-28],[2,-28],[4,-28],[6,-28],[8,-28],[10,-28],[12,-28],[14,-28],[16,-28],[18,-28],[20,-28],[22,-28],[30,-28],[32,-28],[102,-28],[104,-28],[106,-28],[108,-28],[110,-28],[112,-28],[116,-28],[118,-28],[-78,-26],[-76,-26],[-74,-26],[-72,-26],[-70,-26],[-68,-26],[-66,-26],[-64,-26],[-62,-26],[-60,-26],[-58,-26],[-56,-26],[-54,-26],[-52,-26],[-50,-26],[-48,-26],[-46,-26],[2,-26],[4,-26],[6,-26],[8,-26],[10,-26],[12,-26],[14,-26],[16,-26],[18,-26],[20,-26],[22,-26],[24,-26],[32,-26],[34,-26],[102,-26],[104,-26],[106,-26],[108,-26],[110,-26],[118,-26],[-78,-24],[-76,-24],[-74,-24],[-72,-24],[-70,-24],[-68,-24],[-66,-24],[-64,-24],[-62,-24],[-60,-24],[-58,-24],[-56,-24],[-54,-24],[-52,-24],[-50,-24],[-48,-24],[-46,-24],[2,-24],[4,-24],[6,-24],[8,-24],[10,-24],[12,-24],[14,-24],[16,-24],[18,-24],[20,-24],[22,-24],[24,-24],[108,-24],[110,-24],[118,-24],[-80,-22],[-78,-22],[-76,-22],[-74,-22],[-72,-22],[-70,-22],[-68,-22],[-66,-22],[-64,-22],[-62,-22],[-60,-22],[-58,-22],[-56,-22],[-54,-22],[-52,-22],[-50,-22],[-48,-22],[-46,-22],[2,-22],[4,-22],[6,-22],[8,-22],[10,-22],[12,-22],[14,-22],[16,-22],[18,-22],[20,-22],[22,-22],[24,-22],[-80,-20],[-78,-20],[-76,-20],[-74,-20],[-72,-20],[-70,-20],[-68,-20],[-66,-20],[-64,-20],[-62,-20],[-60,-20],[-58,-20],[-56,-20],[-54,-20],[-52,-20],[-50,-20],[-48,-20],[-46,-20],[-44,-20],[2,-20],[4,-20],[6,-20],[8,-20],[10,-20],[12,-20],[14,-20],[16,-20],[18,-20],[20,-20],[22,-20],[24,-20],[102,-20],[116,-20],[118,-20],[122,-20],[134,-20],[-82,-18],[-80,-18],[-78,-18],[-76,-18],[-74,-18],[-72,-18],[-70,-18],[-68,-18],[-66,-18],[-64,-18],[-62,-18],[-60,-18],[-58,-18],[-56,-18],[-54,-18],[-52,-18],[-50,-18],[-48,-18],[-46,-18],[-44,-18],[2,-18],[4,-18],[6,-18],[8,-18],[10,-18],[12,-18],[14,-18],[16,-18],[18,-18],[20,-18],[22,-18],[24,-18],[86,-18],[88,-18],[90,-18],[114,-18],[116,-18],[118,-18],[120,-18],[-82,-16],[-80,-16],[-78,-16],[-76,-16],[-74,-16],[-72,-16],[-70,-16],[-68,-16],[-66,-16],[-64,-16],[-62,-16],[-60,-16],[-58,-16],[-56,-16],[-54,-16],[-52,-16],[-50,-16],[-48,-16],[-46,-16],[-44,-16],[0,-16],[2,-16],[4,-16],[6,-16],[8,-16],[10,-16],[12,-16],[14,-16],[16,-16],[18,-16],[20,-16],[22,-16],[24,-16],[84,-16],[100,-16],[114,-16],[116,-16],[118,-16],[120,-16],[126,-16],[-82,-14],[-80,-14],[-78,-14],[-76,-14],[-74,-14],[-72,-14],[-70,-14],[-68,-14],[-66,-14],[-64,-14],[-62,-14],[-60,-14],[-58,-14],[-56,-14],[-54,-14],[-52,-14],[-50,-14],[-48,-14],[0,-14],[2,-14],[4,-14],[6,-14],[8,-14],[10,-14],[12,-14],[14,-14],[16,-14],[18,-14],[20,-14],[22,-14],[24,-14],[82,-14],[84,-14],[90,-14],[92,-14],[106,-14],[110,-14],[112,-14],[114,-14],[116,-14],[-82,-12],[-80,-12],[-78,-12],[-76,-12],[-74,-12],[-72,-12],[-70,-12],[-68,-12],[-66,-12],[-64,-12],[-62,-12],[-60,-12],[-58,-12],[-56,-12],[-54,-12],[-2,-12],[0,-12],[2,-12],[4,-12],[6,-12],[8,-12],[10,-12],[12,-12],[14,-12],[16,-12],[18,-12],[20,-12],[22,-12],[24,-12],[26,-12],[80,-12],[82,-12],[88,-12],[90,-12],[92,-12],[94,-12],[100,-12],[108,-12],[-82,-10],[-80,-10],[-78,-10],[-76,-10],[-74,-10],[-72,-10],[-70,-10],[-68,-10],[-66,-10],[-64,-10],[-62,-10],[-60,-10],[-58,-10],[-56,-10],[-2,-10],[0,-10],[2,-10],[4,-10],[6,-10],[8,-10],[10,-10],[12,-10],[14,-10],[16,-10],[18,-10],[20,-10],[22,-10],[24,-10],[26,-10],[28,-10],[80,-10],[88,-10],[90,-10],[92,-10],[94,-10],[96,-10],[98,-10],[104,-10],[-80,-8],[-78,-8],[-76,-8],[-74,-8],[-72,-8],[-70,-8],[-68,-8],[-66,-8],[-64,-8],[-62,-8],[-60,-8],[-58,-8],[0,-8],[2,-8],[4,-8],[6,-8],[8,-8],[10,-8],[12,-8],[14,-8],[16,-8],[18,-8],[20,-8],[22,-8],[24,-8],[26,-8],[28,-8],[30,-8],[78,-8],[82,-8],[92,-8],[94,-8],[-80,-6],[-78,-6],[-76,-6],[-74,-6],[-72,-6],[-70,-6],[-68,-6],[-66,-6],[-64,-6],[-62,-6],[-60,-6],[-58,-6],[-18,-6],[-12,-6],[-6,-6],[-4,-6],[-2,-6],[0,-6],[2,-6],[4,-6],[6,-6],[8,-6],[10,-6],[12,-6],[14,-6],[16,-6],[18,-6],[20,-6],[22,-6],[24,-6],[26,-6],[28,-6],[30,-6],[32,-6],[76,-6],[80,-6],[82,-6],[94,-6],[96,-6],[-80,-4],[-78,-4],[-76,-4],[-74,-4],[-72,-4],[-70,-4],[-68,-4],[-66,-4],[-64,-4],[-20,-4],[-18,-4],[-16,-4],[-14,-4],[-12,-4],[-10,-4],[-8,-4],[-6,-4],[-4,-4],[-2,-4],[0,-4],[2,-4],[4,-4],[6,-4],[8,-4],[10,-4],[12,-4],[14,-4],[16,-4],[18,-4],[20,-4],[22,-4],[24,-4],[26,-4],[28,-4],[30,-4],[32,-4],[62,-4],[102,-4],[-82,-2],[-78,-2],[-76,-2],[-74,-2],[-72,-2],[-70,-2],[-68,-2],[-66,-2],[-22,-2],[-20,-2],[-18,-2],[-16,-2],[-14,-2],[-12,-2],[-10,-2],[-8,-2],[-6,-2],[-4,-2],[-2,-2],[0,-2],[2,-2],[4,-2],[6,-2],[8,-2],[10,-2],[12,-2],[14,-2],[16,-2],[18,-2],[20,-2],[22,-2],[24,-2],[26,-2],[28,-2],[30,-2],[32,-2],[34,-2],[62,-2],[78,-2],[84,-2],[102,-2],[-86,0],[-78,0],[-76,0],[-74,0],[-24,0],[-22,0],[-20,0],[-18,0],[-16,0],[-14,0],[-12,0],[-10,0],[-8,0],[-6,0],[-4,0],[-2,0],[0,0],[2,0],[4,0],[6,0],[8,0],[10,0],[12,0],[14,0],[16,0],[18,0],[20,0],[22,0],[24,0],[26,0],[28,0],[32,0],[34,0],[58,0],[60,0],[78,0],[82,0],[84,0],[86,0],[-88,2],[-86,2],[-24,2],[-22,2],[-20,2],[-18,2],[-16,2],[-14,2],[-12,2],[-10,2],[-8,2],[-6,2],[-4,2],[-2,2],[0,2],[2,2],[4,2],[6,2],[8,2],[10,2],[12,2],[14,2],[16,2],[18,2],[20,2],[22,2],[24,2],[26,2],[58,2],[60,2],[78,2],[80,2],[82,2],[84,2],[86,2],[98,2],[100,2],[-92,4],[-90,4],[-88,4],[-86,4],[-26,4],[-24,4],[-22,4],[-20,4],[-18,4],[-16,4],[-14,4],[-12,4],[-10,4],[-8,4],[-6,4],[-4,4],[-2,4],[0,4],[2,4],[4,4],[6,4],[8,4],[10,4],[12,4],[14,4],[16,4],[18,4],[20,4],[22,4],[24,4],[28,4],[30,4],[32,4],[34,4],[56,4],[58,4],[60,4],[78,4],[80,4],[82,4],[84,4],[86,4],[98,4],[-100,6],[-98,6],[-96,6],[-94,6],[-92,6],[-90,6],[-24,6],[-22,6],[-20,6],[-18,6],[-16,6],[-14,6],[-12,6],[-10,6],[-8,6],[-6,6],[-4,6],[-2,6],[0,6],[2,6],[4,6],[6,6],[8,6],[10,6],[12,6],[14,6],[16,6],[18,6],[20,6],[22,6],[24,6],[28,6],[30,6],[32,6],[34,6],[36,6],[56,6],[58,6],[60,6],[62,6],[74,6],[76,6],[78,6],[80,6],[82,6],[84,6],[98,6],[-104,8],[-102,8],[-100,8],[-98,8],[-92,8],[-90,8],[-74,8],[-24,8],[-22,8],[-20,8],[-18,8],[-16,8],[-14,8],[-12,8],[-10,8],[-8,8],[-6,8],[-4,8],[-2,8],[0,8],[2,8],[4,8],[6,8],[8,8],[10,8],[12,8],[14,8],[16,8],[18,8],[20,8],[22,8],[28,8],[30,8],[32,8],[34,8],[36,8],[38,8],[40,8],[56,8],[58,8],[60,8],[62,8],[64,8],[74,8],[76,8],[78,8],[80,8],[82,8],[88,8],[-104,10],[-102,10],[-100,10],[-98,10],[-90,10],[-80,10],[-24,10],[-22,10],[-20,10],[-18,10],[-16,10],[-14,10],[-12,10],[-10,10],[-8,10],[-6,10],[-4,10],[-2,10],[0,10],[2,10],[4,10],[6,10],[8,10],[10,10],[12,10],[14,10],[16,10],[18,10],[20,10],[22,10],[26,10],[28,10],[30,10],[32,10],[34,10],[36,10],[38,10],[40,10],[56,10],[58,10],[60,10],[62,10],[64,10],[66,10],[72,10],[74,10],[76,10],[78,10],[80,10],[82,10],[84,10],[88,10],[-104,12],[-102,12],[-100,12],[-98,12],[-84,12],[-24,12],[-22,12],[-20,12],[-18,12],[-16,12],[-14,12],[-12,12],[-10,12],[-8,12],[-6,12],[-4,12],[-2,12],[0,12],[2,12],[4,12],[6,12],[8,12],[10,12],[12,12],[14,12],[16,12],[18,12],[20,12],[24,12],[26,12],[28,12],[30,12],[32,12],[34,12],[36,12],[38,12],[40,12],[42,12],[52,12],[54,12],[56,12],[58,12],[60,12],[62,12],[64,12],[66,12],[68,12],[70,12],[72,12],[74,12],[76,12],[78,12],[80,12],[82,12],[84,12],[86,12],[88,12],[90,12],[92,12],[-110,14],[-106,14],[-104,14],[-102,14],[-100,14],[-98,14],[-22,14],[-20,14],[-18,14],[-16,14],[-14,14],[-12,14],[-10,14],[-8,14],[-6,14],[-4,14],[-2,14],[0,14],[2,14],[4,14],[6,14],[8,14],[10,14],[12,14],[14,14],[16,14],[18,14],[20,14],[24,14],[26,14],[28,14],[30,14],[32,14],[34,14],[50,14],[52,14],[54,14],[56,14],[58,14],[60,14],[62,14],[64,14],[66,14],[68,14],[70,14],[72,14],[74,14],[76,14],[78,14],[80,14],[82,14],[84,14],[86,14],[88,14],[90,14],[92,14],[94,14],[98,14],[-112,16],[-108,16],[-106,16],[-104,16],[-102,16],[-100,16],[-98,16],[-84,16],[-82,16],[-22,16],[-20,16],[-18,16],[-16,16],[-14,16],[-12,16],[-10,16],[-8,16],[-6,16],[-4,16],[-2,16],[0,16],[2,16],[4,16],[6,16],[8,16],[10,16],[12,16],[14,16],[16,16],[18,16],[22,16],[24,16],[26,16],[28,16],[30,16],[32,16],[38,16],[40,16],[42,16],[44,16],[46,16],[48,16],[50,16],[52,16],[54,16],[56,16],[58,16],[60,16],[62,16],[64,16],[66,16],[68,16],[70,16],[72,16],[74,16],[76,16],[78,16],[80,16],[82,16],[84,16],[86,16],[88,16],[90,16],[92,16],[94,16],[96,16],[-112,18],[-110,18],[-108,18],[-106,18],[-104,18],[-102,18],[-100,18],[-98,18],[-96,18],[-84,18],[-20,18],[-18,18],[-16,18],[-14,18],[-12,18],[-10,18],[-8,18],[-6,18],[-4,18],[-2,18],[0,18],[2,18],[4,18],[6,18],[8,18],[10,18],[12,18],[14,18],[16,18],[18,18],[20,18],[22,18],[24,18],[26,18],[28,18],[30,18],[32,18],[36,18],[38,18],[40,18],[42,18],[44,18],[46,18],[48,18],[50,18],[52,18],[54,18],[56,18],[58,18],[60,18],[62,18],[64,18],[66,18],[68,18],[70,18],[72,18],[74,18],[76,18],[78,18],[80,18],[82,18],[84,18],[86,18],[88,18],[90,18],[92,18],[94,18],[96,18],[-110,20],[-108,20],[-106,20],[-104,20],[-102,20],[-100,20],[-98,20],[-96,20],[-94,20],[-92,20],[-90,20],[-88,20],[-86,20],[-84,20],[-18,20],[-16,20],[-14,20],[-12,20],[-10,20],[-8,20],[-6,20],[-4,20],[-2,20],[0,20],[2,20],[4,20],[8,20],[10,20],[12,20],[14,20],[16,20],[18,20],[20,20],[22,20],[24,20],[26,20],[28,20],[30,20],[32,20],[34,20],[36,20],[38,20],[40,20],[42,20],[44,20],[46,20],[48,20],[50,20],[52,20],[54,20],[56,20],[58,20],[60,20],[62,20],[64,20],[66,20],[68,20],[70,20],[72,20],[74,20],[76,20],[78,20],[80,20],[82,20],[84,20],[86,20],[88,20],[90,20],[92,20],[94,20],[96,20],[-114,22],[-112,22],[-110,22],[-108,22],[-106,22],[-104,22],[-102,22],[-100,22],[-98,22],[-96,22],[-94,22],[-92,22],[-90,22],[-88,22],[-86,22],[-84,22],[-82,22],[-18,22],[-16,22],[-14,22],[-12,22],[-10,22],[-8,22],[-6,22],[-4,22],[-2,22],[22,22],[24,22],[26,22],[28,22],[30,22],[32,22],[34,22],[36,22],[38,22],[40,22],[42,22],[44,22],[46,22],[48,22],[50,22],[52,22],[54,22],[56,22],[58,22],[60,22],[62,22],[64,22],[66,22],[68,22],[70,22],[72,22],[74,22],[76,22],[78,22],[80,22],[82,22],[84,22],[86,22],[88,22],[90,22],[92,22],[94,22],[96,22],[106,22],[-116,24],[-114,24],[-112,24],[-110,24],[-108,24],[-106,24],[-104,24],[-102,24],[-100,24],[-98,24],[-96,24],[-94,24],[-92,24],[-90,24],[-88,24],[-86,24],[-84,24],[-82,24],[-80,24],[-78,24],[-16,24],[-14,24],[-12,24],[-10,24],[-8,24],[-6,24],[-4,24],[-2,24],[12,24],[18,24],[22,24],[24,24],[26,24],[28,24],[30,24],[32,24],[34,24],[36,24],[38,24],[40,24],[42,24],[44,24],[46,24],[48,24],[50,24],[52,24],[54,24],[56,24],[58,24],[60,24],[62,24],[64,24],[66,24],[68,24],[70,24],[72,24],[74,24],[76,24],[78,24],[80,24],[82,24],[84,24],[86,24],[88,24],[90,24],[92,24],[94,24],[102,24],[108,24],[110,24],[112,24],[-118,26],[-116,26],[-114,26],[-112,26],[-110,26],[-108,26],[-106,26],[-104,26],[-102,26],[-100,26],[-98,26],[-96,26],[-94,26],[-92,26],[-90,26],[-88,26],[-86,26],[-84,26],[-82,26],[-80,26],[-78,26],[-18,26],[-16,26],[-14,26],[-4,26],[-2,26],[14,26],[16,26],[18,26],[20,26],[22,26],[24,26],[26,26],[28,26],[30,26],[32,26],[34,26],[38,26],[40,26],[42,26],[44,26],[46,26],[48,26],[50,26],[52,26],[54,26],[56,26],[58,26],[60,26],[62,26],[64,26],[66,26],[68,26],[70,26],[72,26],[74,26],[76,26],[78,26],[80,26],[82,26],[84,26],[86,26],[88,26],[90,26],[92,26],[94,26],[96,26],[102,26],[110,26],[112,26],[-118,28],[-116,28],[-114,28],[-112,28],[-110,28],[-108,28],[-106,28],[-104,28],[-102,28],[-100,28],[-98,28],[-96,28],[-94,28],[-92,28],[-90,28],[-88,28],[-86,28],[-84,28],[-82,28],[-80,28],[-78,28],[-18,28],[-16,28],[-14,28],[-12,28],[4,28],[8,28],[14,28],[16,28],[18,28],[20,28],[22,28],[24,28],[26,28],[28,28],[30,28],[32,28],[38,28],[40,28],[42,28],[44,28],[46,28],[48,28],[50,28],[52,28],[54,28],[56,28],[58,28],[60,28],[62,28],[64,28],[66,28],[68,28],[70,28],[72,28],[74,28],[76,28],[78,28],[80,28],[82,28],[84,28],[86,28],[88,28],[90,28],[92,28],[96,28],[100,28],[114,28],[-118,30],[-116,30],[-114,30],[-112,30],[-110,30],[-108,30],[-106,30],[-104,30],[-102,30],[-100,30],[-98,30],[-96,30],[-94,30],[-92,30],[-90,30],[-88,30],[-86,30],[-84,30],[-82,30],[-80,30],[-78,30],[-76,30],[-74,30],[-18,30],[-16,30],[-14,30],[-12,30],[-10,30],[2,30],[4,30],[8,30],[10,30],[12,30],[16,30],[18,30],[20,30],[22,30],[24,30],[26,30],[28,30],[30,30],[32,30],[38,30],[40,30],[42,30],[44,30],[46,30],[48,30],[50,30],[52,30],[54,30],[56,30],[58,30],[60,30],[62,30],[64,30],[66,30],[68,30],[70,30],[72,30],[74,30],[76,30],[78,30],[80,30],[82,30],[84,30],[86,30],[88,30],[90,30],[92,30],[94,30],[96,30],[98,30],[100,30],[102,30],[-118,32],[-116,32],[-114,32],[-112,32],[-110,32],[-108,32],[-106,32],[-104,32],[-102,32],[-100,32],[-98,32],[-96,32],[-94,32],[-92,32],[-90,32],[-88,32],[-86,32],[-84,32],[-82,32],[-80,32],[-78,32],[-76,32],[-74,32],[-18,32],[-16,32],[-14,32],[-12,32],[-10,32],[-8,32],[0,32],[6,32],[8,32],[10,32],[12,32],[26,32],[28,32],[30,32],[36,32],[38,32],[40,32],[42,32],[44,32],[46,32],[48,32],[50,32],[52,32],[54,32],[56,32],[58,32],[60,32],[62,32],[64,32],[66,32],[68,32],[70,32],[72,32],[74,32],[76,32],[78,32],[80,32],[82,32],[84,32],[86,32],[88,32],[90,32],[92,32],[94,32],[96,32],[98,32],[100,32],[102,32],[104,32],[106,32],[114,32],[-118,34],[-116,34],[-114,34],[-112,34],[-110,34],[-108,34],[-106,34],[-104,34],[-102,34],[-100,34],[-98,34],[-96,34],[-94,34],[-92,34],[-90,34],[-88,34],[-86,34],[-84,34],[-82,34],[-80,34],[-78,34],[-76,34],[-74,34],[-72,34],[-70,34],[-66,34],[-10,34],[-8,34],[-6,34],[-4,34],[-2,34],[0,34],[4,34],[6,34],[8,34],[10,34],[12,34],[14,34],[20,34],[22,34],[24,34],[26,34],[28,34],[30,34],[36,34],[38,34],[40,34],[42,34],[44,34],[46,34],[48,34],[50,34],[52,34],[54,34],[56,34],[58,34],[60,34],[62,34],[64,34],[66,34],[68,34],[70,34],[72,34],[74,34],[76,34],[78,34],[80,34],[82,34],[84,34],[86,34],[88,34],[90,34],[92,34],[94,34],[96,34],[98,34],[100,34],[102,34],[104,34],[106,34],[108,34],[-118,36],[-116,36],[-114,36],[-112,36],[-110,36],[-108,36],[-106,36],[-104,36],[-102,36],[-100,36],[-98,36],[-96,36],[-94,36],[-92,36],[-90,36],[-88,36],[-86,36],[-84,36],[-82,36],[-80,36],[-78,36],[-76,36],[-74,36],[-70,36],[-68,36],[-12,36],[-10,36],[-8,36],[-6,36],[-4,36],[-2,36],[0,36],[2,36],[4,36],[6,36],[8,36],[10,36],[12,36],[14,36],[16,36],[18,36],[20,36],[22,36],[24,36],[26,36],[28,36],[30,36],[32,36],[36,36],[38,36],[40,36],[42,36],[44,36],[46,36],[48,36],[50,36],[52,36],[54,36],[56,36],[58,36],[60,36],[62,36],[64,36],[66,36],[68,36],[70,36],[72,36],[74,36],[76,36],[78,36],[80,36],[82,36],[84,36],[86,36],[88,36],[90,36],[92,36],[94,36],[96,36],[98,36],[100,36],[102,36],[104,36],[106,36],[108,36],[110,36],[114,36],[-118,38],[-116,38],[-114,38],[-112,38],[-110,38],[-108,38],[-106,38],[-104,38],[-102,38],[-100,38],[-98,38],[-96,38],[-94,38],[-92,38],[-90,38],[-88,38],[-86,38],[-84,38],[-82,38],[-80,38],[-78,38],[-76,38],[-74,38],[-72,38],[-70,38],[-68,38],[-60,38],[-58,38],[-10,38],[-8,38],[-6,38],[-4,38],[-2,38],[0,38],[2,38],[4,38],[6,38],[8,38],[10,38],[12,38],[14,38],[16,38],[18,38],[20,38],[22,38],[24,38],[26,38],[28,38],[30,38],[32,38],[34,38],[36,38],[38,38],[40,38],[42,38],[44,38],[46,38],[48,38],[50,38],[52,38],[54,38],[56,38],[58,38],[60,38],[62,38],[64,38],[66,38],[68,38],[70,38],[72,38],[74,38],[76,38],[78,38],[80,38],[82,38],[84,38],[86,38],[88,38],[90,38],[92,38],[94,38],[96,38],[98,38],[100,38],[102,38],[104,38],[106,38],[108,38],[110,38],[-120,40],[-118,40],[-116,40],[-114,40],[-112,40],[-110,40],[-108,40],[-106,40],[-104,40],[-102,40],[-100,40],[-98,40],[-96,40],[-94,40],[-92,40],[-90,40],[-88,40],[-86,40],[-84,40],[-82,40],[-80,40],[-78,40],[-76,40],[-74,40],[-72,40],[-70,40],[-68,40],[-66,40],[-64,40],[-62,40],[-14,40],[-12,40],[-10,40],[-8,40],[-6,40],[-4,40],[-2,40],[0,40],[2,40],[4,40],[6,40],[8,40],[10,40],[12,40],[14,40],[16,40],[18,40],[20,40],[22,40],[24,40],[26,40],[28,40],[30,40],[32,40],[34,40],[36,40],[38,40],[40,40],[42,40],[44,40],[46,40],[48,40],[50,40],[52,40],[54,40],[56,40],[58,40],[60,40],[62,40],[64,40],[66,40],[68,40],[70,40],[72,40],[74,40],[76,40],[78,40],[80,40],[82,40],[84,40],[86,40],[88,40],[90,40],[92,40],[94,40],[96,40],[98,40],[100,40],[102,40],[104,40],[106,40],[108,40],[110,40],[-120,42],[-118,42],[-116,42],[-114,42],[-112,42],[-110,42],[-108,42],[-106,42],[-104,42],[-102,42],[-100,42],[-98,42],[-96,42],[-94,42],[-92,42],[-90,42],[-88,42],[-86,42],[-84,42],[-82,42],[-78,42],[-76,42],[-74,42],[-72,42],[-70,42],[-68,42],[-66,42],[-64,42],[-62,42],[-60,42],[-18,42],[-16,42],[-14,42],[-12,42],[-10,42],[-6,42],[-4,42],[-2,42],[0,42],[2,42],[4,42],[6,42],[8,42],[10,42],[12,42],[14,42],[16,42],[18,42],[20,42],[22,42],[24,42],[26,42],[28,42],[30,42],[32,42],[34,42],[36,42],[38,42],[40,42],[42,42],[44,42],[46,42],[48,42],[50,42],[52,42],[54,42],[56,42],[58,42],[60,42],[62,42],[64,42],[66,42],[68,42],[70,42],[72,42],[74,42],[76,42],[78,42],[80,42],[82,42],[84,42],[86,42],[88,42],[90,42],[92,42],[94,42],[96,42],[98,42],[100,42],[102,42],[104,42],[106,42],[108,42],[110,42],[112,42],[126,42],[-150,44],[-122,44],[-120,44],[-118,44],[-116,44],[-114,44],[-112,44],[-110,44],[-108,44],[-106,44],[-104,44],[-102,44],[-100,44],[-98,44],[-96,44],[-94,44],[-92,44],[-90,44],[-88,44],[-86,44],[-84,44],[-82,44],[-76,44],[-74,44],[-72,44],[-70,44],[-68,44],[-66,44],[-64,44],[-62,44],[-16,44],[-14,44],[-12,44],[-2,44],[0,44],[8,44],[10,44],[12,44],[14,44],[16,44],[18,44],[20,44],[22,44],[24,44],[26,44],[28,44],[30,44],[32,44],[34,44],[36,44],[38,44],[40,44],[42,44],[44,44],[46,44],[48,44],[50,44],[52,44],[54,44],[56,44],[58,44],[60,44],[62,44],[64,44],[66,44],[68,44],[70,44],[72,44],[74,44],[76,44],[78,44],[80,44],[82,44],[84,44],[86,44],[88,44],[90,44],[92,44],[94,44],[96,44],[98,44],[100,44],[102,44],[104,44],[106,44],[124,44],[126,44],[128,44],[-146,46],[-142,46],[-124,46],[-122,46],[-120,46],[-118,46],[-116,46],[-114,46],[-112,46],[-110,46],[-108,46],[-106,46],[-104,46],[-102,46],[-100,46],[-98,46],[-96,46],[-94,46],[-92,46],[-90,46],[-88,46],[-74,46],[-72,46],[-70,46],[-68,46],[-66,46],[-64,46],[-14,46],[-2,46],[2,46],[8,46],[10,46],[12,46],[14,46],[16,46],[18,46],[20,46],[22,46],[24,46],[26,46],[28,46],[30,46],[32,46],[34,46],[36,46],[38,46],[40,46],[42,46],[44,46],[46,46],[48,46],[50,46],[52,46],[54,46],[56,46],[58,46],[60,46],[62,46],[64,46],[66,46],[68,46],[70,46],[72,46],[74,46],[76,46],[78,46],[80,46],[82,46],[84,46],[86,46],[88,46],[90,46],[92,46],[94,46],[96,46],[98,46],[100,46],[102,46],[104,46],[106,46],[108,46],[124,46],[126,46],[128,46],[-148,48],[-146,48],[-144,48],[-142,48],[-128,48],[-126,48],[-124,48],[-122,48],[-120,48],[-118,48],[-116,48],[-114,48],[-112,48],[-110,48],[-108,48],[-106,48],[-104,48],[-102,48],[-100,48],[-98,48],[-96,48],[-94,48],[-92,48],[-76,48],[-74,48],[-72,48],[-70,48],[-66,48],[-4,48],[0,48],[2,48],[4,48],[10,48],[12,48],[14,48],[16,48],[18,48],[20,48],[22,48],[24,48],[26,48],[28,48],[30,48],[32,48],[34,48],[36,48],[38,48],[40,48],[42,48],[44,48],[46,48],[48,48],[50,48],[52,48],[54,48],[56,48],[58,48],[60,48],[62,48],[64,48],[66,48],[68,48],[70,48],[72,48],[74,48],[76,48],[78,48],[80,48],[82,48],[84,48],[86,48],[88,48],[90,48],[92,48],[94,48],[96,48],[98,48],[100,48],[102,48],[104,48],[106,48],[108,48],[110,48],[120,48],[126,48],[128,48],[-150,50],[-148,50],[-146,50],[-144,50],[-142,50],[-140,50],[-136,50],[-134,50],[-132,50],[-130,50],[-128,50],[-126,50],[-124,50],[-122,50],[-120,50],[-118,50],[-116,50],[-114,50],[-112,50],[-110,50],[-108,50],[-106,50],[-104,50],[-102,50],[-100,50],[-98,50],[-96,50],[-94,50],[-92,50],[-76,50],[-74,50],[-72,50],[-70,50],[-50,50],[-48,50],[-4,50],[-2,50],[0,50],[2,50],[4,50],[8,50],[10,50],[12,50],[14,50],[16,50],[18,50],[20,50],[22,50],[24,50],[26,50],[28,50],[30,50],[32,50],[34,50],[36,50],[38,50],[40,50],[42,50],[44,50],[46,50],[48,50],[50,50],[52,50],[54,50],[56,50],[58,50],[60,50],[62,50],[64,50],[66,50],[68,50],[70,50],[72,50],[74,50],[76,50],[78,50],[80,50],[82,50],[84,50],[86,50],[88,50],[90,50],[92,50],[94,50],[96,50],[98,50],[100,50],[102,50],[104,50],[106,50],[108,50],[110,50],[112,50],[114,50],[116,50],[118,50],[120,50],[122,50],[126,50],[130,50],[132,50],[134,50],[136,50],[-148,52],[-146,52],[-144,52],[-142,52],[-140,52],[-138,52],[-136,52],[-134,52],[-132,52],[-130,52],[-128,52],[-126,52],[-124,52],[-122,52],[-120,52],[-118,52],[-116,52],[-114,52],[-112,52],[-110,52],[-108,52],[-106,52],[-104,52],[-102,52],[-100,52],[-98,52],[-96,52],[-94,52],[-92,52],[-90,52],[-88,52],[-70,52],[-68,52],[-66,52],[-52,52],[-50,52],[-48,52],[-46,52],[-4,52],[-2,52],[0,52],[2,52],[4,52],[8,52],[10,52],[12,52],[14,52],[16,52],[18,52],[20,52],[22,52],[24,52],[26,52],[28,52],[30,52],[32,52],[34,52],[36,52],[38,52],[40,52],[42,52],[44,52],[46,52],[48,52],[50,52],[52,52],[54,52],[56,52],[58,52],[60,52],[62,52],[64,52],[66,52],[68,52],[70,52],[72,52],[74,52],[76,52],[78,52],[80,52],[82,52],[84,52],[86,52],[88,52],[90,52],[92,52],[94,52],[96,52],[98,52],[100,52],[102,52],[104,52],[106,52],[108,52],[110,52],[112,52],[114,52],[116,52],[118,52],[120,52],[122,52],[124,52],[126,52],[128,52],[130,52],[132,52],[134,52],[136,52],[138,52],[140,52],[-150,54],[-148,54],[-146,54],[-144,54],[-142,54],[-140,54],[-138,54],[-136,54],[-134,54],[-132,54],[-130,54],[-128,54],[-126,54],[-124,54],[-122,54],[-120,54],[-118,54],[-116,54],[-114,54],[-112,54],[-110,54],[-108,54],[-106,54],[-104,54],[-102,54],[-100,54],[-98,54],[-96,54],[-94,54],[-92,54],[-90,54],[-88,54],[-86,54],[-84,54],[-82,54],[-74,54],[-72,54],[-70,54],[-68,54],[-54,54],[-52,54],[-50,54],[-48,54],[-46,54],[-28,54],[-26,54],[-24,54],[-22,54],[0,54],[2,54],[4,54],[6,54],[12,54],[14,54],[16,54],[18,54],[24,54],[26,54],[28,54],[30,54],[32,54],[34,54],[36,54],[38,54],[40,54],[42,54],[44,54],[46,54],[48,54],[50,54],[52,54],[54,54],[56,54],[58,54],[60,54],[62,54],[64,54],[66,54],[68,54],[70,54],[72,54],[74,54],[76,54],[78,54],[80,54],[82,54],[84,54],[86,54],[88,54],[90,54],[92,54],[94,54],[96,54],[98,54],[100,54],[102,54],[104,54],[106,54],[108,54],[110,54],[112,54],[114,54],[116,54],[118,54],[120,54],[122,54],[124,54],[126,54],[128,54],[130,54],[132,54],[134,54],[136,54],[138,54],[140,54],[146,54],[-146,56],[-144,56],[-142,56],[-140,56],[-138,56],[-136,56],[-134,56],[-132,56],[-130,56],[-128,56],[-126,56],[-124,56],[-122,56],[-120,56],[-118,56],[-116,56],[-114,56],[-112,56],[-110,56],[-108,56],[-106,56],[-104,56],[-102,56],[-100,56],[-98,56],[-96,56],[-94,56],[-92,56],[-90,56],[-88,56],[-86,56],[-84,56],[-82,56],[-80,56],[-70,56],[-68,56],[-66,56],[-64,56],[-54,56],[-52,56],[-50,56],[-48,56],[-46,56],[-44,56],[-42,56],[-40,56],[2,56],[4,56],[6,56],[8,56],[10,56],[12,56],[14,56],[16,56],[18,56],[20,56],[22,56],[24,56],[28,56],[32,56],[34,56],[36,56],[38,56],[40,56],[42,56],[44,56],[46,56],[48,56],[50,56],[54,56],[56,56],[58,56],[60,56],[62,56],[64,56],[66,56],[68,56],[70,56],[72,56],[74,56],[76,56],[78,56],[80,56],[82,56],[84,56],[86,56],[88,56],[90,56],[92,56],[94,56],[96,56],[98,56],[100,56],[102,56],[104,56],[106,56],[108,56],[110,56],[112,56],[114,56],[116,56],[118,56],[120,56],[122,56],[124,56],[126,56],[128,56],[130,56],[132,56],[134,56],[136,56],[138,56],[140,56],[142,56],[144,56],[146,56],[-146,58],[-144,58],[-142,58],[-140,58],[-138,58],[-136,58],[-134,58],[-132,58],[-130,58],[-128,58],[-126,58],[-122,58],[-120,58],[-118,58],[-116,58],[-114,58],[-112,58],[-110,58],[-104,58],[-102,58],[-100,58],[-96,58],[-92,58],[-88,58],[-86,58],[-80,58],[-78,58],[-72,58],[-70,58],[-68,58],[-52,58],[-50,58],[-48,58],[-46,58],[-44,58],[-42,58],[-40,58],[-38,58],[-36,58],[-34,58],[-32,58],[6,58],[8,58],[10,58],[12,58],[14,58],[16,58],[18,58],[20,58],[42,58],[44,58],[48,58],[50,58],[54,58],[56,58],[58,58],[60,58],[62,58],[64,58],[66,58],[68,58],[70,58],[72,58],[74,58],[76,58],[78,58],[80,58],[82,58],[84,58],[86,58],[88,58],[90,58],[92,58],[94,58],[96,58],[98,58],[100,58],[102,58],[104,58],[106,58],[108,58],[110,58],[112,58],[114,58],[116,58],[118,58],[120,58],[122,58],[124,58],[126,58],[128,58],[130,58],[134,58],[136,58],[138,58],[140,58],[-140,60],[-112,60],[-106,60],[-104,60],[-102,60],[-100,60],[-98,60],[-90,60],[-88,60],[-82,60],[-80,60],[-78,60],[-76,60],[-74,60],[-72,60],[-70,60],[-52,60],[-50,60],[-48,60],[-46,60],[-44,60],[-42,60],[-40,60],[-38,60],[-36,60],[-34,60],[-32,60],[-30,60],[14,60],[36,60],[46,60],[48,60],[50,60],[52,60],[54,60],[56,60],[58,60],[60,60],[62,60],[64,60],[66,60],[68,60],[70,60],[72,60],[74,60],[76,60],[78,60],[80,60],[82,60],[84,60],[86,60],[88,60],[90,60],[92,60],[94,60],[96,60],[98,60],[100,60],[102,60],[104,60],[106,60],[108,60],[110,60],[112,60],[114,60],[116,60],[120,60],[140,60],[-112,62],[-110,62],[-108,62],[-106,62],[-98,62],[-92,62],[-88,62],[-86,62],[-82,62],[-80,62],[-78,62],[-76,62],[-74,62],[-54,62],[-52,62],[-50,62],[-48,62],[-46,62],[-44,62],[-42,62],[-40,62],[-38,62],[-36,62],[-34,62],[-32,62],[-30,62],[34,62],[36,62],[48,62],[58,62],[60,62],[62,62],[64,62],[66,62],[68,62],[70,62],[72,62],[74,62],[76,62],[78,62],[80,62],[82,62],[84,62],[86,62],[88,62],[90,62],[92,62],[94,62],[96,62],[-102,64],[-100,64],[-98,64],[-92,64],[-88,64],[-86,64],[-84,64],[-82,64],[-80,64],[-78,64],[-76,64],[-56,64],[-54,64],[-52,64],[-50,64],[-48,64],[-46,64],[-44,64],[-42,64],[-40,64],[-38,64],[-36,64],[-34,64],[-32,64],[-30,64],[-28,64],[36,64],[38,64],[40,64],[62,64],[64,64],[66,64],[68,64],[70,64],[72,64],[74,64],[76,64],[78,64],[80,64],[82,64],[104,64],[106,64],[108,64],[112,64],[-108,66],[-106,66],[-88,66],[-82,66],[-80,66],[-78,66],[-76,66],[-74,66],[-68,66],[-66,66],[-64,66],[-62,66],[-60,66],[-58,66],[-56,66],[-54,66],[-52,66],[-50,66],[-48,66],[-46,66],[-44,66],[-42,66],[-40,66],[-38,66],[-36,66],[-34,66],[-32,66],[-30,66],[-28,66],[-26,66],[4,66],[74,66],[76,66],[-94,68],[-86,68],[-84,68],[-82,68],[-78,68],[-76,68],[-74,68],[-72,68],[-64,68],[-62,68],[-60,68],[-58,68],[-56,68],[-54,68],[-52,68],[-50,68],[-48,68],[-46,68],[-44,68],[-42,68],[-40,68],[-38,68],[-36,68],[-34,68],[-32,68],[-30,68],[-28,68],[-26,68],[0,68],[2,68],[4,68],[6,68],[68,68],[70,68],[74,68],[-86,70],[-82,70],[-80,70],[-78,70],[-76,70],[-74,70],[-72,70],[-70,70],[-68,70],[-66,70],[-62,70],[-60,70],[-58,70],[-56,70],[-54,70],[-52,70],[-50,70],[-48,70],[-46,70],[-44,70],[-42,70],[-40,70],[-38,70],[-36,70],[-34,70],[-32,70],[-30,70],[-28,70],[-26,70],[-24,70],[-22,70],[68,70],[-74,72],[-72,72],[-70,72],[-68,72],[-66,72],[-64,72],[-44,72],[-42,72],[-40,72],[-38,72],[-36,72],[-34,72],[-32,72],[-30,72]]") }, function (t, e) { t.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAC0UlEQVRYhcWX6Y7aQBCEe3wCS97/7fIA+zuAbXxEE3VvPmrHLIkixVJrDLKnqquvsf3vK2X87+/jqzQqt4Q12+a2+rr4+uXVvAhcuzW4T0LAHHhxIjN+715fEcibt7Dafq+VrwG+AfCONayoyDMCefPOATtYAyUqKLA66AzQCc/dS2rsEWgAeDCzHtYKCUMOzADONgrZyZ95SqAW4KPfH0EiCEYOmHg/CnjC/huVUAIJkmegk9sRa2+PoeCms3s5uEXiJjy3Obm1RKCF9wH65nYSEq14x7jffJ+QniUauTIpgVq8DxJnN5I4ACBBgfC+Fc9XGMtzKRFoEfuwDP4NahyQC+FhxL5H7OmxlmVNAhVe6gthOEGJs/+OMCQ0nsHfreA5c4OWScwkUEG6qP89Em8IQ4RgQnIaSEU5doUSruLhJO2WzYf5EOE4+32HEIwAJ/AAVVtt51SgFmtBhtVxAJHe31kL4ANAdY6E4g8KGKZctNgGLzdSJdEnajSW2b1uAfwJFDmS4kabkY7bVBjDQey4MyH1Xd0vhfR6xdRaZdKxljfJ/Mj0TZ7d5D+T/x5aKRsGZ/osfZ5DZkMORP+/y3sktyg5lswiNhdAI6uZcAlVcHMb/PcEQnch9UuVpiCxzvMBwKzzxf9nH8jPXDCMwiZRJnA2bkavtYYvyGRmuzaiUOGHmV2hxoAOGA6ubMWbzPIOBFrJ8tU34ixYQSpUuIBIicSDAlY4ULAHVAAnyb1peAWJG9QYQWBhFRg2KHWtTXr7gOZEAneE4YpwDCAQufWJgEGBQY5bCtDJgUSn3gAlbghDVNLHuVAJRDIlGak62VoJjSo07ZTlqEf00qH047gkXYyZXzoVr1Bpkt4xIv4PR/MSAUPn0rP+q98Fs8R7+tPvAmO3Es9KCco8WaTp/PWXUb6i5vOmGTDOcpxuSvqffhvqxnlTHa36HNv688vMfgIIVK0bvilzugAAAABJRU5ErkJggg==" }, function (t, e) { t.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoxZmEyM2UzNy0xZmZiLTRlZDEtYmM0Ny1kNDM1OGVjOTA4MTAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MkJGNTJBODRBRjc2MTFFOUE4RkNFOUI2NDkzMDBCMEMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MkJGNTJBODNBRjc2MTFFOUE4RkNFOUI2NDkzMDBCMEMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxZmEyM2UzNy0xZmZiLTRlZDEtYmM0Ny1kNDM1OGVjOTA4MTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6MWZhMjNlMzctMWZmYi00ZWQxLWJjNDctZDQzNThlYzkwODEwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+q5YvGAAAHtNJREFUeNrsXU2PHUfVrqrumUliTEzkyBAUE0GsgAQBiZAFSCxAgjUbfgRLJOB/IJDYsQL+AjtgASgQgrAUWUSKnEQoURLiOBgbZ+Z21Vtdp87ppz66uu+dGdvwTqvVU9O37719n/NZ56NaqbPtbDvbzraz7Ww72862s+1sO9v+v236Ab2tcF/OxcHxN/oof8y+JTvzP0sArf8r2fMekEc/OEBn7z0p9icQyw9/QGij7wvoD6xA7ADrMSmh7w30uyG+s47GNx5H0a9/485foU8J/eO8OgeovGulLd0N+sZbFj9th6/TJ47+3Es7vOX+qp3dKLEtDfRJQV89vzPoDTd0vXHOhEY+86QosQPljkuAlShnZxYvOI5AVJ2cnbVE+epJnTkVAhwf+pVysK1C3/aNiwi2L7hHBGhgt/IlVCyCS2Zg8foGd6OTs/OsGD+fxnOaag7u45NhRwKcxrjq8MwpnMZva5uNrZj9OOOTJMBWDJ6NdyPDMeeuSMWtlL78uwjxbjKxCwHWQ7zy1er1x/FHdwtaLELfxnrlZYtk2JEAxxzIeKVNnvNHyznXeg915XgN4uuJsTsBqkjNAboe+q2copUaac2HNEBv8Psc0CtFZBcCrGHeEtA5AjTesga+HdzQttw0wF2D+A7k2ZEAK9FvEKNBnm2FYJVl01tLwNxxDYW2koxs63eeiLXZmTz9xTNzZDimBV78NLoZa7eO31XjgMeJBur17C8IzvH13KvrP2G97i5/2FbBqAbPznF6lfHx4qotWbQE/c5SPIddA/E1ZNtWIhtT4nYoMMNrcdqBzF4Nj1f5fVEI+uP7oCWUiypIThqTf1QRHtBVYQ8DXdyew+9ijFwVU//VooIkMlEaJH8NvSoDfGNp8+cSQbNqalv9UwW9fFX26sXllSnKusZZelGiG/SAT3NzaqdUL3MXLJ5fr4X6lZK+xjWa85fmEJ+5QKdyoFP20QsMFXH3H+LgYgf3ppEwWUBwTdy0yu9rFE711X4rA9CgxCKD09HL7/z1ms+PAxL5jPFJ84hyqM2BCX0i5UQP+OWiuVyJfsM1ovtBpUQ/p/Q455TPFiqo1PJVbSOYZtegZqe9PANvTHBP70pnygf4TqOYp0Lp0jNOhCBc7CZudtMZwj1TL41/566v6qjSTVqQABG0RVGYm0YtUg4VDnCrFgLQv+G+deGK6Mx1SeHWjfljZsmtjZrKmMQ2NIqUyqBT5jjMpYO2UEGL09pSsVQtcLanZJhA500Ewt+m4R+jmQyCnWb1oWtOl2PyuHBX0R6QyxROxlfDGRtei59GFwiriqohzyfTKv7VTPhYZ1byPLu7oWvMwyLuhdrRfEbzUYsuCrAa/uQoAfJ2xlFXZY4Mb6oGR3IS6EQMUjgMuiGniLF2yNQZ6Bms4oweszBrmQBVdbQG9MYF/hW2xkYowZqHvmaSAGb5EXcPJYp2ypXE+1EAmB40duFoAtsnWgjyo+OLRBg0s40EUaaFdqsG61fOAJZUebIT9xHE4PyQqtXI+6x/4jiVg2iBkQCsKCpmTdgf5MCxVYj0YIqSX+SCKtJ09MaANBWdJzWVOVqpJlzO31Vplr2xP77+KUlViEuuc4JOQEoYMQYEPbpATADNiOviF2qGOPH6mQYlGQgDS+gHbe5Itvyr1uqgfFwQUycOD87eRd0vhi7aLtAqI1z1N+agL3dwUieNL7qCiCGiILxPmoePk+8fyKDn3G1UPuKSskwgGYj3yUrYcJNxfkw0EKKGb3clDtmZajyqAfp2ElCNRoh6mVP6oH9GhhKWJ7hxqxJApAHYX7PnozF0w/Rw/NUOjLBDArCdcC76QCQKJvpEk6evg2/q2Dcd5YCEQMxyFjuh88NQz4+2ywP63Xye6gyg2DUTA1XQBHocRr+ItJARFcQaX1hei1OEirjwhjNKkArKJYANgCV8R21v/ctWlIxoHghsVJT7Gr+zbZDXxoLmknxrPJ8IcBSCEfIgHwYMQCSGsD8b4fFoR2ddBYBEPiJGRBKZgsFUwIWvkDmwwyOzvyU3NABtiNlJzgL6LjUwmmUimQGUnk8ZI9kxFrQm9tl1DY2UqPighQwTQI4GpGBSRIT7aBeNWIJojfnniTQkYW3CN3wX/WspqsQCYQMP2YC1Y8dGRMGJD0oEIVIFdRR1EY0z45eKy2y0bk4O+vV5vrbzk/K+ZlzQ1UG/U4hh2CYbEpGAskGPiHAPLDpNBTCUX6hHUf1kQk2APnIxH22QLcvCZMLY8EtTzI6cWiIXu7AVbbNzS0i/rQOK0JP9oYGXhkwRmTgZNTzJmvQ+aXySAKJBuCySgSSApsTBKSQH0QTcx/dzYFKn2sABB3g5QO2v2Q5bHuggCop53AXdMl7gv46EjN1NIpgJbmuST0ZmLxWR6KJdMmLtIoa5M+x0apl2kfJhva8Z8cn+giIiqkTlE36w/wGRHux9EiiGvojREfQdOGAOzlgxAMD+5P7rYAlIBflvHAKBDb1KYuTvINgDSwIQyJPHseV+VLNpYEcvaC7xMpMTnrQNGwYNikiQT3APykcIEI+kiwKbE9dH1yhAYKqh0ACEFdeThICAYy0kcWlxihR7mZ7aHRmDQDNDxkO0GUzxNL+9boRLmdg6KU+6pap2JMYgMyy0wHxGLLAo+Qh0+H881XXjITC1XGSY9ykeZ0hFB1k2PKUwRA+4N02BTyaACfoE2d+yuiO3x5JOJ5PLQkBelu26kRjh62zwAizpwKB/XLglSz/ce/1p5nl2BpDFpTML0S/WgLRLozMiMdl0ewswGbABpusMTwLigL2gyVyzatYcLYg2ACbbDtxQ0Tme1DZIRow/kwFgAozW15DCsyR/cW7MwddpAkjSULY1HKcRs19MtqxJzmA6BaLLEylQDsAUR/SJHnQMup5oQAJBPqEeBg2qSVKMMfcLUzCysbLrQAm6DQr+WOFccUYl3cg/x4qmSQN8EpwQh2hd9dV8zrnfygdtJ35rkwA0sJPXT/weXuxYA3XhxY4IEI4dOaZe6MU7CspBS6ogY0MxuSIE4Y2T/Qxz3ehiBaJaeCNpnEyXkreqyCSQP0ZBoxIKmX+hj7R7Qkbs+2I5YgqBhrSizhJeYoHp9wtJWB1FvUTH4JtPNjkgHq+nOXCaQhC3x/DAMj3oi8R0WLRzhHiYZ5HV1eIHS0BQQtlszytxQCw02kod9btpLolAQbZdY3xYXFIRCLG1pF5ANYlZNoHBDel9UkrBEhBjdlyMlQgB8gon3K14nMwHtqoQMIbKxHDsaCENlNZoDBR8fl4nsT4OWiFA5ten9q2icMD3mFidf7PBeAPoIs1xIcK9i74SmwEmAElAR5QQufFjMgbEm8J0bAOcKOjwhQ6DoxgGx3KKoN9p1ujY6jhyFCQiBA7EZA/8BeQLocNSBoL8mAKlyzZgTQRiRQ2LpBs11jcw72tWMhNt0BQHp8Xj24kEkN4PZyLxiD2zmhqI+9PMi9SODZQYsuAgkSHgS+6vizc+mg1vG0x4i9yzZWaPFti5emnXysa0lgrKfJ45kmS2oSg0mhx1DOyILNOEAKdj4piGT+jYBepY55CsYLzaQI7eQQhIlINlEeTo3UiMqSgIEQ8OPnk4IiKaOT3OwyVdQT6SRDgWje0WoYiVfQ2k/WWylpW2YZpXAs4sGQanwuwIGZ6dGXFAgwskXmkndiJ4RBp9XNbR4neSArEwI0GFKdNgw9Fpg6Y7mJyYpaEZH0S/Nef0pe7Rtb3zbJK8HIrYttkhnW3rRtiOXXWFJhSnCxD+lBkZgdthbI7lyUiMGgoOCV/LYjdOV/ldSjidQGdbTRM9f2ZAAwa1AdG1o+xxWYuXgZCZ4uz6aoFiv1LjFwXMs5kZYMxkC8yloPInDweJg0RAh4BPB/pnmk/QXAHcUAcJYUthH/F/AEoNWXvNvG9TMyDZCM1igaUYGtSsw+Dozl0C/eIsTHRcVsvvzT2FoKVgBBK2jqOY4r1MYU7x9MOAIO7CmS4MPMt3wf8hrDsyy+QvkYUQyChGLVUklH5hN3Tw7msgBkFsmRgDk0dBlG0KoIrQOGAiFhQ6oyggWvI4wZLVj6YZ7HUz4epUK6PNTHnENP/CGZkobnZ4aLqbhOrE9sp0jHyhMBftwj6+GubDfux9O80ZAiwB0kF6BggUuvBRipWPC1+UuK2BMxwmkEkIZEY2V46XlQxn+qe8bPecMH06sXwWBMWBV7XBw4k37a/3J8NRw5h2uoA8IidTUAznevc5wD2GTv3Y72QYh6ixaYJGszwX9jGB0PeW7oE/fBxAukLU4Pg5dCfD4LDakD1UFSKjUdtQoFSCr9m0C9VRxrsL2G6l/efb7XQajSiPOn0JLbBOJw1ZTdxUlQXnpUR3qsqC1LxDmUjLgaacJaV8RZdzQVySLsaXZIhvUiu6XNXqpu2z7T5s93/9yEaHwWJ3QhkRW2yEVzstKvM/RYD2uhHtBT3Ktog2VRoEWFQX/1MEaOTx1YpFDaohkMz6SXVQdc7Z1tRb9TWe7NbfM05f0y7Zpk05r8H4Vxmmb7Sul0fx3zPSnjYl9OlBXwKNnUwY6FZqVVNx6RZjGABczLpiabcBz11w2mLRnzbuRdVQVrOeX6yaXfZobGmqiZU5ZSimoWQafY0oEyUlTpYM+mT1e5XfqwUsVcJsJQc8U8uq4SsEaHC3KnpOF/fsLfdZAhabxTLQpdwIQZeWJjXfAlXaFSon4aRu3NeonTncheVRwjC2M6eU1L1fvDsrD1bzXRtSxTXXQdZo8EObITVh8oNDOCiSQfYyK9tQ94g4jTO10/4Xz+9MBn18ri8BTaNDC/Qo/02lQadN9OLt6IC+o6xs18UoU6qpHcDt5jQ7wYfnM2KUgzY9TlEFYaPaIqDlce4kjHWtf1iljcQx3+AR32ziGwMBHDfXKYzwTH+dtAc7xJTQxzNS8o/lPRKtE+gzkcJFJk6xPL0MgmbMvngsxEJDLWmWztTS3Ir5fQrPEVJBAhxJADWMCOhS5Cw16FwN57gRwzHQruR9IUBGGylCEcKU9FhPhu1alKpsW+LbGMDF2ClGceOsY0BJ/1jaTK9FBZEE+F/a98rvbAMStqchE2AsBWUhcGFoAWKqzK0QQERBSueEAHSm9KOq3d5bE6Asiq6q+Abcxb8Ct87Kp/lk1kepsH8GF7BBU+TRJwmQLjAgQLlZkgkiBo6ZKiqjBLm80JeQ0AOyCBVZaYvCKgmoquxS52Sgk1Xkl2KbGFeoaxhgbcREGKkCohw6NhgrNf1m+gomgOOFOlD/xNawWAk9no/IA+jW0elIgEgJogHCjRKQJb9ECAR3f0sY4diOAJnSR8Vd5fEU7onfeWCkFsjwJuhLYRZWKkptnbWGu1mmghRrNbmhXgtlzUmEfril2KQXzlhBPBDDAtdbHDAZrNDAvyTdALJjvjcTApSGRvi2RYA59KvafG4PGUGBfsI92wR6rg7qGHRN9bkf+Yi5eFE/+qh+7DH9+OP6wgV1/rx++GHtuX5vLxSfDO7oSB0eqjt33L/+pd57z737rvvgA3fzprtxwx0eUm+M7XuhAZJhbjNADAXtx3VKIPpl/KMhB33bza+a3DU7od91Zn7rUhp0VIgYUu2dx/ryZfP00+aZZ8zHPz5Cf/68CXAbXEZLkpHifKq4LJ+7c0fdvGnfe8++9pq7ds2+/rp980179+5YHLe356EfPPrDYI0BtveMPmQ0GMJUY6yoIGeJxK5NCZyly+R8brKm5wjQ5v0C7lztBOg1E6BLKRH/DczeEQGGYayBuHjRfOEL5rnnuoC76Xuqxh2pEi6Qrnmj6j3psiSBpRy953oq/vEC8frrw9Wr9qWX7Kuv2g8/tJ4MWg8EcTiOBPDHlAjxPy9kqJRoBi579m/mPmW+bJ7Im2P/tmNThR6qHwjmDPtxyP923JphNptxfOVK981veujNE0+MhUCbjT9vqDWD6ouorIgKTOC2DSTZp2w7598HLtQdKeERN2a4c8f+/e/D735nX3jBvv/+sLc3BO4m0DdBLDIy+CGJhuP/XYl7lQaZF5uRoUKAzNlfp+hz9JHbu47+S47E+H7sWd6j/8wz/Xe+Y55/vnvkkZEYR0djYZZUqIey2al1SZro0/vHcgebrk0whDNUnjWyvLfMBwf+5PDaa8Ovfz385jf21q1hf38I7D8EoAcmg7D/wNDHo0RBFuUgkwCuc4FMRkP1NwiQ4i7o64zxgQBxYEwfWvJGoC9c6L/73e7b3/bQd4eHfVAyJqCPNOjCSeF9w+hPRSvA+FKBYpkYVmgQKs4HPjN4MnTd8Morwy9/Obz44jgmjUTQ016SAWiQyAEeZd4gx5IMQoBujfJJVXyVAFHzZPzedX2XSAH9u+fhfvbZ/kc/6r/6VW9Ye/+vtXvO0d47tx+Oe/6knA+DfWv38Upr+3Blz2+UvaOaRip0lIprrL729D460pcu6a99TT/yiL52Tfl/qZYLqpWqlRlusWZ58TlEsnVzyiebcM1BL+gz4yfQC+/3fR/Q98cR/W98o//BD/YuXerv3t0LIMZjdWcy7IdBH3CPcPOgQ+gD6D0XOnYAfQedsLFa0oPuEX/2WfXkk/pvf9OHh1TFXTWNmbpbwHexYyBO1rJkVgN6lAwJ/7LV1ZnGJxowAUb0iQCHh93Xv95///v9/n7/4YfIvBkN5KV9OjLjR9C9KKSX7TEZIvqixEgO0s6OrGh1nM19+tP6ySfVn/8s8aWy4N5lQiBFvivzxtWFtTpMdIgcUA1o2+dhSiSqP1X3Hf8TybDZ9J/5TPfDH3YPPzzKAbBtpkAiyyN5gN9HUokQZJonZXxTsjxAj42F2uP+1FPqoYfUSy9NIY0Gv8+tmbsmDoqXJTagqn+Wpr46d+/jIMpBGER15Pfvfa97+mnP+/57RXXssSpPUAaZ6OHMXkYwMQOs7oXxdUoDXSzLq7DTkeZKV664V15Rb75JDR1YOZpkGmB9V9d4BIRSy+sZ93NlaFlVe5nrkZVUcZfOFnBdoh748EPzxS+aL3/ZOzyiH7JBhwo9ICvnqTadxpo/VkPJuOP2GMtdwdRoJ0vjEKYKo3Xh2FFo2nOKN8sHB94rc3/9K/ljtLCTCXM0+V3JLw0/bZh7elW2FnJ1uYi+bcfLQgRcR5zTU1rWM+T22hjLDPXfXrrH897cfelLem/P3L0bERR3EzzO6Qxf0Af0e/5XXioJYPlIoFAkdRCVnVVBc6A06U07OjJXrowRp7feoi4dG6J+JnifhuOjmvfod2azrbmi1eoCT312kfS9lGJVLSmQNcSiQI3Bg1Gf+g/hVYejb+d/2+XLcUILLryWuS5zlkGUCXd+V1eQAQkwhNUgpjR14GvCmhouZaVWacKe+sLpvOeVj33MXLigr18fI30eZc9DDHpsUKA99CtonApkhRSNLDGe7DPHSLI8kuBGFVSm5ZgMcak1gH60z9TTQdtm4/b2HPZHpC1XGlfLTZfuUzINToVDZmdOFiCAPkgbXrWywBwswqfTG1A47kdIonvK+AoNYiWAhKklZ4CT3sWyono0tF2YttSpocslg7Lcrz9z44ZO3bjEpYM1bZPATjr3SRZDoWQLhuHS0JBKV21VtY9Kvsifv317DGt7MpQFMrTcYpocdXM1NWWMup7s2qr2JPOReBrswj6O+96FnU6OF/CZkf1ffhl/rS1CCBMLw+JujhdAGcjGBrXutc0m7EfGjHtoyRt3jjfEnb6F7bME6RySAdaZGG/yrbfcO++ohx+W2x5/QvgtNhy1VGDIr5ZklHiJGVZqfu2xvlHfqWpLNBbOqGNmpy4tIoYNDigdXbhd99BD3ruwb79tLl50h4fE7DFM5twQtMTAq8IMtH5VQFBDZtSBAcA1XRW0yVPkZyj2GALiPlY6ClHjIjce6z/+0XkJODhwIdozJgP4VqclSHGBb17BNFHaOK76P3ksqKzIzHKQ2TQ4JYOhI03K2P3X8i+95P2fW7fGwXPPjZYNl2Ytp6aw2k1FU3F/LwJtA/tvSAiM2ZBAhLa9DV2DIoKyIuOHHhreeGP4+c/HGBwIUCQPLe/HCU4ZKFGDjaLgxjygy0r+VPGcnUaVJy9BguuDGl4LCJfEjb6q95FefVV98pPaz/u9v5EZQ3yGDLIbrsEEuFvqBGagCeUNDZgAG9zpAiYSabCJAHt7w9HR8JOfDNev+7ENQemYpaHkZZq/THL3ZSlRo+wuI0aXGeHGw0hmCsqTVZnAGhuVLhJD9VXeTbp6VT/1lL58WfMiLtNjjXDlVel3ROgDWJbZWSRggptpcMS4Ixno5ICU8Ge8g3ZwMHL9z342vPACoT8mZyQjxtAPmL2HKop6RReG/stSRhGObn2Nf7EsejKhT4mhquVs/ujV13/+o198UT32mJ/3E3dohB6b1pnfHfW8Aw1Ee2wYU5SA6cigV/f4rnPnNjdubH760+H3v9/s71MCYEP5GU7OSNJYxo5TAq5aS5qNszwMOqNd2UW02GdRIxU+gid7KJhK1ctoQo6O1J/+pD74YIy9fPSjVBko0OcKp0Q/nMm4m8ZHQJVMFMr96ODAI775y182P/7x8PLLgx9zEmaTZmMkP4OKKJ8EINwYNShLr1ELde2alAZhai5TlsTI8p1awgFhduauXVMvveT299Xly/aRRxQsmorQO9E5aDBn1AvifhSIdMTSMF3QdSPuHv033tj84hebX/1q8/77m729DQO9Cdw9hCKJQRQR5MXEANTVDvJ+te8DM2LLOeG5fECZkpQ6FMkKY0qSo6W9hEv9Thn5z362+9a3uueeMxcudMMwRuuGgSJ0BiJF1ZxwmatyGBciX1P8Tm9pvYr3IHpL+9vfep0zhLy8h3MTNMwm5feEAJyJFBUUyyMaqeC5tHDS3Vatw20UwWVJyiwpzxVBHdAgT8pzUZDUpPSbzXjmySfNV77SPf+8+dSnxgS9R9mfDzl6CR9hVYRO3T4Hk7gkJ+wnJX0/Hv327rvDtWv2D38Yj7duDaFoZcoAs6VFri/T8XlxyhoCzKG/UJayVXY+JcNUFJTKRAQdyiMmklAdyrlz3eXL5nOfM5//vHniCfP44/rgIBZGSCCMlo6QIKDYcFotN9xJ1F1eUdy8ad95x16/bq9eHSuC3n13RJKgJ34Par1SF5Shz4O8JiUjACXiqyXW1c4y3QhCzE3EViTrtUzNBOK0WmUaczli3GiVPn/01zz2mL50yXziE8b7rP746KP63Lkxge7Nxv6+loYA0gObzVigePeuu33b/fvf7p//dP/4h989+u7tt+2dOzbMsaMoENbi2zAZsqosi/+Rz7OmCGU9+qq9Wkq7Bn2FWMRsJa0JmhcmdlIVGskAdaKGV6OhBQzjYloHB/r8+ZEABwcU945ls7JkkMfo7l11+7a9fVuFFWiiPfCg8xr1WJZLuDvWOaWvGQdkb6UOZa4WqDTFi+irNQ90nrMHDSuNiwJBYbrJqqPLumhZQBSXGuWpdXyeDOkf/8s9vx8daX/07wgyMUZy5OEB4afaoifAQpk0SoBURJcF0rZEPMO6WoiYeURq2wWbsg6QcnXerCUxa7CCUB1F6yhsYHDBSihTnyiBqyriUx2yBg2Kf6QPsZGn0k6op2OZx+Js1mGNOpycqnEz/S5avuyiqdrbdovAwvL1mL3EB8phmk0if9kYSOKQGLSsLdEDlxGFZS2Tp8tIghNXWfQfu9mMgQ3qEZMFvSRmhwSgrC90h1k7/Y80wMEsg8/xewn9IvrLHTLZm/2vFQbHB8gg7ti6RnIArbzToxWwVQYbY/DZVvLkK5AAxx0ysUcMCUDsD8+JFBqoqTnDVTvF6MzE8g2VMqfiV+Yjd2lRwqXppP8G15dGfSU9nvOFLY6PTp4www/IkLakqWOSNY/BB2eQHqBd7oSfZYe4q1QRKXl0AxBEcRfGbCnnIvRVnXNiXZLlZ0lOWNDPGgcJ60wIiunFRAlsWU2f85k8dxVKCjQQwMmX8q0mNJAndsaeMXpkjFX4BMM5Rl4PetmJfyqd8o011Bs9lGLD51u0K89AlEdRZuhLn7BIgKQJVXwGIiatpodl4MJ71Zb5OT2eIb6YfD/FxTqy2qMsYYnr6qIikiaeamd98dxVlz6iPFnyHBWOtC3SIF0xyzWWommsNVCa0EXckf3v6XI1i4mzaotrg/dV7fH0qvYIMzSMaGCqVWl4Zm71k0bypKzrz+LM92G1lDUr1mS93dh9VhJJzTwmoiyZyWr0ZJoi5QiNpZray2UhkTJ8M3qcCPSnsmTZXOKsXIcGoW8sXza3ZBm2f8q8b26p4PbKWNW6v6rCmauFfoAIUBUI1Vw5bnHZuOqCTYgLClm1/G89DRr0OFncT5EAc5RQalbLr18qTqULtGKTdLaMfFUXVc9UyXDauN8LAlSBa6wK136CaOZ0ZZXf1aatuaaJxnpa6p6vHnpPV86trorbppDa4hEesxKwRg6qNLsXmKj7ujXqf6vny/r6auPVmjq1UozuyyLS93/x7qp8LPK+aj4XZPHJCQ/OMvL/J8AAcpCcJ3CDx3YAAAAASUVORK5CYII=" }, function (t, e, n) { "use strict"; n.r(e); const i = 0, r = 1, o = 2, s = 1, a = 2, c = 3, l = 0, h = 1, u = 2, d = 0, p = 1, f = 2, m = 3, g = 4, v = 5, y = 100, x = 101, _ = 102, b = 103, w = 104, M = 200, S = 201, E = 202, T = 203, A = 204, L = 205, R = 206, P = 207, C = 208, I = 209, O = 210, D = 0, N = 1, z = 2, B = 3, H = 4, U = 5, F = 6, G = 7, k = 0, V = 1, W = 2, j = 0, q = 1, X = 2, Y = 3, Z = 4, J = 5, Q = 301, K = 302, $ = 303, tt = 304, et = 306, nt = 307, it = 1e3, rt = 1001, ot = 1002, st = 1003, at = 1004, ct = 1005, lt = 1006, ht = 1007, ut = 1008, dt = 1009, pt = 1010, ft = 1011, mt = 1012, gt = 1013, vt = 1014, yt = 1015, xt = 1016, _t = 1017, bt = 1018, wt = 1019, Mt = 1020, St = 1021, Et = 1022, Tt = 1023, At = 1024, Lt = 1025, Rt = 1026, Pt = 1027, Ct = 1028, It = 1029, Ot = 1030, Dt = 1031, Nt = 1032, zt = 1033, Bt = 33776, Ht = 33777, Ut = 33778, Ft = 33779, Gt = 35840, kt = 35841, Vt = 35842, Wt = 35843, jt = 36196, qt = 37492, Xt = 37496, Yt = 37808, Zt = 37809, Jt = 37810, Qt = 37811, Kt = 37812, $t = 37813, te = 37814, ee = 37815, ne = 37816, ie = 37817, re = 37818, oe = 37819, se = 37820, ae = 37821, ce = 36492, le = 37840, he = 37841, ue = 37842, de = 37843, pe = 37844, fe = 37845, me = 37846, ge = 37847, ve = 37848, ye = 37849, xe = 37850, _e = 37851, be = 37852, we = 37853, Me = 2200, Se = 2201, Ee = 2202, Te = 2400, Ae = 2401, Le = 2402, Re = 2500, Pe = 2501, Ce = 3e3, Ie = 3001, Oe = 3007, De = 3002, Ne = 3003, ze = 3004, Be = 3005, He = 3006, Ue = 3200, Fe = 3201, Ge = 0, ke = 1, Ve = 7680, We = 519, je = 35044, qe = 35048, Xe = "300 es"; function Ye() { } Object.assign(Ye.prototype, { addEventListener: function (t, e) { void 0 === this._listeners && (this._listeners = {}); const n = this._listeners; void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e) }, hasEventListener: function (t, e) { if (void 0 === this._listeners) return !1; const n = this._listeners; return void 0 !== n[t] && -1 !== n[t].indexOf(e) }, removeEventListener: function (t, e) { if (void 0 === this._listeners) return; const n = this._listeners[t]; if (void 0 !== n) { const t = n.indexOf(e); -1 !== t && n.splice(t, 1) } }, dispatchEvent: function (t) { if (void 0 === this._listeners) return; const e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; const n = e.slice(0); for (let e = 0, i = n.length; e < i; e++)n[e].call(this, t) } } }); const Ze = []; for (let t = 0; t < 256; t++)Ze[t] = (t < 16 ? "0" : "") + t.toString(16); let Je = 1234567; const Qe = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { const t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0; return (Ze[255 & t] + Ze[t >> 8 & 255] + Ze[t >> 16 & 255] + Ze[t >> 24 & 255] + "-" + Ze[255 & e] + Ze[e >> 8 & 255] + "-" + Ze[e >> 16 & 15 | 64] + Ze[e >> 24 & 255] + "-" + Ze[63 & n | 128] + Ze[n >> 8 & 255] + "-" + Ze[n >> 16 & 255] + Ze[n >> 24 & 255] + Ze[255 & i] + Ze[i >> 8 & 255] + Ze[i >> 16 & 255] + Ze[i >> 24 & 255]).toUpperCase() }, clamp: function (t, e, n) { return Math.max(e, Math.min(n, t)) }, euclideanModulo: function (t, e) { return (t % e + e) % e }, mapLinear: function (t, e, n, i, r) { return i + (t - e) * (r - i) / (n - e) }, lerp: function (t, e, n) { return (1 - n) * t + n * e }, damp: function (t, e, n, i) { return Qe.lerp(t, e, 1 - Math.exp(-n * i)) }, pingpong: function (t, e = 1) { return e - Math.abs(Qe.euclideanModulo(t, 2 * e) - e) }, smoothstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, n) { return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10) }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, seededRandom: function (t) { return void 0 !== t && (Je = t % 2147483647), ((Je = 16807 * Je % 2147483647) - 1) / 2147483646 }, degToRad: function (t) { return t * Qe.DEG2RAD }, radToDeg: function (t) { return t * Qe.RAD2DEG }, isPowerOfTwo: function (t) { return 0 == (t & t - 1) && 0 !== t }, ceilPowerOfTwo: function (t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }, floorPowerOfTwo: function (t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) }, setQuaternionFromProperEuler: function (t, e, n, i, r) { const o = Math.cos, s = Math.sin, a = o(n / 2), c = s(n / 2), l = o((e + i) / 2), h = s((e + i) / 2), u = o((e - i) / 2), d = s((e - i) / 2), p = o((i - e) / 2), f = s((i - e) / 2); switch (r) { case "XYX": t.set(a * h, c * u, c * d, a * l); break; case "YZY": t.set(c * d, a * h, c * u, a * l); break; case "ZXZ": t.set(c * u, c * d, a * h, a * l); break; case "XZX": t.set(a * h, c * f, c * p, a * l); break; case "YXY": t.set(c * p, a * h, c * f, a * l); break; case "ZYZ": t.set(c * f, c * p, a * h, a * l); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } }; class Ke { constructor(t = 0, e = 0) { Object.defineProperty(this, "isVector2", { value: !0 }), this.x = t, this.y = e } get width() { return this.x } set width(t) { this.x = t } get height() { return this.y } set height(t) { this.y = t } set(t, e) { return this.x = t, this.y = e, this } setScalar(t) { return this.x = t, this.y = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y) } copy(t) { return this.x = t.x, this.y = t.y, this } add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) } addScalar(t) { return this.x += t, this.y += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this } sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) } subScalar(t) { return this.x -= t, this.y -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this } divide(t) { return this.x /= t.x, this.y /= t.y, this } divideScalar(t) { return this.multiplyScalar(1 / t) } applyMatrix3(t) { const e = this.x, n = this.y, i = t.elements; return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(t) { return this.x * t.x + this.y * t.y } cross(t) { return this.x * t.y - this.y * t.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared(t) { const e = this.x - t.x, n = this.y - t.y; return e * e + n * n } manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this } equals(t) { return t.x === this.x && t.y === this.y } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t } fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this } rotateAround(t, e) { const n = Math.cos(e), i = Math.sin(e), r = this.x - t.x, o = this.y - t.y; return this.x = r * n - o * i + t.x, this.y = r * i + o * n + t.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } } class $e { constructor() { Object.defineProperty(this, "isMatrix3", { value: !0 }), this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } set(t, e, n, i, r, o, s, a, c) { const l = this.elements; return l[0] = t, l[1] = i, l[2] = s, l[3] = e, l[4] = r, l[5] = a, l[6] = n, l[7] = o, l[8] = c, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } clone() { return (new this.constructor).fromArray(this.elements) } copy(t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this } extractBasis(t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4(t) { const e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this } multiply(t) { return this.multiplyMatrices(this, t) } premultiply(t) { return this.multiplyMatrices(t, this) } multiplyMatrices(t, e) { const n = t.elements, i = e.elements, r = this.elements, o = n[0], s = n[3], a = n[6], c = n[1], l = n[4], h = n[7], u = n[2], d = n[5], p = n[8], f = i[0], m = i[3], g = i[6], v = i[1], y = i[4], x = i[7], _ = i[2], b = i[5], w = i[8]; return r[0] = o * f + s * v + a * _, r[3] = o * m + s * y + a * b, r[6] = o * g + s * x + a * w, r[1] = c * f + l * v + h * _, r[4] = c * m + l * y + h * b, r[7] = c * g + l * x + h * w, r[2] = u * f + d * v + p * _, r[5] = u * m + d * y + p * b, r[8] = u * g + d * x + p * w, this } multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this } determinant() { const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], o = t[4], s = t[5], a = t[6], c = t[7], l = t[8]; return e * o * l - e * s * c - n * r * l + n * s * a + i * r * c - i * o * a } invert() { const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], o = t[4], s = t[5], a = t[6], c = t[7], l = t[8], h = l * o - s * c, u = s * a - l * r, d = c * r - o * a, p = e * h + n * u + i * d; if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); const f = 1 / p; return t[0] = h * f, t[1] = (i * c - l * n) * f, t[2] = (s * n - i * o) * f, t[3] = u * f, t[4] = (l * e - i * a) * f, t[5] = (i * r - s * e) * f, t[6] = d * f, t[7] = (n * a - c * e) * f, t[8] = (o * e - n * r) * f, this } transpose() { let t; const e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this } getNormalMatrix(t) { return this.setFromMatrix4(t).copy(this).invert().transpose() } transposeIntoArray(t) { const e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this } setUvTransform(t, e, n, i, r, o, s) { const a = Math.cos(r), c = Math.sin(r); return this.set(n * a, n * c, -n * (a * o + c * s) + o + t, -i * c, i * a, -i * (-c * o + a * s) + s + e, 0, 0, 1), this } scale(t, e) { const n = this.elements; return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this } rotate(t) { const e = Math.cos(t), n = Math.sin(t), i = this.elements, r = i[0], o = i[3], s = i[6], a = i[1], c = i[4], l = i[7]; return i[0] = e * r + n * a, i[3] = e * o + n * c, i[6] = e * s + n * l, i[1] = -n * r + e * a, i[4] = -n * o + e * c, i[7] = -n * s + e * l, this } translate(t, e) { const n = this.elements; return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this } equals(t) { const e = this.elements, n = t.elements; for (let t = 0; t < 9; t++)if (e[t] !== n[t]) return !1; return !0 } fromArray(t, e = 0) { for (let n = 0; n < 9; n++)this.elements[n] = t[n + e]; return this } toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t } } let tn; const en = { getDataURL: function (t) { if (/^data:/i.test(t.src)) return t.src; if ("undefined" == typeof HTMLCanvasElement) return t.src; let e; if (t instanceof HTMLCanvasElement) e = t; else { void 0 === tn && (tn = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), tn.width = t.width, tn.height = t.height; const n = tn.getContext("2d"); t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = tn } return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png") } }; let nn = 0; function rn(t = rn.DEFAULT_IMAGE, e = rn.DEFAULT_MAPPING, n = rt, i = rt, r = lt, o = ut, s = Tt, a = dt, c = 1, l = Ce) { Object.defineProperty(this, "id", { value: nn++ }), this.uuid = Qe.generateUUID(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = o, this.anisotropy = c, this.format = s, this.internalFormat = null, this.type = a, this.offset = new Ke(0, 0), this.repeat = new Ke(1, 1), this.center = new Ke(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new $e, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = l, this.version = 0, this.onUpdate = null } function on(t) { return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? en.getDataURL(t) : t.data ? { data: Array.prototype.slice.call(t.data), width: t.width, height: t.height, type: t.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } rn.DEFAULT_IMAGE = void 0, rn.DEFAULT_MAPPING = 300, rn.prototype = Object.assign(Object.create(Ye.prototype), { constructor: rn, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; const n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { const i = this.image; if (void 0 === i.uuid && (i.uuid = Qe.generateUUID()), !e && void 0 === t.images[i.uuid]) { let e; if (Array.isArray(i)) { e = []; for (let t = 0, n = i.length; t < n; t++)i[t].isDataTexture ? e.push(on(i[t].image)) : e.push(on(i[t])) } else e = on(i); t.images[i.uuid] = { uuid: i.uuid, url: e } } n.image = i.uuid } return e || (t.textures[this.uuid] = n), n }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (t) { if (300 !== this.mapping) return t; if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) { case it: t.x = t.x - Math.floor(t.x); break; case rt: t.x = t.x < 0 ? 0 : 1; break; case ot: 1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x) }if (t.y < 0 || t.y > 1) switch (this.wrapT) { case it: t.y = t.y - Math.floor(t.y); break; case rt: t.y = t.y < 0 ? 0 : 1; break; case ot: 1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y) }return this.flipY && (t.y = 1 - t.y), t } }), Object.defineProperty(rn.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }); class sn { constructor(t = 0, e = 0, n = 0, i = 1) { Object.defineProperty(this, "isVector4", { value: !0 }), this.x = t, this.y = e, this.z = n, this.w = i } get width() { return this.z } set width(t) { this.z = t } get height() { return this.w } set height(t) { this.w = t } set(t, e, n, i) { return this.x = t, this.y = e, this.z = n, this.w = i, this } setScalar(t) { return this.x = t, this.y = t, this.z = t, this.w = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setZ(t) { return this.z = t, this } setW(t) { return this.w = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this } add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) } addScalar(t) { return this.x += t, this.y += t, this.z += t, this.w += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this } sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) } subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this } multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this } multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this } applyMatrix4(t) { const e = this.x, n = this.y, i = this.z, r = this.w, o = t.elements; return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r, this } divideScalar(t) { return this.multiplyScalar(1 / t) } setAxisAngleFromQuaternion(t) { this.w = 2 * Math.acos(t.w); const e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this } setAxisAngleFromRotationMatrix(t) { let e, n, i, r; const o = t.elements, s = o[0], a = o[4], c = o[8], l = o[1], h = o[5], u = o[9], d = o[2], p = o[6], f = o[10]; if (Math.abs(a - l) < .01 && Math.abs(c - d) < .01 && Math.abs(u - p) < .01) { if (Math.abs(a + l) < .1 && Math.abs(c + d) < .1 && Math.abs(u + p) < .1 && Math.abs(s + h + f - 3) < .1) return this.set(1, 0, 0, 0), this; e = Math.PI; const t = (s + 1) / 2, o = (h + 1) / 2, m = (f + 1) / 2, g = (a + l) / 4, v = (c + d) / 4, y = (u + p) / 4; return t > o && t > m ? t < .01 ? (n = 0, i = .707106781, r = .707106781) : (i = g / (n = Math.sqrt(t)), r = v / n) : o > m ? o < .01 ? (n = .707106781, i = 0, r = .707106781) : (n = g / (i = Math.sqrt(o)), r = y / i) : m < .01 ? (n = .707106781, i = .707106781, r = 0) : (n = v / (r = Math.sqrt(m)), i = y / r), this.set(n, i, r, e), this } let m = Math.sqrt((p - u) * (p - u) + (c - d) * (c - d) + (l - a) * (l - a)); return Math.abs(m) < .001 && (m = 1), this.x = (p - u) / m, this.y = (c - d) / m, this.z = (l - a) / m, this.w = Math.acos((s + h + f - 1) / 2), this } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this } equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t } fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } } class an extends Ye { constructor(t, e, n) { super(), Object.defineProperty(this, "isWebGLRenderTarget", { value: !0 }), this.width = t, this.height = e, this.scissor = new sn(0, 0, t, e), this.scissorTest = !1, this.viewport = new sn(0, 0, t, e), n = n || {}, this.texture = new rn(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : lt, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null } setSize(t, e) { this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) } clone() { return (new this.constructor).copy(this) } copy(t) { return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } class cn { constructor(t = 0, e = 0, n = 0, i = 1) { Object.defineProperty(this, "isQuaternion", { value: !0 }), this._x = t, this._y = e, this._z = n, this._w = i } static slerp(t, e, n, i) { return n.copy(t).slerp(e, i) } static slerpFlat(t, e, n, i, r, o, s) { let a = n[i + 0], c = n[i + 1], l = n[i + 2], h = n[i + 3]; const u = r[o + 0], d = r[o + 1], p = r[o + 2], f = r[o + 3]; if (h !== f || a !== u || c !== d || l !== p) { let t = 1 - s; const e = a * u + c * d + l * p + h * f, n = e >= 0 ? 1 : -1, i = 1 - e * e; if (i > Number.EPSILON) { const r = Math.sqrt(i), o = Math.atan2(r, e * n); t = Math.sin(t * o) / r, s = Math.sin(s * o) / r } const r = s * n; if (a = a * t + u * r, c = c * t + d * r, l = l * t + p * r, h = h * t + f * r, t === 1 - s) { const t = 1 / Math.sqrt(a * a + c * c + l * l + h * h); a *= t, c *= t, l *= t, h *= t } } t[e] = a, t[e + 1] = c, t[e + 2] = l, t[e + 3] = h } static multiplyQuaternionsFlat(t, e, n, i, r, o) { const s = n[i], a = n[i + 1], c = n[i + 2], l = n[i + 3], h = r[o], u = r[o + 1], d = r[o + 2], p = r[o + 3]; return t[e] = s * p + l * h + a * d - c * u, t[e + 1] = a * p + l * u + c * h - s * d, t[e + 2] = c * p + l * d + s * u - a * h, t[e + 3] = l * p - s * h - a * u - c * d, t } get x() { return this._x } set x(t) { this._x = t, this._onChangeCallback() } get y() { return this._y } set y(t) { this._y = t, this._onChangeCallback() } get z() { return this._z } set z(t) { this._z = t, this._onChangeCallback() } get w() { return this._w } set w(t) { this._w = t, this._onChangeCallback() } set(t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this } setFromEuler(t, e) { if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const n = t._x, i = t._y, r = t._z, o = t._order, s = Math.cos, a = Math.sin, c = s(n / 2), l = s(i / 2), h = s(r / 2), u = a(n / 2), d = a(i / 2), p = a(r / 2); switch (o) { case "XYZ": this._x = u * l * h + c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h - u * d * p; break; case "YXZ": this._x = u * l * h + c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h + u * d * p; break; case "ZXY": this._x = u * l * h - c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h - u * d * p; break; case "ZYX": this._x = u * l * h - c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h + u * d * p; break; case "YZX": this._x = u * l * h + c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h - u * d * p; break; case "XZY": this._x = u * l * h - c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h + u * d * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o) }return !1 !== e && this._onChangeCallback(), this } setFromAxisAngle(t, e) { const n = e / 2, i = Math.sin(n); return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix(t) { const e = t.elements, n = e[0], i = e[4], r = e[8], o = e[1], s = e[5], a = e[9], c = e[2], l = e[6], h = e[10], u = n + s + h; if (u > 0) { const t = .5 / Math.sqrt(u + 1); this._w = .25 / t, this._x = (l - a) * t, this._y = (r - c) * t, this._z = (o - i) * t } else if (n > s && n > h) { const t = 2 * Math.sqrt(1 + n - s - h); this._w = (l - a) / t, this._x = .25 * t, this._y = (i + o) / t, this._z = (r + c) / t } else if (s > h) { const t = 2 * Math.sqrt(1 + s - n - h); this._w = (r - c) / t, this._x = (i + o) / t, this._y = .25 * t, this._z = (a + l) / t } else { const t = 2 * Math.sqrt(1 + h - n - s); this._w = (o - i) / t, this._x = (r + c) / t, this._y = (a + l) / t, this._z = .25 * t } return this._onChangeCallback(), this } setFromUnitVectors(t, e) { let n = t.dot(e) + 1; return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize() } angleTo(t) { return 2 * Math.acos(Math.abs(Qe.clamp(this.dot(t), -1, 1))) } rotateTowards(t, e) { const n = this.angleTo(t); if (0 === n) return this; const i = Math.min(1, e / n); return this.slerp(t, i), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { let t = this.length(); return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this } multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) } premultiply(t) { return this.multiplyQuaternions(t, this) } multiplyQuaternions(t, e) { const n = t._x, i = t._y, r = t._z, o = t._w, s = e._x, a = e._y, c = e._z, l = e._w; return this._x = n * l + o * s + i * c - r * a, this._y = i * l + o * a + r * s - n * c, this._z = r * l + o * c + n * a - i * s, this._w = o * l - n * s - i * a - r * c, this._onChangeCallback(), this } slerp(t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); const n = this._x, i = this._y, r = this._z, o = this._w; let s = o * t._w + n * t._x + i * t._y + r * t._z; if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this; const a = 1 - s * s; if (a <= Number.EPSILON) { const t = 1 - e; return this._w = t * o + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this } const c = Math.sqrt(a), l = Math.atan2(c, s), h = Math.sin((1 - e) * l) / c, u = Math.sin(e * l) / c; return this._w = o * h + this._w * u, this._x = n * h + this._x * u, this._y = i * h + this._y * u, this._z = r * h + this._z * u, this._onChangeCallback(), this } equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w } fromArray(t, e = 0) { return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this } toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t } fromBufferAttribute(t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this } _onChange(t) { return this._onChangeCallback = t, this } _onChangeCallback() { } } class ln { constructor(t = 0, e = 0, n = 0) { Object.defineProperty(this, "isVector3", { value: !0 }), this.x = t, this.y = e, this.z = n } set(t, e, n) { return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this } setScalar(t) { return this.x = t, this.y = t, this.z = t, this } setX(t) { return this.x = t, this } setY(t) { return this.y = t, this } setZ(t) { return this.z = t, this } setComponent(t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent(t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this } add(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) } addScalar(t) { return this.x += t, this.y += t, this.z += t, this } addVectors(t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this } addScaledVector(t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this } sub(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) } subScalar(t) { return this.x -= t, this.y -= t, this.z -= t, this } subVectors(t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this } multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) } multiplyScalar(t) { return this.x *= t, this.y *= t, this.z *= t, this } multiplyVectors(t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this } applyEuler(t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(un.setFromEuler(t)) } applyAxisAngle(t, e) { return this.applyQuaternion(un.setFromAxisAngle(t, e)) } applyMatrix3(t) { const e = this.x, n = this.y, i = this.z, r = t.elements; return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this } applyNormalMatrix(t) { return this.applyMatrix3(t).normalize() } applyMatrix4(t) { const e = this.x, n = this.y, i = this.z, r = t.elements, o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]); return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o, this } applyQuaternion(t) { const e = this.x, n = this.y, i = this.z, r = t.x, o = t.y, s = t.z, a = t.w, c = a * e + o * i - s * n, l = a * n + s * e - r * i, h = a * i + r * n - o * e, u = -r * e - o * n - s * i; return this.x = c * a + u * -r + l * -s - h * -o, this.y = l * a + u * -o + h * -r - c * -s, this.z = h * a + u * -s + c * -o - l * -r, this } project(t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) } unproject(t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) } transformDirection(t) { const e = this.x, n = this.y, i = this.z, r = t.elements; return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize() } divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this } divideScalar(t) { return this.multiplyScalar(1 / t) } min(t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this } max(t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this } clamp(t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this } clampScalar(t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this } clampLength(t, e) { const n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(t) { return this.normalize().multiplyScalar(t) } lerp(t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this } lerpVectors(t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this } cross(t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) } crossVectors(t, e) { const n = t.x, i = t.y, r = t.z, o = e.x, s = e.y, a = e.z; return this.x = i * a - r * s, this.y = r * o - n * a, this.z = n * s - i * o, this } projectOnVector(t) { const e = t.lengthSq(); if (0 === e) return this.set(0, 0, 0); const n = t.dot(this) / e; return this.copy(t).multiplyScalar(n) } projectOnPlane(t) { return hn.copy(this).projectOnVector(t), this.sub(hn) } reflect(t) { return this.sub(hn.copy(t).multiplyScalar(2 * this.dot(t))) } angleTo(t) { const e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (0 === e) return Math.PI / 2; const n = this.dot(t) / e; return Math.acos(Qe.clamp(n, -1, 1)) } distanceTo(t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared(t) { const e = this.x - t.x, n = this.y - t.y, i = this.z - t.z; return e * e + n * n + i * i } manhattanDistanceTo(t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) } setFromSpherical(t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) } setFromSphericalCoords(t, e, n) { const i = Math.sin(e) * t; return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this } setFromCylindrical(t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) } setFromCylindricalCoords(t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this } setFromMatrixPosition(t) { const e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this } setFromMatrixScale(t) { const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), i = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = n, this.z = i, this } setFromMatrixColumn(t, e) { return this.fromArray(t.elements, 4 * e) } setFromMatrix3Column(t, e) { return this.fromArray(t.elements, 3 * e) } equals(t) { return t.x === this.x && t.y === this.y && t.z === this.z } fromArray(t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this } toArray(t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t } fromBufferAttribute(t, e, n) { return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } } const hn = new ln, un = new cn; class dn { constructor(t, e) { Object.defineProperty(this, "isBox3", { value: !0 }), this.min = void 0 !== t ? t : new ln(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new ln(-1 / 0, -1 / 0, -1 / 0) } set(t, e) { return this.min.copy(t), this.max.copy(e), this } setFromArray(t) { let e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0; for (let a = 0, c = t.length; a < c; a += 3) { const c = t[a], l = t[a + 1], h = t[a + 2]; c < e && (e = c), l < n && (n = l), h < i && (i = h), c > r && (r = c), l > o && (o = l), h > s && (s = h) } return this.min.set(e, n, i), this.max.set(r, o, s), this } setFromBufferAttribute(t) { let e = 1 / 0, n = 1 / 0, i = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0; for (let a = 0, c = t.count; a < c; a++) { const c = t.getX(a), l = t.getY(a), h = t.getZ(a); c < e && (e = c), l < n && (n = l), h < i && (i = h), c > r && (r = c), l > o && (o = l), h > s && (s = h) } return this.min.set(e, n, i), this.max.set(r, o, s), this } setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this } setFromCenterAndSize(t, e) { const n = mn.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this } setFromObject(t) { return this.makeEmpty(), this.expandByObject(t) } clone() { return (new this.constructor).copy(this) } copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(t) { return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new ln), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(t) { return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new ln), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) } expandByPoint(t) { return this.min.min(t), this.max.max(t), this } expandByVector(t) { return this.min.sub(t), this.max.add(t), this } expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this } expandByObject(t) { t.updateWorldMatrix(!1, !1); const e = t.geometry; void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), gn.copy(e.boundingBox), gn.applyMatrix4(t.matrixWorld), this.union(gn)); const n = t.children; for (let t = 0, e = n.length; t < e; t++)this.expandByObject(n[t]); return this } containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) } containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z } getParameter(t, e) { return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new ln), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) } intersectsSphere(t) { return this.clampPoint(t.center, mn), mn.distanceToSquared(t.center) <= t.radius * t.radius } intersectsPlane(t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant } intersectsTriangle(t) { if (this.isEmpty()) return !1; this.getCenter(Mn), Sn.subVectors(this.max, Mn), vn.subVectors(t.a, Mn), yn.subVectors(t.b, Mn), xn.subVectors(t.c, Mn), _n.subVectors(yn, vn), bn.subVectors(xn, yn), wn.subVectors(vn, xn); let e = [0, -_n.z, _n.y, 0, -bn.z, bn.y, 0, -wn.z, wn.y, _n.z, 0, -_n.x, bn.z, 0, -bn.x, wn.z, 0, -wn.x, -_n.y, _n.x, 0, -bn.y, bn.x, 0, -wn.y, wn.x, 0]; return !!pn(e, vn, yn, xn, Sn) && (!!pn(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], vn, yn, xn, Sn) && (En.crossVectors(_n, bn), pn(e = [En.x, En.y, En.z], vn, yn, xn, Sn))) } clampPoint(t, e) { return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new ln), e.copy(t).clamp(this.min, this.max) } distanceToPoint(t) { return mn.copy(t).clamp(this.min, this.max).sub(t).length() } getBoundingSphere(t) { return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(mn).length(), t } intersect(t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this } union(t) { return this.min.min(t.min), this.max.max(t.max), this } applyMatrix4(t) { return this.isEmpty() ? this : (fn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), fn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), fn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), fn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), fn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), fn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), fn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), fn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(fn), this) } translate(t) { return this.min.add(t), this.max.add(t), this } equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) } } function pn(t, e, n, i, r) { for (let o = 0, s = t.length - 3; o <= s; o += 3) { Tn.fromArray(t, o); const s = r.x * Math.abs(Tn.x) + r.y * Math.abs(Tn.y) + r.z * Math.abs(Tn.z), a = e.dot(Tn), c = n.dot(Tn), l = i.dot(Tn); if (Math.max(-Math.max(a, c, l), Math.min(a, c, l)) > s) return !1 } return !0 } const fn = [new ln, new ln, new ln, new ln, new ln, new ln, new ln, new ln], mn = new ln, gn = new dn, vn = new ln, yn = new ln, xn = new ln, _n = new ln, bn = new ln, wn = new ln, Mn = new ln, Sn = new ln, En = new ln, Tn = new ln, An = new dn; class Ln { constructor(t, e) { this.center = void 0 !== t ? t : new ln, this.radius = void 0 !== e ? e : -1 } set(t, e) { return this.center.copy(t), this.radius = e, this } setFromPoints(t, e) { const n = this.center; void 0 !== e ? n.copy(e) : An.setFromPoints(t).getCenter(n); let i = 0; for (let e = 0, r = t.length; e < r; e++)i = Math.max(i, n.distanceToSquared(t[e])); return this.radius = Math.sqrt(i), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.center.copy(t.center), this.radius = t.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(t) { return t.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(t) { return t.distanceTo(this.center) - this.radius } intersectsSphere(t) { const e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e } intersectsBox(t) { return t.intersectsSphere(this) } intersectsPlane(t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius } clampPoint(t, e) { const n = this.center.distanceToSquared(t); return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new ln), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e } getBoundingBox(t) { return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new dn), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) } applyMatrix4(t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this } translate(t) { return this.center.add(t), this } equals(t) { return t.center.equals(this.center) && t.radius === this.radius } } const Rn = new ln, Pn = new ln, Cn = new ln, In = new ln, On = new ln, Dn = new ln, Nn = new ln; class zn { constructor(t, e) { this.origin = void 0 !== t ? t : new ln, this.direction = void 0 !== e ? e : new ln(0, 0, -1) } set(t, e) { return this.origin.copy(t), this.direction.copy(e), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this } at(t, e) { return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new ln), e.copy(this.direction).multiplyScalar(t).add(this.origin) } lookAt(t) { return this.direction.copy(t).sub(this.origin).normalize(), this } recast(t) { return this.origin.copy(this.at(t, Rn)), this } closestPointToPoint(t, e) { void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new ln), e.subVectors(t, this.origin); const n = e.dot(this.direction); return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin) } distanceToPoint(t) { return Math.sqrt(this.distanceSqToPoint(t)) } distanceSqToPoint(t) { const e = Rn.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (Rn.copy(this.direction).multiplyScalar(e).add(this.origin), Rn.distanceToSquared(t)) } distanceSqToSegment(t, e, n, i) { Pn.copy(t).add(e).multiplyScalar(.5), Cn.copy(e).sub(t).normalize(), In.copy(this.origin).sub(Pn); const r = .5 * t.distanceTo(e), o = -this.direction.dot(Cn), s = In.dot(this.direction), a = -In.dot(Cn), c = In.lengthSq(), l = Math.abs(1 - o * o); let h, u, d, p; if (l > 0) if (u = o * s - a, p = r * l, (h = o * a - s) >= 0) if (u >= -p) if (u <= p) { const t = 1 / l; d = (h *= t) * (h + o * (u *= t) + 2 * s) + u * (o * h + u + 2 * a) + c } else u = r, d = -(h = Math.max(0, -(o * u + s))) * h + u * (u + 2 * a) + c; else u = -r, d = -(h = Math.max(0, -(o * u + s))) * h + u * (u + 2 * a) + c; else u <= -p ? d = -(h = Math.max(0, -(-o * r + s))) * h + (u = h > 0 ? -r : Math.min(Math.max(-r, -a), r)) * (u + 2 * a) + c : u <= p ? (h = 0, d = (u = Math.min(Math.max(-r, -a), r)) * (u + 2 * a) + c) : d = -(h = Math.max(0, -(o * r + s))) * h + (u = h > 0 ? r : Math.min(Math.max(-r, -a), r)) * (u + 2 * a) + c; else u = o > 0 ? -r : r, d = -(h = Math.max(0, -(o * u + s))) * h + u * (u + 2 * a) + c; return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), i && i.copy(Cn).multiplyScalar(u).add(Pn), d } intersectSphere(t, e) { Rn.subVectors(t.center, this.origin); const n = Rn.dot(this.direction), i = Rn.dot(Rn) - n * n, r = t.radius * t.radius; if (i > r) return null; const o = Math.sqrt(r - i), s = n - o, a = n + o; return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e) } intersectsSphere(t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius } distanceToPlane(t) { const e = t.normal.dot(this.direction); if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null; const n = -(this.origin.dot(t.normal) + t.constant) / e; return n >= 0 ? n : null } intersectPlane(t, e) { const n = this.distanceToPlane(t); return null === n ? null : this.at(n, e) } intersectsPlane(t) { const e = t.distanceToPoint(this.origin); return 0 === e || t.normal.dot(this.direction) * e < 0 } intersectBox(t, e) { let n, i, r, o, s, a; const c = 1 / this.direction.x, l = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin; return c >= 0 ? (n = (t.min.x - u.x) * c, i = (t.max.x - u.x) * c) : (n = (t.max.x - u.x) * c, i = (t.min.x - u.x) * c), l >= 0 ? (r = (t.min.y - u.y) * l, o = (t.max.y - u.y) * l) : (r = (t.max.y - u.y) * l, o = (t.min.y - u.y) * l), n > o || r > i ? null : ((r > n || n != n) && (n = r), (o < i || i != i) && (i = o), h >= 0 ? (s = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (s = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), n > a || s > i ? null : ((s > n || n != n) && (n = s), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e))) } intersectsBox(t) { return null !== this.intersectBox(t, Rn) } intersectTriangle(t, e, n, i, r) { On.subVectors(e, t), Dn.subVectors(n, t), Nn.crossVectors(On, Dn); let o, s = this.direction.dot(Nn); if (s > 0) { if (i) return null; o = 1 } else { if (!(s < 0)) return null; o = -1, s = -s } In.subVectors(this.origin, t); const a = o * this.direction.dot(Dn.crossVectors(In, Dn)); if (a < 0) return null; const c = o * this.direction.dot(On.cross(In)); if (c < 0) return null; if (a + c > s) return null; const l = -o * In.dot(Nn); return l < 0 ? null : this.at(l / s, r) } applyMatrix4(t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this } equals(t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } } class Bn { constructor() { Object.defineProperty(this, "isMatrix4", { value: !0 }), this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } set(t, e, n, i, r, o, s, a, c, l, h, u, d, p, f, m) { const g = this.elements; return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = o, g[9] = s, g[13] = a, g[2] = c, g[6] = l, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new Bn).fromArray(this.elements) } copy(t) { const e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this } copyPosition(t) { const e = this.elements, n = t.elements; return e[12] = n[12], e[13] = n[13], e[14] = n[14], this } setFromMatrix3(t) { const e = t.elements; return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this } extractBasis(t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis(t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this } extractRotation(t) { const e = this.elements, n = t.elements, i = 1 / Hn.setFromMatrixColumn(t, 0).length(), r = 1 / Hn.setFromMatrixColumn(t, 1).length(), o = 1 / Hn.setFromMatrixColumn(t, 2).length(); return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromEuler(t) { t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const e = this.elements, n = t.x, i = t.y, r = t.z, o = Math.cos(n), s = Math.sin(n), a = Math.cos(i), c = Math.sin(i), l = Math.cos(r), h = Math.sin(r); if ("XYZ" === t.order) { const t = o * l, n = o * h, i = s * l, r = s * h; e[0] = a * l, e[4] = -a * h, e[8] = c, e[1] = n + i * c, e[5] = t - r * c, e[9] = -s * a, e[2] = r - t * c, e[6] = i + n * c, e[10] = o * a } else if ("YXZ" === t.order) { const t = a * l, n = a * h, i = c * l, r = c * h; e[0] = t + r * s, e[4] = i * s - n, e[8] = o * c, e[1] = o * h, e[5] = o * l, e[9] = -s, e[2] = n * s - i, e[6] = r + t * s, e[10] = o * a } else if ("ZXY" === t.order) { const t = a * l, n = a * h, i = c * l, r = c * h; e[0] = t - r * s, e[4] = -o * h, e[8] = i + n * s, e[1] = n + i * s, e[5] = o * l, e[9] = r - t * s, e[2] = -o * c, e[6] = s, e[10] = o * a } else if ("ZYX" === t.order) { const t = o * l, n = o * h, i = s * l, r = s * h; e[0] = a * l, e[4] = i * c - n, e[8] = t * c + r, e[1] = a * h, e[5] = r * c + t, e[9] = n * c - i, e[2] = -c, e[6] = s * a, e[10] = o * a } else if ("YZX" === t.order) { const t = o * a, n = o * c, i = s * a, r = s * c; e[0] = a * l, e[4] = r - t * h, e[8] = i * h + n, e[1] = h, e[5] = o * l, e[9] = -s * l, e[2] = -c * l, e[6] = n * h + i, e[10] = t - r * h } else if ("XZY" === t.order) { const t = o * a, n = o * c, i = s * a, r = s * c; e[0] = a * l, e[4] = -h, e[8] = c * l, e[1] = t * h + r, e[5] = o * l, e[9] = n * h - i, e[2] = i * h - n, e[6] = s * l, e[10] = r * h + t } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromQuaternion(t) { return this.compose(Fn, t, Gn) } lookAt(t, e, n) { const i = this.elements; return Wn.subVectors(t, e), 0 === Wn.lengthSq() && (Wn.z = 1), Wn.normalize(), kn.crossVectors(n, Wn), 0 === kn.lengthSq() && (1 === Math.abs(n.z) ? Wn.x += 1e-4 : Wn.z += 1e-4, Wn.normalize(), kn.crossVectors(n, Wn)), kn.normalize(), Vn.crossVectors(Wn, kn), i[0] = kn.x, i[4] = Vn.x, i[8] = Wn.x, i[1] = kn.y, i[5] = Vn.y, i[9] = Wn.y, i[2] = kn.z, i[6] = Vn.z, i[10] = Wn.z, this } multiply(t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) } premultiply(t) { return this.multiplyMatrices(t, this) } multiplyMatrices(t, e) { const n = t.elements, i = e.elements, r = this.elements, o = n[0], s = n[4], a = n[8], c = n[12], l = n[1], h = n[5], u = n[9], d = n[13], p = n[2], f = n[6], m = n[10], g = n[14], v = n[3], y = n[7], x = n[11], _ = n[15], b = i[0], w = i[4], M = i[8], S = i[12], E = i[1], T = i[5], A = i[9], L = i[13], R = i[2], P = i[6], C = i[10], I = i[14], O = i[3], D = i[7], N = i[11], z = i[15]; return r[0] = o * b + s * E + a * R + c * O, r[4] = o * w + s * T + a * P + c * D, r[8] = o * M + s * A + a * C + c * N, r[12] = o * S + s * L + a * I + c * z, r[1] = l * b + h * E + u * R + d * O, r[5] = l * w + h * T + u * P + d * D, r[9] = l * M + h * A + u * C + d * N, r[13] = l * S + h * L + u * I + d * z, r[2] = p * b + f * E + m * R + g * O, r[6] = p * w + f * T + m * P + g * D, r[10] = p * M + f * A + m * C + g * N, r[14] = p * S + f * L + m * I + g * z, r[3] = v * b + y * E + x * R + _ * O, r[7] = v * w + y * T + x * P + _ * D, r[11] = v * M + y * A + x * C + _ * N, r[15] = v * S + y * L + x * I + _ * z, this } multiplyScalar(t) { const e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this } determinant() { const t = this.elements, e = t[0], n = t[4], i = t[8], r = t[12], o = t[1], s = t[5], a = t[9], c = t[13], l = t[2], h = t[6], u = t[10], d = t[14]; return t[3] * (+r * a * h - i * c * h - r * s * u + n * c * u + i * s * d - n * a * d) + t[7] * (+e * a * d - e * c * u + r * o * u - i * o * d + i * c * l - r * a * l) + t[11] * (+e * c * h - e * s * d - r * o * h + n * o * d + r * s * l - n * c * l) + t[15] * (-i * s * l - e * a * h + e * s * u + i * o * h - n * o * u + n * a * l) } transpose() { const t = this.elements; let e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this } setPosition(t, e, n) { const i = this.elements; return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this } invert() { const t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], o = t[4], s = t[5], a = t[6], c = t[7], l = t[8], h = t[9], u = t[10], d = t[11], p = t[12], f = t[13], m = t[14], g = t[15], v = h * m * c - f * u * c + f * a * d - s * m * d - h * a * g + s * u * g, y = p * u * c - l * m * c - p * a * d + o * m * d + l * a * g - o * u * g, x = l * f * c - p * h * c + p * s * d - o * f * d - l * s * g + o * h * g, _ = p * h * a - l * f * a - p * s * u + o * f * u + l * s * m - o * h * m, b = e * v + n * y + i * x + r * _; if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); const w = 1 / b; return t[0] = v * w, t[1] = (f * u * r - h * m * r - f * i * d + n * m * d + h * i * g - n * u * g) * w, t[2] = (s * m * r - f * a * r + f * i * c - n * m * c - s * i * g + n * a * g) * w, t[3] = (h * a * r - s * u * r - h * i * c + n * u * c + s * i * d - n * a * d) * w, t[4] = y * w, t[5] = (l * m * r - p * u * r + p * i * d - e * m * d - l * i * g + e * u * g) * w, t[6] = (p * a * r - o * m * r - p * i * c + e * m * c + o * i * g - e * a * g) * w, t[7] = (o * u * r - l * a * r + l * i * c - e * u * c - o * i * d + e * a * d) * w, t[8] = x * w, t[9] = (p * h * r - l * f * r - p * n * d + e * f * d + l * n * g - e * h * g) * w, t[10] = (o * f * r - p * s * r + p * n * c - e * f * c - o * n * g + e * s * g) * w, t[11] = (l * s * r - o * h * r - l * n * c + e * h * c + o * n * d - e * s * d) * w, t[12] = _ * w, t[13] = (l * f * i - p * h * i + p * n * u - e * f * u - l * n * m + e * h * m) * w, t[14] = (p * s * i - o * f * i - p * n * a + e * f * a + o * n * m - e * s * m) * w, t[15] = (o * h * i - l * s * i + l * n * a - e * h * a - o * n * u + e * s * u) * w, this } scale(t) { const e = this.elements, n = t.x, i = t.y, r = t.z; return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this } getMaxScaleOnAxis() { const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, n, i)) } makeTranslation(t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this } makeRotationY(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this } makeRotationZ(t) { const e = Math.cos(t), n = Math.sin(t); return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(t, e) { const n = Math.cos(e), i = Math.sin(e), r = 1 - n, o = t.x, s = t.y, a = t.z, c = r * o, l = r * s; return this.set(c * o + n, c * s - i * a, c * a + i * s, 0, c * s + i * a, l * s + n, l * a - i * o, 0, c * a - i * s, l * a + i * o, r * a * a + n, 0, 0, 0, 0, 1), this } makeScale(t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear(t, e, n) { return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this } compose(t, e, n) { const i = this.elements, r = e._x, o = e._y, s = e._z, a = e._w, c = r + r, l = o + o, h = s + s, u = r * c, d = r * l, p = r * h, f = o * l, m = o * h, g = s * h, v = a * c, y = a * l, x = a * h, _ = n.x, b = n.y, w = n.z; return i[0] = (1 - (f + g)) * _, i[1] = (d + x) * _, i[2] = (p - y) * _, i[3] = 0, i[4] = (d - x) * b, i[5] = (1 - (u + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - v) * w, i[10] = (1 - (u + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this } decompose(t, e, n) { const i = this.elements; let r = Hn.set(i[0], i[1], i[2]).length(); const o = Hn.set(i[4], i[5], i[6]).length(), s = Hn.set(i[8], i[9], i[10]).length(); this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], Un.copy(this); const a = 1 / r, c = 1 / o, l = 1 / s; return Un.elements[0] *= a, Un.elements[1] *= a, Un.elements[2] *= a, Un.elements[4] *= c, Un.elements[5] *= c, Un.elements[6] *= c, Un.elements[8] *= l, Un.elements[9] *= l, Un.elements[10] *= l, e.setFromRotationMatrix(Un), n.x = r, n.y = o, n.z = s, this } makePerspective(t, e, n, i, r, o) { void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const s = this.elements, a = 2 * r / (e - t), c = 2 * r / (n - i), l = (e + t) / (e - t), h = (n + i) / (n - i), u = -(o + r) / (o - r), d = -2 * o * r / (o - r); return s[0] = a, s[4] = 0, s[8] = l, s[12] = 0, s[1] = 0, s[5] = c, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = u, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this } makeOrthographic(t, e, n, i, r, o) { const s = this.elements, a = 1 / (e - t), c = 1 / (n - i), l = 1 / (o - r), h = (e + t) * a, u = (n + i) * c, d = (o + r) * l; return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * c, s[9] = 0, s[13] = -u, s[2] = 0, s[6] = 0, s[10] = -2 * l, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this } equals(t) { const e = this.elements, n = t.elements; for (let t = 0; t < 16; t++)if (e[t] !== n[t]) return !1; return !0 } fromArray(t, e = 0) { for (let n = 0; n < 16; n++)this.elements[n] = t[n + e]; return this } toArray(t = [], e = 0) { const n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t } } const Hn = new ln, Un = new Bn, Fn = new ln(0, 0, 0), Gn = new ln(1, 1, 1), kn = new ln, Vn = new ln, Wn = new ln; class jn { constructor(t = 0, e = 0, n = 0, i = jn.DefaultOrder) { Object.defineProperty(this, "isEuler", { value: !0 }), this._x = t, this._y = e, this._z = n, this._order = i } get x() { return this._x } set x(t) { this._x = t, this._onChangeCallback() } get y() { return this._y } set y(t) { this._y = t, this._onChangeCallback() } get z() { return this._z } set z(t) { this._z = t, this._onChangeCallback() } get order() { return this._order } set order(t) { this._order = t, this._onChangeCallback() } set(t, e, n, i) { return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this } setFromRotationMatrix(t, e, n) { const i = Qe.clamp, r = t.elements, o = r[0], s = r[4], a = r[8], c = r[1], l = r[5], h = r[9], u = r[2], d = r[6], p = r[10]; switch (e = e || this._order) { case "XYZ": this._y = Math.asin(i(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(d, l), this._z = 0); break; case "YXZ": this._x = Math.asin(-i(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, o), this._z = 0); break; case "ZXY": this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(c, o)); break; case "ZYX": this._y = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-s, l)); break; case "YZX": this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(a, p)); break; case "XZY": this._z = Math.asin(-i(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-h, p), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e) }return this._order = e, !1 !== n && this._onChangeCallback(), this } setFromQuaternion(t, e, n) { return qn.makeRotationFromQuaternion(t), this.setFromRotationMatrix(qn, e, n) } setFromVector3(t, e) { return this.set(t.x, t.y, t.z, e || this._order) } reorder(t) { return Xn.setFromEuler(this), this.setFromQuaternion(Xn, t) } equals(t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order } fromArray(t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this } toArray(t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t } toVector3(t) { return t ? t.set(this._x, this._y, this._z) : new ln(this._x, this._y, this._z) } _onChange(t) { return this._onChangeCallback = t, this } _onChangeCallback() { } } jn.DefaultOrder = "XYZ", jn.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; const qn = new Bn, Xn = new cn; class Yn { constructor() { this.mask = 1 } set(t) { this.mask = 1 << t | 0 } enable(t) { this.mask |= 1 << t | 0 } enableAll() { this.mask = -1 } toggle(t) { this.mask ^= 1 << t | 0 } disable(t) { this.mask &= ~(1 << t | 0) } disableAll() { this.mask = 0 } test(t) { return 0 != (this.mask & t.mask) } } let Zn = 0; const Jn = new ln, Qn = new cn, Kn = new Bn, $n = new ln, ti = new ln, ei = new ln, ni = new cn, ii = new ln(1, 0, 0), ri = new ln(0, 1, 0), oi = new ln(0, 0, 1), si = { type: "added" }, ai = { type: "removed" }; function ci() { Object.defineProperty(this, "id", { value: Zn++ }), this.uuid = Qe.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ci.DefaultUp.clone(); const t = new ln, e = new jn, n = new cn, i = new ln(1, 1, 1); e._onChange(function () { n.setFromEuler(e, !1) }), n._onChange(function () { e.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new Bn }, normalMatrix: { value: new $e } }), this.matrix = new Bn, this.matrixWorld = new Bn, this.matrixAutoUpdate = ci.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Yn, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } ci.DefaultUp = new ln(0, 1, 0), ci.DefaultMatrixAutoUpdate = !0, ci.prototype = Object.assign(Object.create(Ye.prototype), { constructor: ci, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix4: function (t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (t) { return this.quaternion.premultiply(t), this }, setRotationFromAxisAngle: function (t, e) { this.quaternion.setFromAxisAngle(t, e) }, setRotationFromEuler: function (t) { this.quaternion.setFromEuler(t, !0) }, setRotationFromMatrix: function (t) { this.quaternion.setFromRotationMatrix(t) }, setRotationFromQuaternion: function (t) { this.quaternion.copy(t) }, rotateOnAxis: function (t, e) { return Qn.setFromAxisAngle(t, e), this.quaternion.multiply(Qn), this }, rotateOnWorldAxis: function (t, e) { return Qn.setFromAxisAngle(t, e), this.quaternion.premultiply(Qn), this }, rotateX: function (t) { return this.rotateOnAxis(ii, t) }, rotateY: function (t) { return this.rotateOnAxis(ri, t) }, rotateZ: function (t) { return this.rotateOnAxis(oi, t) }, translateOnAxis: function (t, e) { return Jn.copy(t).applyQuaternion(this.quaternion), this.position.add(Jn.multiplyScalar(e)), this }, translateX: function (t) { return this.translateOnAxis(ii, t) }, translateY: function (t) { return this.translateOnAxis(ri, t) }, translateZ: function (t) { return this.translateOnAxis(oi, t) }, localToWorld: function (t) { return t.applyMatrix4(this.matrixWorld) }, worldToLocal: function (t) { return t.applyMatrix4(Kn.copy(this.matrixWorld).invert()) }, lookAt: function (t, e, n) { t.isVector3 ? $n.copy(t) : $n.set(t, e, n); const i = this.parent; this.updateWorldMatrix(!0, !1), ti.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Kn.lookAt(ti, $n, this.up) : Kn.lookAt($n, ti, this.up), this.quaternion.setFromRotationMatrix(Kn), i && (Kn.extractRotation(i.matrixWorld), Qn.setFromRotationMatrix(Kn), this.quaternion.premultiply(Qn.invert())) }, add: function (t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(si)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }, remove: function (t) { if (arguments.length > 1) { for (let t = 0; t < arguments.length; t++)this.remove(arguments[t]); return this } const e = this.children.indexOf(t); return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(ai)), this }, clear: function () { for (let t = 0; t < this.children.length; t++) { const e = this.children[t]; e.parent = null, e.dispatchEvent(ai) } return this.children.length = 0, this }, attach: function (t) { return this.updateWorldMatrix(!0, !1), Kn.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Kn.multiply(t.parent.matrixWorld)), t.applyMatrix4(Kn), t.updateWorldMatrix(!1, !1), this.add(t), this }, getObjectById: function (t) { return this.getObjectByProperty("id", t) }, getObjectByName: function (t) { return this.getObjectByProperty("name", t) }, getObjectByProperty: function (t, e) { if (this[t] === e) return this; for (let n = 0, i = this.children.length; n < i; n++) { const i = this.children[n].getObjectByProperty(t, e); if (void 0 !== i) return i } }, getWorldPosition: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new ln), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new cn), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ti, t, ei), t }, getWorldScale: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new ln), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ti, ni, t), t }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new ln), this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() }, raycast: function () { }, traverse: function (t) { t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].traverse(t) }, traverseVisible: function (t) { if (!1 === this.visible) return; t(this); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].traverseVisible(t) }, traverseAncestors: function (t) { const e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); const e = this.children; for (let n = 0, i = e.length; n < i; n++)e[n].updateMatrixWorld(t) }, updateWorldMatrix: function (t, e) { const n = this.parent; if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const t = this.children; for (let e = 0, n = t.length; e < n; e++)t[e].updateWorldMatrix(!1, !0) } }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t, n = {}; e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); const i = {}; function r(e, n) { return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) { i.geometry = r(t.geometries, this.geometry); const e = this.geometry.parameters; if (void 0 !== e && void 0 !== e.shapes) { const n = e.shapes; if (Array.isArray(n)) for (let e = 0, i = n.length; e < i; e++) { const i = n[e]; r(t.shapes, i) } else r(t.shapes, n) } } if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const e = []; for (let n = 0, i = this.material.length; n < i; n++)e.push(r(t.materials, this.material[n])); i.material = e } else i.material = r(t.materials, this.material); if (this.children.length > 0) { i.children = []; for (let e = 0; e < this.children.length; e++)i.children.push(this.children[e].toJSON(t).object) } if (this.animations.length > 0) { i.animations = []; for (let e = 0; e < this.animations.length; e++) { const n = this.animations[e]; i.animations.push(r(t.animations, n)) } } if (e) { const e = o(t.geometries), i = o(t.materials), r = o(t.textures), s = o(t.images), a = o(t.shapes), c = o(t.skeletons), l = o(t.animations); e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), a.length > 0 && (n.shapes = a), c.length > 0 && (n.skeletons = c), l.length > 0 && (n.animations = l) } return n.object = i, n; function o(t) { const e = []; for (const n in t) { const i = t[n]; delete i.metadata, e.push(i) } return e } }, clone: function (t) { return (new this.constructor).copy(this, t) }, copy: function (t, e = !0) { if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let e = 0; e < t.children.length; e++) { const n = t.children[e]; this.add(n.clone()) } return this } }); const li = new ln, hi = new ln, ui = new $e; class di { constructor(t, e) { Object.defineProperty(this, "isPlane", { value: !0 }), this.normal = void 0 !== t ? t : new ln(1, 0, 0), this.constant = void 0 !== e ? e : 0 } set(t, e) { return this.normal.copy(t), this.constant = e, this } setComponents(t, e, n, i) { return this.normal.set(t, e, n), this.constant = i, this } setFromNormalAndCoplanarPoint(t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this } setFromCoplanarPoints(t, e, n) { const i = li.subVectors(n, e).cross(hi.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(i, t), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.normal.copy(t.normal), this.constant = t.constant, this } normalize() { const t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(t) { return this.normal.dot(t) + this.constant } distanceToSphere(t) { return this.distanceToPoint(t.center) - t.radius } projectPoint(t, e) { return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new ln), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) } intersectLine(t, e) { void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new ln); const n = t.delta(li), i = this.normal.dot(n); if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0; const r = -(t.start.dot(this.normal) + this.constant) / i; return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start) } intersectsLine(t) { const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end); return e < 0 && n > 0 || n < 0 && e > 0 } intersectsBox(t) { return t.intersectsPlane(this) } intersectsSphere(t) { return t.intersectsPlane(this) } coplanarPoint(t) { return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new ln), t.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(t, e) { const n = e || ui.getNormalMatrix(t), i = this.coplanarPoint(li).applyMatrix4(t), r = this.normal.applyMatrix3(n).normalize(); return this.constant = -i.dot(r), this } translate(t) { return this.constant -= t.dot(this.normal), this } equals(t) { return t.normal.equals(this.normal) && t.constant === this.constant } } const pi = new ln, fi = new ln, mi = new ln, gi = new ln, vi = new ln, yi = new ln, xi = new ln, _i = new ln, bi = new ln, wi = new ln; class Mi { constructor(t, e, n) { this.a = void 0 !== t ? t : new ln, this.b = void 0 !== e ? e : new ln, this.c = void 0 !== n ? n : new ln } static getNormal(t, e, n, i) { void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new ln), i.subVectors(n, e), pi.subVectors(t, e), i.cross(pi); const r = i.lengthSq(); return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0) } static getBarycoord(t, e, n, i, r) { pi.subVectors(i, e), fi.subVectors(n, e), mi.subVectors(t, e); const o = pi.dot(pi), s = pi.dot(fi), a = pi.dot(mi), c = fi.dot(fi), l = fi.dot(mi), h = o * c - s * s; if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new ln), 0 === h) return r.set(-2, -1, -1); const u = 1 / h, d = (c * a - s * l) * u, p = (o * l - s * a) * u; return r.set(1 - d - p, p, d) } static containsPoint(t, e, n, i) { return this.getBarycoord(t, e, n, i, gi), gi.x >= 0 && gi.y >= 0 && gi.x + gi.y <= 1 } static getUV(t, e, n, i, r, o, s, a) { return this.getBarycoord(t, e, n, i, gi), a.set(0, 0), a.addScaledVector(r, gi.x), a.addScaledVector(o, gi.y), a.addScaledVector(s, gi.z), a } static isFrontFacing(t, e, n, i) { return pi.subVectors(n, e), fi.subVectors(t, e), pi.cross(fi).dot(i) < 0 } set(t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this } setFromPointsAndIndices(t, e, n, i) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this } getArea() { return pi.subVectors(this.c, this.b), fi.subVectors(this.a, this.b), .5 * pi.cross(fi).length() } getMidpoint(t) { return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new ln), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(t) { return Mi.getNormal(this.a, this.b, this.c, t) } getPlane(t) { return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new di), t.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(t, e) { return Mi.getBarycoord(t, this.a, this.b, this.c, e) } getUV(t, e, n, i, r) { return Mi.getUV(t, this.a, this.b, this.c, e, n, i, r) } containsPoint(t) { return Mi.containsPoint(t, this.a, this.b, this.c) } isFrontFacing(t) { return Mi.isFrontFacing(this.a, this.b, this.c, t) } intersectsBox(t) { return t.intersectsTriangle(this) } closestPointToPoint(t, e) { void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new ln); const n = this.a, i = this.b, r = this.c; let o, s; vi.subVectors(i, n), yi.subVectors(r, n), _i.subVectors(t, n); const a = vi.dot(_i), c = yi.dot(_i); if (a <= 0 && c <= 0) return e.copy(n); bi.subVectors(t, i); const l = vi.dot(bi), h = yi.dot(bi); if (l >= 0 && h <= l) return e.copy(i); const u = a * h - l * c; if (u <= 0 && a >= 0 && l <= 0) return o = a / (a - l), e.copy(n).addScaledVector(vi, o); wi.subVectors(t, r); const d = vi.dot(wi), p = yi.dot(wi); if (p >= 0 && d <= p) return e.copy(r); const f = d * c - a * p; if (f <= 0 && c >= 0 && p <= 0) return s = c / (c - p), e.copy(n).addScaledVector(yi, s); const m = l * p - d * h; if (m <= 0 && h - l >= 0 && d - p >= 0) return xi.subVectors(r, i), s = (h - l) / (h - l + (d - p)), e.copy(i).addScaledVector(xi, s); const g = 1 / (m + f + u); return o = f * g, s = u * g, e.copy(n).addScaledVector(vi, o).addScaledVector(yi, s) } equals(t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } } const Si = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Ei = { h: 0, s: 0, l: 0 }, Ti = { h: 0, s: 0, l: 0 }; function Ai(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t } function Li(t) { return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) } function Ri(t) { return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 } class Pi { constructor(t, e, n) { return Object.defineProperty(this, "isColor", { value: !0 }), void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n) } set(t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this } setScalar(t) { return this.r = t, this.g = t, this.b = t, this } setHex(t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this } setRGB(t, e, n) { return this.r = t, this.g = e, this.b = n, this } setHSL(t, e, n) { if (t = Qe.euclideanModulo(t, 1), e = Qe.clamp(e, 0, 1), n = Qe.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n; else { const i = n <= .5 ? n * (1 + e) : n + e - n * e, r = 2 * n - i; this.r = Ai(r, i, t + 1 / 3), this.g = Ai(r, i, t), this.b = Ai(r, i, t - 1 / 3) } return this } setStyle(t) { function e(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } let n; if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) { let t; const i = n[1], r = n[2]; switch (i) { case "rgb": case "rgba": if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this; if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this; break; case "hsl": case "hsla": if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) { const n = parseFloat(t[1]) / 360, i = parseInt(t[2], 10) / 100, r = parseInt(t[3], 10) / 100; return e(t[4]), this.setHSL(n, i, r) } } } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) { const t = n[1], e = t.length; if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this; if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this } return t && t.length > 0 ? this.setColorName(t) : this } setColorName(t) { const e = Si[t]; return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this } copyGammaToLinear(t, e = 2) { return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this } copyLinearToGamma(t, e = 2) { const n = e > 0 ? 1 / e : 1; return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this } convertGammaToLinear(t) { return this.copyGammaToLinear(this, t), this } convertLinearToGamma(t) { return this.copyLinearToGamma(this, t), this } copySRGBToLinear(t) { return this.r = Li(t.r), this.g = Li(t.g), this.b = Li(t.b), this } copyLinearToSRGB(t) { return this.r = Ri(t.r), this.g = Ri(t.g), this.b = Ri(t.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 } getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) } getHSL(t) { void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 }); const e = this.r, n = this.g, i = this.b, r = Math.max(e, n, i), o = Math.min(e, n, i); let s, a; const c = (o + r) / 2; if (o === r) s = 0, a = 0; else { const t = r - o; switch (a = c <= .5 ? t / (r + o) : t / (2 - r - o), r) { case e: s = (n - i) / t + (n < i ? 6 : 0); break; case n: s = (i - e) / t + 2; break; case i: s = (e - n) / t + 4 }s /= 6 } return t.h = s, t.s = a, t.l = c, t } getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" } offsetHSL(t, e, n) { return this.getHSL(Ei), Ei.h += t, Ei.s += e, Ei.l += n, this.setHSL(Ei.h, Ei.s, Ei.l), this } add(t) { return this.r += t.r, this.g += t.g, this.b += t.b, this } addColors(t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this } addScalar(t) { return this.r += t, this.g += t, this.b += t, this } sub(t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this } multiply(t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this } multiplyScalar(t) { return this.r *= t, this.g *= t, this.b *= t, this } lerp(t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this } lerpColors(t, e, n) { return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this } lerpHSL(t, e) { this.getHSL(Ei), t.getHSL(Ti); const n = Qe.lerp(Ei.h, Ti.h, e), i = Qe.lerp(Ei.s, Ti.s, e), r = Qe.lerp(Ei.l, Ti.l, e); return this.setHSL(n, i, r), this } equals(t) { return t.r === this.r && t.g === this.g && t.b === this.b } fromArray(t, e = 0) { return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this } toArray(t = [], e = 0) { return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t } fromBufferAttribute(t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } toJSON() { return this.getHex() } } Pi.NAMES = Si, Pi.prototype.r = 1, Pi.prototype.g = 1, Pi.prototype.b = 1; class Ci { constructor(t, e, n, i, r, o = 0) { this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new ln, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new Pi, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = o } clone() { return (new this.constructor).copy(this) } copy(t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (let e = 0, n = t.vertexNormals.length; e < n; e++)this.vertexNormals[e] = t.vertexNormals[e].clone(); for (let e = 0, n = t.vertexColors.length; e < n; e++)this.vertexColors[e] = t.vertexColors[e].clone(); return this } } let Ii = 0; function Oi() { Object.defineProperty(this, "id", { value: Ii++ }), this.uuid = Qe.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = p, this.side = l, this.flatShading = !1, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = A, this.blendDst = L, this.blendEquation = y, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = B, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = We, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ve, this.stencilZFail = Ve, this.stencilZPass = Ve, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } function Di(t) { Oi.call(this), this.type = "MeshBasicMaterial", this.color = new Pi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = k, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t) } Oi.prototype = Object.assign(Object.create(Ye.prototype), { constructor: Oi, isMaterial: !0, onBeforeCompile: function () { }, customProgramCacheKey: function () { return this.onBeforeCompile.toString() }, setValues: function (t) { if (void 0 !== t) for (const e in t) { const n = t[e]; if (void 0 === n) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue } if ("shading" === e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n; continue } const i = this[e]; void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") } }, toJSON: function (t) { const e = void 0 === t || "string" == typeof t; e && (t = { textures: {}, images: {} }); const n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function i(t) { const e = []; for (const n in t) { const i = t[n]; delete i.metadata, e.push(i) } return e } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== p && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== l && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) { const e = i(t.textures), r = i(t.images); e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r) } return n }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; const e = t.clippingPlanes; let n = null; if (null !== e) { const t = e.length; n = new Array(t); for (let i = 0; i !== t; ++i)n[i] = e[i].clone() } return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(Oi.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Di.prototype = Object.create(Oi.prototype), Di.prototype.constructor = Di, Di.prototype.isMeshBasicMaterial = !0, Di.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this }; const Ni = new ln, zi = new Ke; function Bi(t, e, n) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = je, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function Hi(t, e, n) { Bi.call(this, new Int8Array(t), e, n) } function Ui(t, e, n) { Bi.call(this, new Uint8Array(t), e, n) } function Fi(t, e, n) { Bi.call(this, new Uint8ClampedArray(t), e, n) } function Gi(t, e, n) { Bi.call(this, new Int16Array(t), e, n) } function ki(t, e, n) { Bi.call(this, new Uint16Array(t), e, n) } function Vi(t, e, n) { Bi.call(this, new Int32Array(t), e, n) } function Wi(t, e, n) { Bi.call(this, new Uint32Array(t), e, n) } function ji(t, e, n) { Bi.call(this, new Uint16Array(t), e, n) } function qi(t, e, n) { Bi.call(this, new Float32Array(t), e, n) } function Xi(t, e, n) { Bi.call(this, new Float64Array(t), e, n) } function Yi(t) { if (0 === t.length) return -1 / 0; let e = t[0]; for (let n = 1, i = t.length; n < i; ++n)t[n] > e && (e = t[n]); return e } Object.defineProperty(Bi.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(Bi.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setUsage: function (t) { return this.usage = t, this }, copy: function (t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this }, copyAt: function (t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let i = 0, r = this.itemSize; i < r; i++)this.array[t + i] = e.array[n + i]; return this }, copyArray: function (t) { return this.array.set(t), this }, copyColorsArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Pi), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b } return this }, copyVector2sArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Ke), e[n++] = r.x, e[n++] = r.y } return this }, copyVector3sArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new ln), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z } return this }, copyVector4sArray: function (t) { const e = this.array; let n = 0; for (let i = 0, r = t.length; i < r; i++) { let r = t[i]; void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new sn), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w } return this }, applyMatrix3: function (t) { if (2 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)zi.fromBufferAttribute(this, e), zi.applyMatrix3(t), this.setXY(e, zi.x, zi.y); else if (3 === this.itemSize) for (let e = 0, n = this.count; e < n; e++)Ni.fromBufferAttribute(this, e), Ni.applyMatrix3(t), this.setXYZ(e, Ni.x, Ni.y, Ni.z); return this }, applyMatrix4: function (t) { for (let e = 0, n = this.count; e < n; e++)Ni.x = this.getX(e), Ni.y = this.getY(e), Ni.z = this.getZ(e), Ni.applyMatrix4(t), this.setXYZ(e, Ni.x, Ni.y, Ni.z); return this }, applyNormalMatrix: function (t) { for (let e = 0, n = this.count; e < n; e++)Ni.x = this.getX(e), Ni.y = this.getY(e), Ni.z = this.getZ(e), Ni.applyNormalMatrix(t), this.setXYZ(e, Ni.x, Ni.y, Ni.z); return this }, transformDirection: function (t) { for (let e = 0, n = this.count; e < n; e++)Ni.x = this.getX(e), Ni.y = this.getY(e), Ni.z = this.getZ(e), Ni.transformDirection(t), this.setXYZ(e, Ni.x, Ni.y, Ni.z); return this }, set: function (t, e = 0) { return this.array.set(t, e), this }, getX: function (t) { return this.array[t * this.itemSize] }, setX: function (t, e) { return this.array[t * this.itemSize] = e, this }, getY: function (t) { return this.array[t * this.itemSize + 1] }, setY: function (t, e) { return this.array[t * this.itemSize + 1] = e, this }, getZ: function (t) { return this.array[t * this.itemSize + 2] }, setZ: function (t, e) { return this.array[t * this.itemSize + 2] = e, this }, getW: function (t) { return this.array[t * this.itemSize + 3] }, setW: function (t, e) { return this.array[t * this.itemSize + 3] = e, this }, setXY: function (t, e, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this }, setXYZ: function (t, e, n, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this }, setXYZW: function (t, e, n, i, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this }, onUpload: function (t) { return this.onUploadCallback = t, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) }, toJSON: function () { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } } }), Hi.prototype = Object.create(Bi.prototype), Hi.prototype.constructor = Hi, Ui.prototype = Object.create(Bi.prototype), Ui.prototype.constructor = Ui, Fi.prototype = Object.create(Bi.prototype), Fi.prototype.constructor = Fi, Gi.prototype = Object.create(Bi.prototype), Gi.prototype.constructor = Gi, ki.prototype = Object.create(Bi.prototype), ki.prototype.constructor = ki, Vi.prototype = Object.create(Bi.prototype), Vi.prototype.constructor = Vi, Wi.prototype = Object.create(Bi.prototype), Wi.prototype.constructor = Wi, ji.prototype = Object.create(Bi.prototype), ji.prototype.constructor = ji, ji.prototype.isFloat16BufferAttribute = !0, qi.prototype = Object.create(Bi.prototype), qi.prototype.constructor = qi, Xi.prototype = Object.create(Bi.prototype), Xi.prototype.constructor = Xi; const Zi = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function Ji(t, e) { return new Zi[t](e) } let Qi = 0; const Ki = new Bn, $i = new ci, tr = new ln, er = new dn, nr = new dn, ir = new ln; function rr() { Object.defineProperty(this, "id", { value: Qi++ }), this.uuid = Qe.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } rr.prototype = Object.assign(Object.create(Ye.prototype), { constructor: rr, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (t) { return Array.isArray(t) ? this.index = new (Yi(t) > 65535 ? Wi : ki)(t, 1) : this.index = t, this }, getAttribute: function (t) { return this.attributes[t] }, setAttribute: function (t, e) { return this.attributes[t] = e, this }, deleteAttribute: function (t) { return delete this.attributes[t], this }, hasAttribute: function (t) { return void 0 !== this.attributes[t] }, addGroup: function (t, e, n = 0) { this.groups.push({ start: t, count: e, materialIndex: n }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (t, e) { this.drawRange.start = t, this.drawRange.count = e }, applyMatrix4: function (t) { const e = this.attributes.position; void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0); const n = this.attributes.normal; if (void 0 !== n) { const e = (new $e).getNormalMatrix(t); n.applyNormalMatrix(e), n.needsUpdate = !0 } const i = this.attributes.tangent; return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function (t) { return Ki.makeRotationX(t), this.applyMatrix4(Ki), this }, rotateY: function (t) { return Ki.makeRotationY(t), this.applyMatrix4(Ki), this }, rotateZ: function (t) { return Ki.makeRotationZ(t), this.applyMatrix4(Ki), this }, translate: function (t, e, n) { return Ki.makeTranslation(t, e, n), this.applyMatrix4(Ki), this }, scale: function (t, e, n) { return Ki.makeScale(t, e, n), this.applyMatrix4(Ki), this }, lookAt: function (t) { return $i.lookAt(t), $i.updateMatrix(), this.applyMatrix4($i.matrix), this }, center: function () { return this.computeBoundingBox(), this.boundingBox.getCenter(tr).negate(), this.translate(tr.x, tr.y, tr.z), this }, setFromPoints: function (t) { const e = []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; e.push(i.x, i.y, i.z || 0) } return this.setAttribute("position", new qi(e, 3)), this }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new dn); const t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new ln(-1 / 0, -1 / 0, -1 / 0), new ln(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== t) { if (this.boundingBox.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; er.setFromBufferAttribute(n), this.morphTargetsRelative ? (ir.addVectors(this.boundingBox.min, er.min), this.boundingBox.expandByPoint(ir), ir.addVectors(this.boundingBox.max, er.max), this.boundingBox.expandByPoint(ir)) : (this.boundingBox.expandByPoint(er.min), this.boundingBox.expandByPoint(er.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new Ln); const t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new ln, 1 / 0); if (t) { const n = this.boundingSphere.center; if (er.setFromBufferAttribute(t), e) for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; nr.setFromBufferAttribute(n), this.morphTargetsRelative ? (ir.addVectors(er.min, nr.min), er.expandByPoint(ir), ir.addVectors(er.max, nr.max), er.expandByPoint(ir)) : (er.expandByPoint(nr.min), er.expandByPoint(nr.max)) } er.getCenter(n); let i = 0; for (let e = 0, r = t.count; e < r; e++)ir.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(ir)); if (e) for (let r = 0, o = e.length; r < o; r++) { const o = e[r], s = this.morphTargetsRelative; for (let e = 0, r = o.count; e < r; e++)ir.fromBufferAttribute(o, e), s && (tr.fromBufferAttribute(t, e), ir.add(tr)), i = Math.max(i, n.distanceToSquared(ir)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } }, computeFaceNormals: function () { }, computeTangents: function () { const t = this.index, e = this.attributes; if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); const n = t.array, i = e.position.array, r = e.normal.array, o = e.uv.array, s = i.length / 3; void 0 === e.tangent && this.setAttribute("tangent", new Bi(new Float32Array(4 * s), 4)); const a = e.tangent.array, c = [], l = []; for (let t = 0; t < s; t++)c[t] = new ln, l[t] = new ln; const h = new ln, u = new ln, d = new ln, p = new Ke, f = new Ke, m = new Ke, g = new ln, v = new ln; function y(t, e, n) { h.fromArray(i, 3 * t), u.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(o, 2 * t), f.fromArray(o, 2 * e), m.fromArray(o, 2 * n), u.sub(h), d.sub(h), f.sub(p), m.sub(p); const r = 1 / (f.x * m.y - m.x * f.y); isFinite(r) && (g.copy(u).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(u, -m.x).multiplyScalar(r), c[t].add(g), c[e].add(g), c[n].add(g), l[t].add(v), l[e].add(v), l[n].add(v)) } let x = this.groups; 0 === x.length && (x = [{ start: 0, count: n.length }]); for (let t = 0, e = x.length; t < e; ++t) { const e = x[t], i = e.start; for (let t = i, r = i + e.count; t < r; t += 3)y(n[t + 0], n[t + 1], n[t + 2]) } const _ = new ln, b = new ln, w = new ln, M = new ln; function S(t) { w.fromArray(r, 3 * t), M.copy(w); const e = c[t]; _.copy(e), _.sub(w.multiplyScalar(w.dot(e))).normalize(), b.crossVectors(M, e); const n = b.dot(l[t]) < 0 ? -1 : 1; a[4 * t] = _.x, a[4 * t + 1] = _.y, a[4 * t + 2] = _.z, a[4 * t + 3] = n } for (let t = 0, e = x.length; t < e; ++t) { const e = x[t], i = e.start; for (let t = i, r = i + e.count; t < r; t += 3)S(n[t + 0]), S(n[t + 1]), S(n[t + 2]) } }, computeVertexNormals: function () { const t = this.index, e = this.getAttribute("position"); if (void 0 !== e) { let n = this.getAttribute("normal"); if (void 0 === n) n = new Bi(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n); else for (let t = 0, e = n.count; t < e; t++)n.setXYZ(t, 0, 0, 0); const i = new ln, r = new ln, o = new ln, s = new ln, a = new ln, c = new ln, l = new ln, h = new ln; if (t) for (let u = 0, d = t.count; u < d; u += 3) { const d = t.getX(u + 0), p = t.getX(u + 1), f = t.getX(u + 2); i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), o.fromBufferAttribute(e, f), l.subVectors(o, r), h.subVectors(i, r), l.cross(h), s.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), c.fromBufferAttribute(n, f), s.add(l), a.add(l), c.add(l), n.setXYZ(d, s.x, s.y, s.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(f, c.x, c.y, c.z) } else for (let t = 0, s = e.count; t < s; t += 3)i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), o.fromBufferAttribute(e, t + 2), l.subVectors(o, r), h.subVectors(i, r), l.cross(h), n.setXYZ(t + 0, l.x, l.y, l.z), n.setXYZ(t + 1, l.x, l.y, l.z), n.setXYZ(t + 2, l.x, l.y, l.z); this.normalizeNormals(), n.needsUpdate = !0 } }, merge: function (t, e) { if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t); void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); const n = this.attributes; for (const i in n) { if (void 0 === t.attributes[i]) continue; const r = n[i].array, o = t.attributes[i], s = o.array, a = o.itemSize * e, c = Math.min(s.length, r.length - a); for (let t = 0, e = a; t < c; t++, e++)r[e] = s[t] } return this }, normalizeNormals: function () { const t = this.attributes.normal; for (let e = 0, n = t.count; e < n; e++)ir.fromBufferAttribute(t, e), ir.normalize(), t.setXYZ(e, ir.x, ir.y, ir.z) }, toNonIndexed: function () { function t(t, e) { const n = t.array, i = t.itemSize, r = t.normalized, o = new n.constructor(e.length * i); let s = 0, a = 0; for (let t = 0, r = e.length; t < r; t++) { s = e[t] * i; for (let t = 0; t < i; t++)o[a++] = n[s++] } return new Bi(o, i, r) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const e = new rr, n = this.index.array, i = this.attributes; for (const r in i) { const o = t(i[r], n); e.setAttribute(r, o) } const r = this.morphAttributes; for (const i in r) { const o = [], s = r[i]; for (let e = 0, i = s.length; e < i; e++) { const i = t(s[e], n); o.push(i) } e.morphAttributes[i] = o } e.morphTargetsRelative = this.morphTargetsRelative; const o = this.groups; for (let t = 0, n = o.length; t < n; t++) { const n = o[t]; e.addGroup(n.start, n.count, n.materialIndex) } return e }, toJSON: function () { const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const n in e) void 0 !== e[n] && (t[n] = e[n]); return t } t.data = { attributes: {} }; const e = this.index; null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }); const n = this.attributes; for (const e in n) { const i = n[e], r = i.toJSON(t.data); "" !== i.name && (r.name = i.name), t.data.attributes[e] = r } const i = {}; let r = !1; for (const e in this.morphAttributes) { const n = this.morphAttributes[e], o = []; for (let e = 0, i = n.length; e < i; e++) { const i = n[e], r = i.toJSON(t.data); "" !== i.name && (r.name = i.name), o.push(r) } o.length > 0 && (i[e] = o, r = !0) } r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative); const o = this.groups; o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o))); const s = this.boundingSphere; return null !== s && (t.data.boundingSphere = { center: s.center.toArray(), radius: s.radius }), t }, clone: function () { return (new rr).copy(this) }, copy: function (t) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const e = {}; this.name = t.name; const n = t.index; null !== n && this.setIndex(n.clone(e)); const i = t.attributes; for (const t in i) { const n = i[t]; this.setAttribute(t, n.clone(e)) } const r = t.morphAttributes; for (const t in r) { const n = [], i = r[t]; for (let t = 0, r = i.length; t < r; t++)n.push(i[t].clone(e)); this.morphAttributes[t] = n } this.morphTargetsRelative = t.morphTargetsRelative; const o = t.groups; for (let t = 0, e = o.length; t < e; t++) { const e = o[t]; this.addGroup(e.start, e.count, e.materialIndex) } const s = t.boundingBox; null !== s && (this.boundingBox = s.clone()); const a = t.boundingSphere; return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); const or = new Bn, sr = new zn, ar = new Ln, cr = new ln, lr = new ln, hr = new ln, ur = new ln, dr = new ln, pr = new ln, fr = new ln, mr = new ln, gr = new ln, vr = new Ke, yr = new Ke, xr = new Ke, _r = new ln, br = new ln; function wr(t = new rr, e = new Di) { ci.call(this), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets() } function Mr(t, e, n, i, r, o, s, a, c, l, d, p) { cr.fromBufferAttribute(r, l), lr.fromBufferAttribute(r, d), hr.fromBufferAttribute(r, p); const f = t.morphTargetInfluences; if (e.morphTargets && o && f) { fr.set(0, 0, 0), mr.set(0, 0, 0), gr.set(0, 0, 0); for (let t = 0, e = o.length; t < e; t++) { const e = f[t], n = o[t]; 0 !== e && (ur.fromBufferAttribute(n, l), dr.fromBufferAttribute(n, d), pr.fromBufferAttribute(n, p), s ? (fr.addScaledVector(ur, e), mr.addScaledVector(dr, e), gr.addScaledVector(pr, e)) : (fr.addScaledVector(ur.sub(cr), e), mr.addScaledVector(dr.sub(lr), e), gr.addScaledVector(pr.sub(hr), e))) } cr.add(fr), lr.add(mr), hr.add(gr) } t.isSkinnedMesh && (t.boneTransform(l, cr), t.boneTransform(d, lr), t.boneTransform(p, hr)); const m = function (t, e, n, i, r, o, s, a) { let c; if (null === (c = e.side === h ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, e.side !== u, a))) return null; br.copy(a), br.applyMatrix4(t.matrixWorld); const l = n.ray.origin.distanceTo(br); return l < n.near || l > n.far ? null : { distance: l, point: br.clone(), object: t } }(t, e, n, i, cr, lr, hr, _r); if (m) { a && (vr.fromBufferAttribute(a, l), yr.fromBufferAttribute(a, d), xr.fromBufferAttribute(a, p), m.uv = Mi.getUV(_r, cr, lr, hr, vr, yr, xr, new Ke)), c && (vr.fromBufferAttribute(c, l), yr.fromBufferAttribute(c, d), xr.fromBufferAttribute(c, p), m.uv2 = Mi.getUV(_r, cr, lr, hr, vr, yr, xr, new Ke)); const t = new Ci(l, d, p); Mi.getNormal(cr, lr, hr, t.normal), m.face = t } return m } wr.prototype = Object.assign(Object.create(ci.prototype), { constructor: wr, isMesh: !0, copy: function (t) { return ci.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }, raycast: function (t, e) { const n = this.geometry, i = this.material, r = this.matrixWorld; if (void 0 === i) return; if (null === n.boundingSphere && n.computeBoundingSphere(), ar.copy(n.boundingSphere), ar.applyMatrix4(r), !1 === t.ray.intersectsSphere(ar)) return; if (or.copy(r).invert(), sr.copy(t.ray).applyMatrix4(or), null !== n.boundingBox && !1 === sr.intersectsBox(n.boundingBox)) return; let o; if (n.isBufferGeometry) { const r = n.index, s = n.attributes.position, a = n.morphAttributes.position, c = n.morphTargetsRelative, l = n.attributes.uv, h = n.attributes.uv2, u = n.groups, d = n.drawRange; if (null !== r) if (Array.isArray(i)) for (let n = 0, p = u.length; n < p; n++) { const p = u[n], f = i[p.materialIndex]; for (let n = Math.max(p.start, d.start), i = Math.min(p.start + p.count, d.start + d.count); n < i; n += 3) { const i = r.getX(n), u = r.getX(n + 1), d = r.getX(n + 2); (o = Mr(this, f, t, sr, s, a, c, l, h, i, u, d)) && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = p.materialIndex, e.push(o)) } } else { for (let n = Math.max(0, d.start), u = Math.min(r.count, d.start + d.count); n < u; n += 3) { const u = r.getX(n), d = r.getX(n + 1), p = r.getX(n + 2); (o = Mr(this, i, t, sr, s, a, c, l, h, u, d, p)) && (o.faceIndex = Math.floor(n / 3), e.push(o)) } } else if (void 0 !== s) if (Array.isArray(i)) for (let n = 0, r = u.length; n < r; n++) { const r = u[n], p = i[r.materialIndex]; for (let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count); n < i; n += 3) { (o = Mr(this, p, t, sr, s, a, c, l, h, n, n + 1, n + 2)) && (o.faceIndex = Math.floor(n / 3), o.face.materialIndex = r.materialIndex, e.push(o)) } } else { for (let n = Math.max(0, d.start), r = Math.min(s.count, d.start + d.count); n < r; n += 3) { (o = Mr(this, i, t, sr, s, a, c, l, h, n, n + 1, n + 2)) && (o.faceIndex = Math.floor(n / 3), e.push(o)) } } } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }); class Sr extends rr { constructor(t = 1, e = 1, n = 1, i = 1, r = 1, o = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: i, heightSegments: r, depthSegments: o }; const s = this; i = Math.floor(i), r = Math.floor(r), o = Math.floor(o); const a = [], c = [], l = [], h = []; let u = 0, d = 0; function p(t, e, n, i, r, o, p, f, m, g, v) { const y = o / m, x = p / g, _ = o / 2, b = p / 2, w = f / 2, M = m + 1, S = g + 1; let E = 0, T = 0; const A = new ln; for (let o = 0; o < S; o++) { const s = o * x - b; for (let a = 0; a < M; a++) { const u = a * y - _; A[t] = u * i, A[e] = s * r, A[n] = w, c.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = f > 0 ? 1 : -1, l.push(A.x, A.y, A.z), h.push(a / m), h.push(1 - o / g), E += 1 } } for (let t = 0; t < g; t++)for (let e = 0; e < m; e++) { const n = u + e + M * t, i = u + e + M * (t + 1), r = u + (e + 1) + M * (t + 1), o = u + (e + 1) + M * t; a.push(n, i, o), a.push(i, r, o), T += 6 } s.addGroup(d, T, v), d += T, u += E } p("z", "y", "x", -1, -1, n, e, t, o, r, 0), p("z", "y", "x", 1, -1, n, e, -t, o, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, o, 2), p("x", "z", "y", 1, -1, t, n, -e, i, o, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new qi(c, 3)), this.setAttribute("normal", new qi(l, 3)), this.setAttribute("uv", new qi(h, 2)) } } function Er(t) { const e = {}; for (const n in t) { e[n] = {}; for (const i in t[n]) { const r = t[n][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r } } return e } function Tr(t) { const e = {}; for (let n = 0; n < t.length; n++) { const i = Er(t[n]); for (const t in i) e[t] = i[t] } return e } const Ar = { clone: Er, merge: Tr }; var Lr = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", Rr = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"; function Pr(t) { Oi.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = Lr, this.fragmentShader = Rr, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) } function Cr() { ci.call(this), this.type = "Camera", this.matrixWorldInverse = new Bn, this.projectionMatrix = new Bn, this.projectionMatrixInverse = new Bn } function Ir(t = 50, e = 1, n = .1, i = 2e3) { Cr.call(this), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } Pr.prototype = Object.create(Oi.prototype), Pr.prototype.constructor = Pr, Pr.prototype.isShaderMaterial = !0, Pr.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Er(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this }, Pr.prototype.toJSON = function (t) { const e = Oi.prototype.toJSON.call(this, t); e.glslVersion = this.glslVersion, e.uniforms = {}; for (const n in this.uniforms) { const i = this.uniforms[n].value; i && i.isTexture ? e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid } : i && i.isColor ? e.uniforms[n] = { type: "c", value: i.getHex() } : i && i.isVector2 ? e.uniforms[n] = { type: "v2", value: i.toArray() } : i && i.isVector3 ? e.uniforms[n] = { type: "v3", value: i.toArray() } : i && i.isVector4 ? e.uniforms[n] = { type: "v4", value: i.toArray() } : i && i.isMatrix3 ? e.uniforms[n] = { type: "m3", value: i.toArray() } : i && i.isMatrix4 ? e.uniforms[n] = { type: "m4", value: i.toArray() } : e.uniforms[n] = { value: i } } Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader; const n = {}; for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0); return Object.keys(n).length > 0 && (e.extensions = n), e }, Cr.prototype = Object.assign(Object.create(ci.prototype), { constructor: Cr, isCamera: !0, copy: function (t, e) { return ci.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new ln), this.updateWorldMatrix(!0, !1); const e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }, updateMatrixWorld: function (t) { ci.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() }, updateWorldMatrix: function (t, e) { ci.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert() }, clone: function () { return (new this.constructor).copy(this) } }), Ir.prototype = Object.assign(Object.create(Cr.prototype), { constructor: Ir, isPerspectiveCamera: !0, copy: function (t, e) { return Cr.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }, setFocalLength: function (t) { const e = .5 * this.getFilmHeight() / t; this.fov = 2 * Qe.RAD2DEG * Math.atan(e), this.updateProjectionMatrix() }, getFocalLength: function () { const t = Math.tan(.5 * Qe.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / t }, getEffectiveFOV: function () { return 2 * Qe.RAD2DEG * Math.atan(Math.tan(.5 * Qe.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (t, e, n, i, r, o) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { const t = this.near; let e = t * Math.tan(.5 * Qe.DEG2RAD * this.fov) / this.zoom, n = 2 * e, i = this.aspect * n, r = -.5 * i; const o = this.view; if (null !== this.view && this.view.enabled) { const t = o.fullWidth, s = o.fullHeight; r += o.offsetX * i / t, e -= o.offsetY * n / s, i *= o.width / t, n *= o.height / s } const s = this.filmOffset; 0 !== s && (r += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() }, toJSON: function (t) { const e = ci.prototype.toJSON.call(this, t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } }); const Or = 90, Dr = 1; function Nr(t, e, n) { if (ci.call(this), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); this.renderTarget = n; const i = new Ir(Or, Dr, t, e); i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new ln(1, 0, 0)), this.add(i); const r = new Ir(Or, Dr, t, e); r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new ln(-1, 0, 0)), this.add(r); const o = new Ir(Or, Dr, t, e); o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new ln(0, 1, 0)), this.add(o); const s = new Ir(Or, Dr, t, e); s.layers = this.layers, s.up.set(0, 0, -1), s.lookAt(new ln(0, -1, 0)), this.add(s); const a = new Ir(Or, Dr, t, e); a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new ln(0, 0, 1)), this.add(a); const c = new Ir(Or, Dr, t, e); c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new ln(0, 0, -1)), this.add(c), this.update = function (t, e) { null === this.parent && this.updateMatrixWorld(); const l = t.xr.enabled, h = t.getRenderTarget(); t.xr.enabled = !1; const u = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, s), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(h), t.xr.enabled = l } } function zr(t, e, n, i, r, o, s, a, c, l) { t = void 0 !== t ? t : [], e = void 0 !== e ? e : Q, s = void 0 !== s ? s : Et, rn.call(this, t, e, n, i, r, o, s, a, c, l), this.flipY = !1, this._needsFlipEnvMap = !0 } Nr.prototype = Object.create(ci.prototype), Nr.prototype.constructor = Nr, zr.prototype = Object.create(rn.prototype), zr.prototype.constructor = zr, zr.prototype.isCubeTexture = !0, Object.defineProperty(zr.prototype, "images", { get: function () { return this.image }, set: function (t) { this.image = t } }); class Br extends an { constructor(t, e, n) { Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), Object.defineProperty(this, "isWebGLCubeRenderTarget", { value: !0 }), e = e || {}, this.texture = new zr(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture._needsFlipEnvMap = !1 } fromEquirectangularTexture(t, e) { this.texture.type = e.type, this.texture.format = Tt, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter; const n = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t" }, i = new Sr(5, 5, 5), r = new Pr({ name: "CubemapFromEquirect", uniforms: Er(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: h, blending: d }); r.uniforms.tEquirect.value = e; const o = new wr(i, r), s = e.minFilter; return e.minFilter === ut && (e.minFilter = lt), new Nr(1, 10, this).update(t, o), e.minFilter = s, o.geometry.dispose(), o.material.dispose(), this } clear(t, e, n, i) { const r = t.getRenderTarget(); for (let r = 0; r < 6; r++)t.setRenderTarget(this, r), t.clear(e, n, i); t.setRenderTarget(r) } } function Hr(t, e, n, i, r, o, s, a, c, l, h, u) { rn.call(this, null, o, s, a, c, l, i, r, h, u), this.image = { data: t || null, width: e || 1, height: n || 1 }, this.magFilter = void 0 !== c ? c : st, this.minFilter = void 0 !== l ? l : st, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } Hr.prototype = Object.create(rn.prototype), Hr.prototype.constructor = Hr, Hr.prototype.isDataTexture = !0; const Ur = new Ln, Fr = new ln; class Gr { constructor(t, e, n, i, r, o) { this.planes = [void 0 !== t ? t : new di, void 0 !== e ? e : new di, void 0 !== n ? n : new di, void 0 !== i ? i : new di, void 0 !== r ? r : new di, void 0 !== o ? o : new di] } set(t, e, n, i, r, o) { const s = this.planes; return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(o), this } clone() { return (new this.constructor).copy(this) } copy(t) { const e = this.planes; for (let n = 0; n < 6; n++)e[n].copy(t.planes[n]); return this } setFromProjectionMatrix(t) { const e = this.planes, n = t.elements, i = n[0], r = n[1], o = n[2], s = n[3], a = n[4], c = n[5], l = n[6], h = n[7], u = n[8], d = n[9], p = n[10], f = n[11], m = n[12], g = n[13], v = n[14], y = n[15]; return e[0].setComponents(s - i, h - a, f - u, y - m).normalize(), e[1].setComponents(s + i, h + a, f + u, y + m).normalize(), e[2].setComponents(s + r, h + c, f + d, y + g).normalize(), e[3].setComponents(s - r, h - c, f - d, y - g).normalize(), e[4].setComponents(s - o, h - l, f - p, y - v).normalize(), e[5].setComponents(s + o, h + l, f + p, y + v).normalize(), this } intersectsObject(t) { const e = t.geometry; return null === e.boundingSphere && e.computeBoundingSphere(), Ur.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Ur) } intersectsSprite(t) { return Ur.center.set(0, 0, 0), Ur.radius = .7071067811865476, Ur.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ur) } intersectsSphere(t) { const e = this.planes, n = t.center, i = -t.radius; for (let t = 0; t < 6; t++) { if (e[t].distanceToPoint(n) < i) return !1 } return !0 } intersectsBox(t) { const e = this.planes; for (let n = 0; n < 6; n++) { const i = e[n]; if (Fr.x = i.normal.x > 0 ? t.max.x : t.min.x, Fr.y = i.normal.y > 0 ? t.max.y : t.min.y, Fr.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(Fr) < 0) return !1 } return !0 } containsPoint(t) { const e = this.planes; for (let n = 0; n < 6; n++)if (e[n].distanceToPoint(t) < 0) return !1; return !0 } } function kr() { let t = null, e = !1, n = null, i = null; function r(e, o) { n(e, o), i = t.requestAnimationFrame(r) } return { start: function () { !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0) }, stop: function () { t.cancelAnimationFrame(i), e = !1 }, setAnimationLoop: function (t) { n = t }, setContext: function (e) { t = e } } } function Vr(t, e) { const n = e.isWebGL2, i = new WeakMap; return { get: function (t) { return t.isInterleavedBufferAttribute && (t = t.data), i.get(t) }, remove: function (e) { e.isInterleavedBufferAttribute && (e = e.data); const n = i.get(e); n && (t.deleteBuffer(n.buffer), i.delete(e)) }, update: function (e, r) { if (e.isGLBufferAttribute) { const t = i.get(e); return void ((!t || t.version < e.version) && i.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version })) } e.isInterleavedBufferAttribute && (e = e.data); const o = i.get(e); void 0 === o ? i.set(e, function (e, i) { const r = e.array, o = e.usage, s = t.createBuffer(); t.bindBuffer(i, s), t.bufferData(i, r, o), e.onUploadCallback(); let a = 5126; return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : r instanceof Uint8Array && (a = 5121), { buffer: s, type: a, bytesPerElement: r.BYTES_PER_ELEMENT, version: e.version } }(e, r)) : o.version < e.version && (!function (e, i, r) { const o = i.array, s = i.updateRange; t.bindBuffer(r, e), -1 === s.count ? t.bufferSubData(r, 0, o) : (n ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)), s.count = -1) }(o.buffer, e, r), o.version = e.version) } } } class Wr extends rr { constructor(t = 1, e = 1, n = 1, i = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: i }; const r = t / 2, o = e / 2, s = Math.floor(n), a = Math.floor(i), c = s + 1, l = a + 1, h = t / s, u = e / a, d = [], p = [], f = [], m = []; for (let t = 0; t < l; t++) { const e = t * u - o; for (let n = 0; n < c; n++) { const i = n * h - r; p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / s), m.push(1 - t / a) } } for (let t = 0; t < a; t++)for (let e = 0; e < s; e++) { const n = e + c * t, i = e + c * (t + 1), r = e + 1 + c * (t + 1), o = e + 1 + c * t; d.push(n, i, o), d.push(i, r, o) } this.setIndex(d), this.setAttribute("position", new qi(p, 3)), this.setAttribute("normal", new qi(f, 3)), this.setAttribute("uv", new qi(m, 2)) } } const jr = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif", transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, qr = { common: { diffuse: { value: new Pi(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new $e }, uv2Transform: { value: new $e }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Ke(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Pi(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Pi(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new $e } }, sprite: { diffuse: { value: new Pi(15658734) }, opacity: { value: 1 }, center: { value: new Ke(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new $e } } }, Xr = { basic: { uniforms: Tr([qr.common, qr.specularmap, qr.envmap, qr.aomap, qr.lightmap, qr.fog]), vertexShader: jr.meshbasic_vert, fragmentShader: jr.meshbasic_frag }, lambert: { uniforms: Tr([qr.common, qr.specularmap, qr.envmap, qr.aomap, qr.lightmap, qr.emissivemap, qr.fog, qr.lights, { emissive: { value: new Pi(0) } }]), vertexShader: jr.meshlambert_vert, fragmentShader: jr.meshlambert_frag }, phong: { uniforms: Tr([qr.common, qr.specularmap, qr.envmap, qr.aomap, qr.lightmap, qr.emissivemap, qr.bumpmap, qr.normalmap, qr.displacementmap, qr.fog, qr.lights, { emissive: { value: new Pi(0) }, specular: { value: new Pi(1118481) }, shininess: { value: 30 } }]), vertexShader: jr.meshphong_vert, fragmentShader: jr.meshphong_frag }, standard: { uniforms: Tr([qr.common, qr.envmap, qr.aomap, qr.lightmap, qr.emissivemap, qr.bumpmap, qr.normalmap, qr.displacementmap, qr.roughnessmap, qr.metalnessmap, qr.fog, qr.lights, { emissive: { value: new Pi(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: jr.meshphysical_vert, fragmentShader: jr.meshphysical_frag }, toon: { uniforms: Tr([qr.common, qr.aomap, qr.lightmap, qr.emissivemap, qr.bumpmap, qr.normalmap, qr.displacementmap, qr.gradientmap, qr.fog, qr.lights, { emissive: { value: new Pi(0) } }]), vertexShader: jr.meshtoon_vert, fragmentShader: jr.meshtoon_frag }, matcap: { uniforms: Tr([qr.common, qr.bumpmap, qr.normalmap, qr.displacementmap, qr.fog, { matcap: { value: null } }]), vertexShader: jr.meshmatcap_vert, fragmentShader: jr.meshmatcap_frag }, points: { uniforms: Tr([qr.points, qr.fog]), vertexShader: jr.points_vert, fragmentShader: jr.points_frag }, dashed: { uniforms: Tr([qr.common, qr.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: jr.linedashed_vert, fragmentShader: jr.linedashed_frag }, depth: { uniforms: Tr([qr.common, qr.displacementmap]), vertexShader: jr.depth_vert, fragmentShader: jr.depth_frag }, normal: { uniforms: Tr([qr.common, qr.bumpmap, qr.normalmap, qr.displacementmap, { opacity: { value: 1 } }]), vertexShader: jr.normal_vert, fragmentShader: jr.normal_frag }, sprite: { uniforms: Tr([qr.sprite, qr.fog]), vertexShader: jr.sprite_vert, fragmentShader: jr.sprite_frag }, background: { uniforms: { uvTransform: { value: new $e }, t2D: { value: null } }, vertexShader: jr.background_vert, fragmentShader: jr.background_frag }, cube: { uniforms: Tr([qr.envmap, { opacity: { value: 1 } }]), vertexShader: jr.cube_vert, fragmentShader: jr.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: jr.equirect_vert, fragmentShader: jr.equirect_frag }, distanceRGBA: { uniforms: Tr([qr.common, qr.displacementmap, { referencePosition: { value: new ln }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: jr.distanceRGBA_vert, fragmentShader: jr.distanceRGBA_frag }, shadow: { uniforms: Tr([qr.lights, qr.fog, { color: { value: new Pi(0) }, opacity: { value: 1 } }]), vertexShader: jr.shadow_vert, fragmentShader: jr.shadow_frag } }; function Yr(t, e, n, i, r) { const o = new Pi(0); let s, a, c = 0, u = null, d = 0, p = null; function f(t, e) { n.buffers.color.setClear(t.r, t.g, t.b, e, r) } return { getClearColor: function () { return o }, setClearColor: function (t, e = 1) { o.set(t), f(o, c = e) }, getClearAlpha: function () { return c }, setClearAlpha: function (t) { f(o, c = t) }, render: function (n, r, m, g) { let v = !0 === r.isScene ? r.background : null; v && v.isTexture && (v = e.get(v)); const y = t.xr, x = y.getSession && y.getSession(); x && "additive" === x.environmentBlendMode && (v = null), null === v ? f(o, c) : v && v.isColor && (f(v, 1), g = !0), (t.autoClear || g) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), v && (v.isCubeTexture || v.isWebGLCubeRenderTarget || v.mapping === et) ? (void 0 === a && ((a = new wr(new Sr(1, 1, 1), new Pr({ name: "BackgroundCubeMaterial", uniforms: Er(Xr.cube.uniforms), vertexShader: Xr.cube.vertexShader, fragmentShader: Xr.cube.fragmentShader, side: h, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function (t, e, n) { this.matrixWorld.copyPosition(n.matrixWorld) }, Object.defineProperty(a.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), i.update(a)), v.isWebGLCubeRenderTarget && (v = v.texture), a.material.uniforms.envMap.value = v, a.material.uniforms.flipEnvMap.value = v.isCubeTexture && v._needsFlipEnvMap ? -1 : 1, u === v && d === v.version && p === t.toneMapping || (a.material.needsUpdate = !0, u = v, d = v.version, p = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : v && v.isTexture && (void 0 === s && ((s = new wr(new Wr(2, 2), new Pr({ name: "BackgroundMaterial", uniforms: Er(Xr.background.uniforms), vertexShader: Xr.background.vertexShader, fragmentShader: Xr.background.fragmentShader, side: l, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(s.material, "map", { get: function () { return this.uniforms.t2D.value } }), i.update(s)), s.material.uniforms.t2D.value = v, !0 === v.matrixAutoUpdate && v.updateMatrix(), s.material.uniforms.uvTransform.value.copy(v.matrix), u === v && d === v.version && p === t.toneMapping || (s.material.needsUpdate = !0, u = v, d = v.version, p = t.toneMapping), n.unshift(s, s.geometry, s.material, 0, 0, null)) } } } function Zr(t, e, n, i) { const r = t.getParameter(34921), o = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), s = i.isWebGL2 || null !== o, a = {}, c = d(null); let l = c; function h(e) { return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e) } function u(e) { return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e) } function d(t) { const e = [], n = [], i = []; for (let t = 0; t < r; t++)e[t] = 0, n[t] = 0, i[t] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: n, attributeDivisors: i, object: t, attributes: {}, index: null } } function p() { const t = l.newAttributes; for (let e = 0, n = t.length; e < n; e++)t[e] = 0 } function f(t) { m(t, 0) } function m(n, r) { const o = l.newAttributes, s = l.enabledAttributes, a = l.attributeDivisors; if (o[n] = 1, 0 === s[n] && (t.enableVertexAttribArray(n), s[n] = 1), a[n] !== r) { (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r } } function g() { const e = l.newAttributes, n = l.enabledAttributes; for (let i = 0, r = n.length; i < r; i++)n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0) } function v(e, n, r, o, s, a) { !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, o, s, a) : t.vertexAttribIPointer(e, n, r, s, a) } function y() { x(), l !== c && h((l = c).object) } function x() { c.geometry = null, c.program = null, c.wireframe = !1 } return { setup: function (r, c, u, y, x) { let _ = !1; if (s) { const e = function (e, n, r) { const s = !0 === r.wireframe; let c = a[e.id]; void 0 === c && (c = {}, a[e.id] = c); let l = c[n.id]; void 0 === l && (l = {}, c[n.id] = l); let h = l[s]; void 0 === h && (h = d(i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()), l[s] = h); return h }(y, u, c); l !== e && h((l = e).object), (_ = function (t, e) { const n = l.attributes, i = t.attributes; let r = 0; for (const t in i) { const e = n[t], o = i[t]; if (void 0 === e) return !0; if (e.attribute !== o) return !0; if (e.data !== o.data) return !0; r++ } return l.attributesNum !== r || l.index !== e }(y, x)) && function (t, e) { const n = {}, i = t.attributes; let r = 0; for (const t in i) { const e = i[t], o = {}; o.attribute = e, e.data && (o.data = e.data), n[t] = o, r++ } l.attributes = n, l.attributesNum = r, l.index = e }(y, x) } else { const t = !0 === c.wireframe; l.geometry === y.id && l.program === u.id && l.wireframe === t || (l.geometry = y.id, l.program = u.id, l.wireframe = t, _ = !0) } !0 === r.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (!function (r, o, s, a) { if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return; p(); const c = a.attributes, l = s.getAttributes(), h = o.defaultAttributeValues; for (const e in l) { const i = l[e]; if (i >= 0) { const o = c[e]; if (void 0 !== o) { const e = o.normalized, r = o.itemSize, s = n.get(o); if (void 0 === s) continue; const c = s.buffer, l = s.type, h = s.bytesPerElement; if (o.isInterleavedBufferAttribute) { const n = o.data, s = n.stride, u = o.offset; n && n.isInstancedInterleavedBuffer ? (m(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : f(i), t.bindBuffer(34962, c), v(i, r, l, e, s * h, u * h) } else o.isInstancedBufferAttribute ? (m(i, o.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)) : f(i), t.bindBuffer(34962, c), v(i, r, l, e, 0, 0) } else if ("instanceMatrix" === e) { const e = n.get(r.instanceMatrix); if (void 0 === e) continue; const o = e.buffer, s = e.type; m(i + 0, 1), m(i + 1, 1), m(i + 2, 1), m(i + 3, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48) } else if ("instanceColor" === e) { const e = n.get(r.instanceColor); if (void 0 === e) continue; const o = e.buffer, s = e.type; m(i, 1), t.bindBuffer(34962, o), t.vertexAttribPointer(i, 3, s, !1, 12, 0) } else if (void 0 !== h) { const n = h[e]; if (void 0 !== n) switch (n.length) { case 2: t.vertexAttrib2fv(i, n); break; case 3: t.vertexAttrib3fv(i, n); break; case 4: t.vertexAttrib4fv(i, n); break; default: t.vertexAttrib1fv(i, n) } } } } g() }(r, c, u, y), null !== x && t.bindBuffer(34963, n.get(x).buffer)) }, reset: y, resetDefaultState: x, dispose: function () { y(); for (const t in a) { const e = a[t]; for (const t in e) { const n = e[t]; for (const t in n) u(n[t].object), delete n[t]; delete e[t] } delete a[t] } }, releaseStatesOfGeometry: function (t) { if (void 0 === a[t.id]) return; const e = a[t.id]; for (const t in e) { const n = e[t]; for (const t in n) u(n[t].object), delete n[t]; delete e[t] } delete a[t.id] }, releaseStatesOfProgram: function (t) { for (const e in a) { const n = a[e]; if (void 0 === n[t.id]) continue; const i = n[t.id]; for (const t in i) u(i[t].object), delete i[t]; delete n[t.id] } }, initAttributes: p, enableAttribute: f, disableUnusedAttributes: g } } function Jr(t, e, n, i) { const r = i.isWebGL2; let o; this.setMode = function (t) { o = t }, this.render = function (e, i) { t.drawArrays(o, e, i), n.update(i, o, 1) }, this.renderInstances = function (i, s, a) { if (0 === a) return; let c, l; if (r) c = t, l = "drawArraysInstanced"; else if (l = "drawArraysInstancedANGLE", null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); c[l](o, i, s, a), n.update(s, o, a) } } function Qr(t, e, n) { let i; function r(e) { if ("highp" === e) { if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; e = "mediump" } return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext; let s = void 0 !== n.precision ? n.precision : "highp"; const a = r(s); a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a); const c = !0 === n.logarithmicDepthBuffer, l = t.getParameter(34930), h = t.getParameter(35660), u = t.getParameter(3379), d = t.getParameter(34076), p = t.getParameter(34921), f = t.getParameter(36347), m = t.getParameter(36348), g = t.getParameter(36349), v = h > 0, y = o || !!e.get("OES_texture_float"); return { isWebGL2: o, getMaxAnisotropy: function () { if (void 0 !== i) return i; const n = e.get("EXT_texture_filter_anisotropic"); return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: r, precision: s, logarithmicDepthBuffer: c, maxTextures: l, maxVertexTextures: h, maxTextureSize: u, maxCubemapSize: d, maxAttributes: p, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: g, vertexTextures: v, floatFragmentTextures: y, floatVertexTextures: v && y, maxSamples: o ? t.getParameter(36183) : 0 } } function Kr(t) { const e = this; let n = null, i = 0, r = !1, o = !1; const s = new di, a = new $e, c = { value: null, needsUpdate: !1 }; function l() { c.value !== n && (c.value = n, c.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0 } function h(t, n, i, r) { const o = null !== t ? t.length : 0; let l = null; if (0 !== o) { if (l = c.value, !0 !== r || null === l) { const e = i + 4 * o, r = n.matrixWorldInverse; a.getNormalMatrix(r), (null === l || l.length < e) && (l = new Float32Array(e)); for (let e = 0, n = i; e !== o; ++e, n += 4)s.copy(t[e]).applyMatrix4(r, a), s.normal.toArray(l, n), l[n + 3] = s.constant } c.value = l, c.needsUpdate = !0 } return e.numPlanes = o, e.numIntersection = 0, l } this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, o) { const s = 0 !== t.length || e || 0 !== i || r; return r = e, n = h(t, o, 0), i = t.length, s }, this.beginShadows = function () { o = !0, h(null) }, this.endShadows = function () { o = !1, l() }, this.setState = function (e, s, a) { const u = e.clippingPlanes, d = e.clipIntersection, p = e.clipShadows, f = t.get(e); if (!r || null === u || 0 === u.length || o && !p) o ? h(null) : l(); else { const t = o ? 0 : i, e = 4 * t; let r = f.clippingState || null; c.value = r, r = h(u, s, e, a); for (let t = 0; t !== e; ++t)r[t] = n[t]; f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t } } } function $r(t) { let e = new WeakMap; function n(t, e) { return e === $ ? t.mapping = Q : e === tt && (t.mapping = K), t } function i(t) { const n = t.target; n.removeEventListener("dispose", i); const r = e.get(n); void 0 !== r && (e.delete(n), r.dispose()) } return { get: function (r) { if (r && r.isTexture) { const o = r.mapping; if (o === $ || o === tt) { if (e.has(r)) { return n(e.get(r).texture, r.mapping) } { const o = r.image; if (o && o.height > 0) { const s = t.getRenderList(), a = t.getRenderTarget(), c = new Br(o.height / 2); return c.fromEquirectangularTexture(t, r), e.set(r, c), t.setRenderTarget(a), t.setRenderList(s), r.addEventListener("dispose", i), n(c.texture, r.mapping) } return null } } } return r }, dispose: function () { e = new WeakMap } } } function to(t) { const e = {}; function n(n) { if (void 0 !== e[n]) return e[n]; let i; switch (n) { case "WEBGL_depth_texture": i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = t.getExtension(n) }return e[n] = i, i } return { has: function (t) { return null !== n(t) }, init: function (t) { t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float") }, get: function (t) { const e = n(t); return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e } } } function eo(t, e, n, i) { const r = {}, o = new WeakMap; function s(t) { const a = t.target; null !== a.index && e.remove(a.index); for (const t in a.attributes) e.remove(a.attributes[t]); a.removeEventListener("dispose", s), delete r[a.id]; const c = o.get(a); c && (e.remove(c), o.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries-- } function a(t) { const n = [], i = t.index, r = t.attributes.position; let s = 0; if (null !== i) { const t = i.array; s = i.version; for (let e = 0, i = t.length; e < i; e += 3) { const i = t[e + 0], r = t[e + 1], o = t[e + 2]; n.push(i, r, r, o, o, i) } } else { const t = r.array; s = r.version; for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) { const t = e + 0, i = e + 1, r = e + 2; n.push(t, i, i, r, r, t) } } const a = new (Yi(n) > 65535 ? Wi : ki)(n, 1); a.version = s; const c = o.get(t); c && e.remove(c), o.set(t, a) } return { get: function (t, e) { return !0 === r[e.id] ? e : (e.addEventListener("dispose", s), r[e.id] = !0, n.memory.geometries++, e) }, update: function (t) { const n = t.attributes; for (const t in n) e.update(n[t], 34962); const i = t.morphAttributes; for (const t in i) { const n = i[t]; for (let t = 0, i = n.length; t < i; t++)e.update(n[t], 34962) } }, getWireframeAttribute: function (t) { const e = o.get(t); if (e) { const n = t.index; null !== n && e.version < n.version && a(t) } else a(t); return o.get(t) } } } function no(t, e, n, i) { const r = i.isWebGL2; let o, s, a; this.setMode = function (t) { o = t }, this.setIndex = function (t) { s = t.type, a = t.bytesPerElement }, this.render = function (e, i) { t.drawElements(o, i, s, e * a), n.update(i, o, 1) }, this.renderInstances = function (i, c, l) { if (0 === l) return; let h, u; if (r) h = t, u = "drawElementsInstanced"; else if (u = "drawElementsInstancedANGLE", null === (h = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); h[u](o, c, s, i * a, l), n.update(c, o, l) } } function io(t) { const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function () { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 }, update: function (t, n, i) { switch (e.calls++, n) { case 4: e.triangles += i * (t / 3); break; case 1: e.lines += i * (t / 2); break; case 3: e.lines += i * (t - 1); break; case 2: e.lines += i * t; break; case 0: e.points += i * t; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", n) } } } } function ro(t, e) { return t[0] - e[0] } function oo(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) } function so(t) { const e = {}, n = new Float32Array(8), i = []; for (let t = 0; t < 8; t++)i[t] = [t, 0]; return { update: function (r, o, s, a) { const c = r.morphTargetInfluences, l = void 0 === c ? 0 : c.length; let h = e[o.id]; if (void 0 === h) { h = []; for (let t = 0; t < l; t++)h[t] = [t, 0]; e[o.id] = h } for (let t = 0; t < l; t++) { const e = h[t]; e[0] = t, e[1] = c[t] } h.sort(oo); for (let t = 0; t < 8; t++)t < l && h[t][1] ? (i[t][0] = h[t][0], i[t][1] = h[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0); i.sort(ro); const u = s.morphTargets && o.morphAttributes.position, d = s.morphNormals && o.morphAttributes.normal; let p = 0; for (let t = 0; t < 8; t++) { const e = i[t], r = e[0], s = e[1]; r !== Number.MAX_SAFE_INTEGER && s ? (u && o.getAttribute("morphTarget" + t) !== u[r] && o.setAttribute("morphTarget" + t, u[r]), d && o.getAttribute("morphNormal" + t) !== d[r] && o.setAttribute("morphNormal" + t, d[r]), n[t] = s, p += s) : (u && !0 === o.hasAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t), d && !0 === o.hasAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t), n[t] = 0) } const f = o.morphTargetsRelative ? 1 : 1 - p; a.getUniforms().setValue(t, "morphTargetBaseInfluence", f), a.getUniforms().setValue(t, "morphTargetInfluences", n) } } } function ao(t, e, n, i) { let r = new WeakMap; function o(t) { const e = t.target; e.removeEventListener("dispose", o), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor) } return { update: function (t) { const s = i.render.frame, a = t.geometry, c = e.get(t, a); return r.get(c) !== s && (e.update(c), r.set(c, s)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", o) && t.addEventListener("dispose", o), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), c }, dispose: function () { r = new WeakMap } } } function co(t = null, e = 1, n = 1, i = 1) { rn.call(this, null), this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = st, this.minFilter = st, this.wrapR = rt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } function lo(t = null, e = 1, n = 1, i = 1) { rn.call(this, null), this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = st, this.minFilter = st, this.wrapR = rt, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0 } Xr.physical = { uniforms: Tr([Xr.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Ke(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new Pi(0) }, transmission: { value: 0 }, transmissionMap: { value: null } }]), vertexShader: jr.meshphysical_vert, fragmentShader: jr.meshphysical_frag }, co.prototype = Object.create(rn.prototype), co.prototype.constructor = co, co.prototype.isDataTexture2DArray = !0, lo.prototype = Object.create(rn.prototype), lo.prototype.constructor = lo, lo.prototype.isDataTexture3D = !0; const ho = new rn, uo = new co, po = new lo, fo = new zr, mo = [], go = [], vo = new Float32Array(16), yo = new Float32Array(9), xo = new Float32Array(4); function _o(t, e, n) { const i = t[0]; if (i <= 0 || i > 0) return t; const r = e * n; let o = mo[r]; if (void 0 === o && (o = new Float32Array(r), mo[r] = o), 0 !== e) { i.toArray(o, 0); for (let i = 1, r = 0; i !== e; ++i)r += n, t[i].toArray(o, r) } return o } function bo(t, e) { if (t.length !== e.length) return !1; for (let n = 0, i = t.length; n < i; n++)if (t[n] !== e[n]) return !1; return !0 } function wo(t, e) { for (let n = 0, i = e.length; n < i; n++)t[n] = e[n] } function Mo(t, e) { let n = go[e]; void 0 === n && (n = new Int32Array(e), go[e] = n); for (let i = 0; i !== e; ++i)n[i] = t.allocateTextureUnit(); return n } function So(t, e) { const n = this.cache; n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e) } function Eo(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y); else { if (bo(n, e)) return; t.uniform2fv(this.addr, e), wo(n, e) } } function To(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z); else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b); else { if (bo(n, e)) return; t.uniform3fv(this.addr, e), wo(n, e) } } function Ao(t, e) { const n = this.cache; if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w); else { if (bo(n, e)) return; t.uniform4fv(this.addr, e), wo(n, e) } } function Lo(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (bo(n, e)) return; t.uniformMatrix2fv(this.addr, !1, e), wo(n, e) } else { if (bo(n, i)) return; xo.set(i), t.uniformMatrix2fv(this.addr, !1, xo), wo(n, i) } } function Ro(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (bo(n, e)) return; t.uniformMatrix3fv(this.addr, !1, e), wo(n, e) } else { if (bo(n, i)) return; yo.set(i), t.uniformMatrix3fv(this.addr, !1, yo), wo(n, i) } } function Po(t, e) { const n = this.cache, i = e.elements; if (void 0 === i) { if (bo(n, e)) return; t.uniformMatrix4fv(this.addr, !1, e), wo(n, e) } else { if (bo(n, i)) return; vo.set(i), t.uniformMatrix4fv(this.addr, !1, vo), wo(n, i) } } function Co(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || ho, r) } function Io(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || uo, r) } function Oo(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || po, r) } function Do(t, e, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || fo, r) } function No(t, e) { const n = this.cache; n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e) } function zo(t, e) { const n = this.cache; bo(n, e) || (t.uniform2iv(this.addr, e), wo(n, e)) } function Bo(t, e) { const n = this.cache; bo(n, e) || (t.uniform3iv(this.addr, e), wo(n, e)) } function Ho(t, e) { const n = this.cache; bo(n, e) || (t.uniform4iv(this.addr, e), wo(n, e)) } function Uo(t, e) { const n = this.cache; n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e) } function Fo(t, e) { t.uniform1fv(this.addr, e) } function Go(t, e) { t.uniform1iv(this.addr, e) } function ko(t, e) { t.uniform2iv(this.addr, e) } function Vo(t, e) { t.uniform3iv(this.addr, e) } function Wo(t, e) { t.uniform4iv(this.addr, e) } function jo(t, e) { const n = _o(e, this.size, 2); t.uniform2fv(this.addr, n) } function qo(t, e) { const n = _o(e, this.size, 3); t.uniform3fv(this.addr, n) } function Xo(t, e) { const n = _o(e, this.size, 4); t.uniform4fv(this.addr, n) } function Yo(t, e) { const n = _o(e, this.size, 4); t.uniformMatrix2fv(this.addr, !1, n) } function Zo(t, e) { const n = _o(e, this.size, 9); t.uniformMatrix3fv(this.addr, !1, n) } function Jo(t, e) { const n = _o(e, this.size, 16); t.uniformMatrix4fv(this.addr, !1, n) } function Qo(t, e, n) { const i = e.length, r = Mo(n, i); t.uniform1iv(this.addr, r); for (let t = 0; t !== i; ++t)n.safeSetTexture2D(e[t] || ho, r[t]) } function Ko(t, e, n) { const i = e.length, r = Mo(n, i); t.uniform1iv(this.addr, r); for (let t = 0; t !== i; ++t)n.safeSetTextureCube(e[t] || fo, r[t]) } function $o(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.setValue = function (t) { switch (t) { case 5126: return So; case 35664: return Eo; case 35665: return To; case 35666: return Ao; case 35674: return Lo; case 35675: return Ro; case 35676: return Po; case 5124: case 35670: return No; case 35667: case 35671: return zo; case 35668: case 35672: return Bo; case 35669: case 35673: return Ho; case 5125: return Uo; case 35678: case 36198: case 36298: case 36306: case 35682: return Co; case 35679: case 36299: case 36307: return Oo; case 35680: case 36300: case 36308: case 36293: return Do; case 36289: case 36303: case 36311: case 36292: return Io } }(e.type) } function ts(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function (t) { switch (t) { case 5126: return Fo; case 35664: return jo; case 35665: return qo; case 35666: return Xo; case 35674: return Yo; case 35675: return Zo; case 35676: return Jo; case 5124: case 35670: return Go; case 35667: case 35671: return ko; case 35668: case 35672: return Vo; case 35669: case 35673: return Wo; case 35678: case 36198: case 36298: case 36306: case 35682: return Qo; case 35680: case 36300: case 36308: case 36293: return Ko } }(e.type) } function es(t) { this.id = t, this.seq = [], this.map = {} } ts.prototype.updateCache = function (t) { const e = this.cache; t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), wo(e, t) }, es.prototype.setValue = function (t, e, n) { const i = this.seq; for (let r = 0, o = i.length; r !== o; ++r) { const o = i[r]; o.setValue(t, e[o.id], n) } }; const ns = /(\w+)(\])?(\[|\.)?/g; function is(t, e) { t.seq.push(e), t.map[e.id] = e } function rs(t, e, n) { const i = t.name, r = i.length; for (ns.lastIndex = 0; ;) { const o = ns.exec(i), s = ns.lastIndex; let a = o[1]; const c = "]" === o[2], l = o[3]; if (c && (a |= 0), void 0 === l || "[" === l && s + 2 === r) { is(n, void 0 === l ? new $o(a, t, e) : new ts(a, t, e)); break } { let t = n.map[a]; void 0 === t && is(n, t = new es(a)), n = t } } } function os(t, e) { this.seq = [], this.map = {}; const n = t.getProgramParameter(e, 35718); for (let i = 0; i < n; ++i) { const n = t.getActiveUniform(e, i); rs(n, t.getUniformLocation(e, n.name), this) } } function ss(t, e, n) { const i = t.createShader(e); return t.shaderSource(i, n), t.compileShader(i), i } os.prototype.setValue = function (t, e, n, i) { const r = this.map[e]; void 0 !== r && r.setValue(t, n, i) }, os.prototype.setOptional = function (t, e, n) { const i = e[n]; void 0 !== i && this.setValue(t, n, i) }, os.upload = function (t, e, n, i) { for (let r = 0, o = e.length; r !== o; ++r) { const o = e[r], s = n[o.id]; !1 !== s.needsUpdate && o.setValue(t, s.value, i) } }, os.seqWithValue = function (t, e) { const n = []; for (let i = 0, r = t.length; i !== r; ++i) { const r = t[i]; r.id in e && n.push(r) } return n }; let as = 0; function cs(t) { switch (t) { case Ce: return ["Linear", "( value )"]; case Ie: return ["sRGB", "( value )"]; case De: return ["RGBE", "( value )"]; case ze: return ["RGBM", "( value, 7.0 )"]; case Be: return ["RGBM", "( value, 16.0 )"]; case He: return ["RGBD", "( value, 256.0 )"]; case Oe: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case Ne: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"] } } function ls(t, e, n) { const i = t.getShaderParameter(e, 35713), r = t.getShaderInfoLog(e).trim(); return i && "" === r ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function (t) { const e = t.split("\n"); for (let t = 0; t < e.length; t++)e[t] = t + 1 + ": " + e[t]; return e.join("\n") }(t.getShaderSource(e)) } function hs(t, e) { const n = cs(e); return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" } function us(t, e) { const n = cs(e); return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" } function ds(t, e) { let n; switch (e) { case q: n = "Linear"; break; case X: n = "Reinhard"; break; case Y: n = "OptimizedCineon"; break; case Z: n = "ACESFilmic"; break; case J: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear" }return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }" } function ps(t) { return "" !== t } function fs(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows) } function ms(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } const gs = /^[ \t]*#include +<([\w\d./]+)>/gm; function vs(t) { return t.replace(gs, ys) } function ys(t, e) { const n = jr[e]; if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">"); return vs(n) } const xs = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, _s = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function bs(t) { return t.replace(_s, Ms).replace(xs, ws) } function ws(t, e, n, i) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Ms(t, e, n, i) } function Ms(t, e, n, i) { let r = ""; for (let t = parseInt(e); t < parseInt(n); t++)r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t); return r } function Ss(t) { let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;"; return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e } function Es(t, e, n, i) { const r = t.getContext(), o = n.defines; let l = n.vertexShader, h = n.fragmentShader; const u = function (t) { let e = "SHADOWMAP_TYPE_BASIC"; return t.shadowMapType === s ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === a ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === c && (e = "SHADOWMAP_TYPE_VSM"), e }(n), d = function (t) { let e = "ENVMAP_TYPE_CUBE"; if (t.envMap) switch (t.envMapMode) { case Q: case K: e = "ENVMAP_TYPE_CUBE"; break; case et: case nt: e = "ENVMAP_TYPE_CUBE_UV" }return e }(n), p = function (t) { let e = "ENVMAP_MODE_REFLECTION"; if (t.envMap) switch (t.envMapMode) { case K: case nt: e = "ENVMAP_MODE_REFRACTION" }return e }(n), f = function (t) { let e = "ENVMAP_BLENDING_NONE"; if (t.envMap) switch (t.combine) { case k: e = "ENVMAP_BLENDING_MULTIPLY"; break; case V: e = "ENVMAP_BLENDING_MIX"; break; case W: e = "ENVMAP_BLENDING_ADD" }return e }(n), m = t.gammaFactor > 0 ? t.gammaFactor : 1, g = n.isWebGL2 ? "" : function (t) { return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ps).join("\n") }(n), v = function (t) { const e = []; for (const n in t) { const i = t[n]; !1 !== i && e.push("#define " + n + " " + i) } return e.join("\n") }(o), y = r.createProgram(); let x, _, b = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? ((x = [v].filter(ps).join("\n")).length > 0 && (x += "\n"), (_ = [g, v].filter(ps).join("\n")).length > 0 && (_ += "\n")) : (x = [Ss(n), "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ps).join("\n"), _ = [g, Ss(n), "#define SHADER_NAME " + n.shaderName, v, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + f : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== j ? "#define TONE_MAPPING" : "", n.toneMapping !== j ? jr.tonemapping_pars_fragment : "", n.toneMapping !== j ? ds("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", jr.encodings_pars_fragment, n.map ? hs("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? hs("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? hs("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? hs("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? hs("lightMapTexelToLinear", n.lightMapEncoding) : "", us("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ps).join("\n")), l = ms(l = fs(l = vs(l), n), n), h = ms(h = fs(h = vs(h), n), n), l = bs(l), h = bs(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (b = "#version 300 es\n", x = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x, _ = ["#define varying in", n.glslVersion === Xe ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === Xe ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _); const w = b + _ + h, M = ss(r, 35633, b + x + l), S = ss(r, 35632, w); if (r.attachShader(y, M), r.attachShader(y, S), void 0 !== n.index0AttributeName ? r.bindAttribLocation(y, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y), t.debug.checkShaderErrors) { const t = r.getProgramInfoLog(y).trim(), e = r.getShaderInfoLog(M).trim(), n = r.getShaderInfoLog(S).trim(); let i = !0, o = !0; if (!1 === r.getProgramParameter(y, 35714)) { i = !1; const e = ls(r, M, "vertex"), n = ls(r, S, "fragment"); console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(y, 35715), "gl.getProgramInfoLog", t, e, n) } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (o = !1); o && (this.diagnostics = { runnable: i, programLog: t, vertexShader: { log: e, prefix: x }, fragmentShader: { log: n, prefix: _ } }) } let E, T; return r.deleteShader(M), r.deleteShader(S), this.getUniforms = function () { return void 0 === E && (E = new os(r, y)), E }, this.getAttributes = function () { return void 0 === T && (T = function (t, e) { const n = {}, i = t.getProgramParameter(e, 35721); for (let r = 0; r < i; r++) { const i = t.getActiveAttrib(e, r).name; n[i] = t.getAttribLocation(e, i) } return n }(r, y)), T }, this.destroy = function () { i.releaseStatesOfProgram(this), r.deleteProgram(y), this.program = void 0 }, this.name = n.shaderName, this.id = as++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = M, this.fragmentShader = S, this } function Ts(t, e, n, i, r, o) { const s = [], a = i.isWebGL2, c = i.logarithmicDepthBuffer, l = i.floatVertexTextures, d = i.maxVertexUniforms, p = i.vertexTextures; let f = i.precision; const m = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, g = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"]; function v(t) { let e; return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = Ce, e } return { getParameters: function (r, s, g, y, x) { const _ = y.fog, b = r.isMeshStandardMaterial ? y.environment : null, w = e.get(r.envMap || b), M = m[r.type], S = x.isSkinnedMesh ? function (t) { const e = t.skeleton.bones; if (l) return 1024; { const t = d, n = Math.floor((t - 20) / 4), i = Math.min(n, e.length); return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i } }(x) : 0; let E, T; if (null !== r.precision && (f = i.getMaxPrecision(r.precision)) !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", f, "instead."), M) { const t = Xr[M]; E = t.vertexShader, T = t.fragmentShader } else E = r.vertexShader, T = r.fragmentShader; const A = t.getRenderTarget(); return { isWebGL2: a, shaderID: M, shaderName: r.type, vertexShader: E, fragmentShader: T, defines: r.defines, isRawShaderMaterial: !0 === r.isRawShaderMaterial, glslVersion: r.glslVersion, precision: f, instancing: !0 === x.isInstancedMesh, instancingColor: !0 === x.isInstancedMesh && null !== x.instanceColor, supportsVertexTextures: p, outputEncoding: null !== A ? v(A.texture) : t.outputEncoding, map: !!r.map, mapEncoding: v(r.map), matcap: !!r.matcap, matcapEncoding: v(r.matcap), envMap: !!w, envMapMode: w && w.mapping, envMapEncoding: v(w), envMapCubeUV: !!w && (w.mapping === et || w.mapping === nt), lightMap: !!r.lightMap, lightMapEncoding: v(r.lightMap), aoMap: !!r.aoMap, emissiveMap: !!r.emissiveMap, emissiveMapEncoding: v(r.emissiveMap), bumpMap: !!r.bumpMap, normalMap: !!r.normalMap, objectSpaceNormalMap: r.normalMapType === ke, tangentSpaceNormalMap: r.normalMapType === Ge, clearcoatMap: !!r.clearcoatMap, clearcoatRoughnessMap: !!r.clearcoatRoughnessMap, clearcoatNormalMap: !!r.clearcoatNormalMap, displacementMap: !!r.displacementMap, roughnessMap: !!r.roughnessMap, metalnessMap: !!r.metalnessMap, specularMap: !!r.specularMap, alphaMap: !!r.alphaMap, gradientMap: !!r.gradientMap, sheen: !!r.sheen, transmissionMap: !!r.transmissionMap, combine: r.combine, vertexTangents: r.normalMap && r.vertexTangents, vertexColors: r.vertexColors, vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap), uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap || !r.displacementMap), fog: !!_, useFog: r.fog, fogExp2: _ && _.isFogExp2, flatShading: r.flatShading, sizeAttenuation: r.sizeAttenuation, logarithmicDepthBuffer: c, skinning: r.skinning && S > 0, maxBones: S, useVertexTexture: l, morphTargets: r.morphTargets, morphNormals: r.morphNormals, maxMorphTargets: t.maxMorphTargets, maxMorphNormals: t.maxMorphNormals, numDirLights: s.directional.length, numPointLights: s.point.length, numSpotLights: s.spot.length, numRectAreaLights: s.rectArea.length, numHemiLights: s.hemi.length, numDirLightShadows: s.directionalShadowMap.length, numPointLightShadows: s.pointShadowMap.length, numSpotLightShadows: s.spotShadowMap.length, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: r.dithering, shadowMapEnabled: t.shadowMap.enabled && g.length > 0, shadowMapType: t.shadowMap.type, toneMapping: r.toneMapped ? t.toneMapping : j, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: r.premultipliedAlpha, alphaTest: r.alphaTest, doubleSided: r.side === u, flipSided: r.side === h, depthPacking: void 0 !== r.depthPacking && r.depthPacking, index0AttributeName: r.index0AttributeName, extensionDerivatives: r.extensions && r.extensions.derivatives, extensionFragDepth: r.extensions && r.extensions.fragDepth, extensionDrawBuffers: r.extensions && r.extensions.drawBuffers, extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD, rendererExtensionFragDepth: a || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"), customProgramCacheKey: r.customProgramCacheKey() } }, getProgramCacheKey: function (e) { const n = []; if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (const t in e.defines) n.push(t), n.push(e.defines[t]); if (!1 === e.isRawShaderMaterial) { for (let t = 0; t < g.length; t++)n.push(e[g[t]]); n.push(t.outputEncoding), n.push(t.gammaFactor) } return n.push(e.customProgramCacheKey), n.join() }, getUniforms: function (t) { const e = m[t.type]; let n; if (e) { const t = Xr[e]; n = Ar.clone(t.uniforms) } else n = t.uniforms; return n }, acquireProgram: function (e, n) { let i; for (let t = 0, e = s.length; t < e; t++) { const e = s[t]; if (e.cacheKey === n) { ++(i = e).usedTimes; break } } return void 0 === i && (i = new Es(t, n, e, r), s.push(i)), i }, releaseProgram: function (t) { if (0 == --t.usedTimes) { const e = s.indexOf(t); s[e] = s[s.length - 1], s.pop(), t.destroy() } }, programs: s } } function As() { let t = new WeakMap; return { get: function (e) { let n = t.get(e); return void 0 === n && (n = {}, t.set(e, n)), n }, remove: function (e) { t.delete(e) }, update: function (e, n, i) { t.get(e)[n] = i }, dispose: function () { t = new WeakMap } } } function Ls(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function Rs(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function Ps(t) { const e = []; let n = 0; const i = [], r = [], o = { id: -1 }; function s(i, r, s, a, c, l) { let h = e[n]; const u = t.get(s); return void 0 === h ? (h = { id: i.id, object: i, geometry: r, material: s, program: u.program || o, groupOrder: a, renderOrder: i.renderOrder, z: c, group: l }, e[n] = h) : (h.id = i.id, h.object = i, h.geometry = r, h.material = s, h.program = u.program || o, h.groupOrder = a, h.renderOrder = i.renderOrder, h.z = c, h.group = l), n++, h } return { opaque: i, transparent: r, init: function () { n = 0, i.length = 0, r.length = 0 }, push: function (t, e, n, o, a, c) { const l = s(t, e, n, o, a, c); (!0 === n.transparent ? r : i).push(l) }, unshift: function (t, e, n, o, a, c) { const l = s(t, e, n, o, a, c); (!0 === n.transparent ? r : i).unshift(l) }, finish: function () { for (let t = n, i = e.length; t < i; t++) { const n = e[t]; if (null === n.id) break; n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null } }, sort: function (t, e) { i.length > 1 && i.sort(t || Ls), r.length > 1 && r.sort(e || Rs) } } } function Cs(t) { let e = new WeakMap; return { get: function (n, i) { const r = e.get(n); let o; return void 0 === r ? (o = new Ps(t), e.set(n, new WeakMap), e.get(n).set(i, o)) : void 0 === (o = r.get(i)) && (o = new Ps(t), r.set(i, o)), o }, dispose: function () { e = new WeakMap } } } function Is() { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": n = { direction: new ln, color: new Pi }; break; case "SpotLight": n = { position: new ln, direction: new ln, color: new Pi, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new ln, color: new Pi, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new ln, skyColor: new Pi, groundColor: new Pi }; break; case "RectAreaLight": n = { color: new Pi, position: new ln, halfWidth: new ln, halfHeight: new ln } }return t[e.id] = n, n } } } let Os = 0; function Ds(t, e) { return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0) } function Ns(t, e) { const n = new Is, i = function () { const t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; let n; switch (e.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Ke }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Ke, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return t[e.id] = n, n } } }(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let t = 0; t < 9; t++)r.probe.push(new ln); const o = new ln, s = new Bn, a = new Bn; return { setup: function (o) { let s = 0, a = 0, c = 0; for (let t = 0; t < 9; t++)r.probe[t].set(0, 0, 0); let l = 0, h = 0, u = 0, d = 0, p = 0, f = 0, m = 0, g = 0; o.sort(Ds); for (let t = 0, e = o.length; t < e; t++) { const e = o[t], v = e.color, y = e.intensity, x = e.distance, _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null; if (e.isAmbientLight) s += v.r * y, a += v.g * y, c += v.b * y; else if (e.isLightProbe) for (let t = 0; t < 9; t++)r.probe[t].addScaledVector(e.sh.coefficients[t], y); else if (e.isDirectionalLight) { const t = n.get(e); if (t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow) { const t = e.shadow, n = i.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[l] = n, r.directionalShadowMap[l] = _, r.directionalShadowMatrix[l] = e.shadow.matrix, f++ } r.directional[l] = t, l++ } else if (e.isSpotLight) { const t = n.get(e); if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(v).multiplyScalar(y), t.distance = x, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) { const t = e.shadow, n = i.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.spotShadow[u] = n, r.spotShadowMap[u] = _, r.spotShadowMatrix[u] = e.shadow.matrix, g++ } r.spot[u] = t, u++ } else if (e.isRectAreaLight) { const t = n.get(e); t.color.copy(v).multiplyScalar(y), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[d] = t, d++ } else if (e.isPointLight) { const t = n.get(e); if (t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) { const t = e.shadow, n = i.get(e); n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = _, r.pointShadowMatrix[h] = e.shadow.matrix, m++ } r.point[h] = t, h++ } else if (e.isHemisphereLight) { const t = n.get(e); t.skyColor.copy(e.color).multiplyScalar(y), t.groundColor.copy(e.groundColor).multiplyScalar(y), r.hemi[p] = t, p++ } } d > 0 && (e.isWebGL2 ? (r.rectAreaLTC1 = qr.LTC_FLOAT_1, r.rectAreaLTC2 = qr.LTC_FLOAT_2) : !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = qr.LTC_FLOAT_1, r.rectAreaLTC2 = qr.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = qr.LTC_HALF_1, r.rectAreaLTC2 = qr.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = s, r.ambient[1] = a, r.ambient[2] = c; const v = r.hash; v.directionalLength === l && v.pointLength === h && v.spotLength === u && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (r.directional.length = l, r.spot.length = u, r.rectArea.length = d, r.point.length = h, r.hemi.length = p, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = m, r.pointShadowMap.length = m, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = m, r.spotShadowMatrix.length = g, v.directionalLength = l, v.pointLength = h, v.spotLength = u, v.rectAreaLength = d, v.hemiLength = p, v.numDirectionalShadows = f, v.numPointShadows = m, v.numSpotShadows = g, r.version = Os++) }, setupView: function (t, e) { let n = 0, i = 0, c = 0, l = 0, h = 0; const u = e.matrixWorldInverse; for (let e = 0, d = t.length; e < d; e++) { const d = t[e]; if (d.isDirectionalLight) { const t = r.directional[n]; t.direction.setFromMatrixPosition(d.matrixWorld), o.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(u), n++ } else if (d.isSpotLight) { const t = r.spot[c]; t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(d.matrixWorld), o.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(o), t.direction.transformDirection(u), c++ } else if (d.isRectAreaLight) { const t = r.rectArea[l]; t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), a.identity(), s.copy(d.matrixWorld), s.premultiply(u), a.extractRotation(s), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), l++ } else if (d.isPointLight) { const t = r.point[i]; t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), i++ } else if (d.isHemisphereLight) { const t = r.hemi[h]; t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(u), t.direction.normalize(), h++ } } }, state: r } } function zs(t, e) { const n = new Ns(t, e), i = [], r = []; return { init: function () { i.length = 0, r.length = 0 }, state: { lightsArray: i, shadowsArray: r, lights: n }, setupLights: function () { n.setup(i) }, setupLightsView: function (t) { n.setupView(i, t) }, pushLight: function (t) { i.push(t) }, pushShadow: function (t) { r.push(t) } } } function Bs(t, e) { let n = new WeakMap; return { get: function (i, r = 0) { let o; return !1 === n.has(i) ? (o = new zs(t, e), n.set(i, []), n.get(i).push(o)) : r >= n.get(i).length ? (o = new zs(t, e), n.get(i).push(o)) : o = n.get(i)[r], o }, dispose: function () { n = new WeakMap } } } function Hs(t) { Oi.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Ue, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t) } function Us(t) { Oi.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new ln, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t) } Hs.prototype = Object.create(Oi.prototype), Hs.prototype.constructor = Hs, Hs.prototype.isMeshDepthMaterial = !0, Hs.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, Us.prototype = Object.create(Oi.prototype), Us.prototype.constructor = Us, Us.prototype.isMeshDistanceMaterial = !0, Us.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this }; var Fs = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}", Gs = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}"; function ks(t, e, n) { let i = new Gr; const r = new Ke, o = new Ke, a = new sn, p = [], f = [], m = {}, g = { 0: h, 1: l, 2: u }, v = new Pr({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Ke }, radius: { value: 4 } }, vertexShader: Gs, fragmentShader: Fs }), y = v.clone(); y.defines.HORIZONTAL_PASS = 1; const x = new rr; x.setAttribute("position", new Bi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const _ = new wr(x, v), b = this; function w(n, i) { const r = e.update(_); v.uniforms.shadow_pass.value = n.map.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, v, _, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, y, _, null) } function M(t, e, n) { const i = t << 0 | e << 1 | n << 2; let r = p[i]; return void 0 === r && (r = new Hs({ depthPacking: Fe, morphTargets: t, skinning: e }), p[i] = r), r } function S(t, e, n) { const i = t << 0 | e << 1 | n << 2; let r = f[i]; return void 0 === r && (r = new Us({ morphTargets: t, skinning: e }), f[i] = r), r } function E(e, n, i, r, o, s, a) { let l = null, h = M, u = e.customDepthMaterial; if (!0 === r.isPointLight && (h = S, u = e.customDistanceMaterial), void 0 === u) { let t = !1; !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0); let r = !1; !0 === e.isSkinnedMesh && (!0 === i.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), l = h(t, r, !0 === e.isInstancedMesh) } else l = u; if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) { const t = l.uuid, e = i.uuid; let n = m[t]; void 0 === n && (n = {}, m[t] = n); let r = n[e]; void 0 === r && (r = l.clone(), n[e] = r), l = r } return l.visible = i.visible, l.wireframe = i.wireframe, l.side = a === c ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : g[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = o, l.farDistance = s), l } function T(n, r, o, s, a) { if (!1 === n.visible) return; if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === c) && (!n.frustumCulled || i.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld); const i = e.update(n), r = n.material; if (Array.isArray(r)) { const e = i.groups; for (let c = 0, l = e.length; c < l; c++) { const l = e[c], h = r[l.materialIndex]; if (h && h.visible) { const e = E(n, i, h, s, o.near, o.far, a); t.renderBufferDirect(o, null, i, e, n, l) } } } else if (r.visible) { const e = E(n, i, r, s, o.near, o.far, a); t.renderBufferDirect(o, null, i, e, n, null) } } const l = n.children; for (let t = 0, e = l.length; t < e; t++)T(l[t], r, o, s, a) } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = s, this.render = function (e, s, l) { if (!1 === b.enabled) return; if (!1 === b.autoUpdate && !1 === b.needsUpdate) return; if (0 === e.length) return; const h = t.getRenderTarget(), u = t.getActiveCubeFace(), p = t.getActiveMipmapLevel(), f = t.state; f.setBlending(d), f.buffers.color.setClear(1, 1, 1, 1), f.buffers.depth.setTest(!0), f.setScissorTest(!1); for (let h = 0, u = e.length; h < u; h++) { const u = e[h], d = u.shadow; if (void 0 === d) { console.warn("THREE.WebGLShadowMap:", u, "has no shadow."); continue } if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue; r.copy(d.mapSize); const p = d.getFrameExtents(); if (r.multiply(p), o.copy(d.mapSize), (r.x > n || r.y > n) && (r.x > n && (o.x = Math.floor(n / p.x), r.x = o.x * p.x, d.mapSize.x = o.x), r.y > n && (o.y = Math.floor(n / p.y), r.y = o.y * p.y, d.mapSize.y = o.y)), null === d.map && !d.isPointLightShadow && this.type === c) { const t = { minFilter: lt, magFilter: lt, format: Tt }; d.map = new an(r.x, r.y, t), d.map.texture.name = u.name + ".shadowMap", d.mapPass = new an(r.x, r.y, t), d.camera.updateProjectionMatrix() } if (null === d.map) { const t = { minFilter: st, magFilter: st, format: Tt }; d.map = new an(r.x, r.y, t), d.map.texture.name = u.name + ".shadowMap", d.camera.updateProjectionMatrix() } t.setRenderTarget(d.map), t.clear(); const m = d.getViewportCount(); for (let t = 0; t < m; t++) { const e = d.getViewport(t); a.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w), f.viewport(a), d.updateMatrices(u, t), i = d.getFrustum(), T(s, l, d.camera, u, this.type) } d.isPointLightShadow || this.type !== c || w(d, l), d.needsUpdate = !1 } b.needsUpdate = !1, t.setRenderTarget(h, u, p) } } function Vs(t, e, n) { const s = n.isWebGL2; const a = new function () { let e = !1; const n = new sn; let i = null; const r = new sn(0, 0, 0, 0); return { setMask: function (n) { i === n || e || (t.colorMask(n, n, n, n), i = n) }, setLocked: function (t) { e = t }, setClear: function (e, i, o, s, a) { !0 === a && (e *= s, i *= s, o *= s), n.set(e, i, o, s), !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n)) }, reset: function () { e = !1, i = null, r.set(-1, 0, 0, 0) } } }, c = new function () { let e = !1, n = null, i = null, r = null; return { setTest: function (t) { t ? ft(2929) : mt(2929) }, setMask: function (i) { n === i || e || (t.depthMask(i), n = i) }, setFunc: function (e) { if (i !== e) { if (e) switch (e) { case D: t.depthFunc(512); break; case N: t.depthFunc(519); break; case z: t.depthFunc(513); break; case B: t.depthFunc(515); break; case H: t.depthFunc(514); break; case U: t.depthFunc(518); break; case F: t.depthFunc(516); break; case G: t.depthFunc(517); break; default: t.depthFunc(515) } else t.depthFunc(515); i = e } }, setLocked: function (t) { e = t }, setClear: function (e) { r !== e && (t.clearDepth(e), r = e) }, reset: function () { e = !1, n = null, i = null, r = null } } }, l = new function () { let e = !1, n = null, i = null, r = null, o = null, s = null, a = null, c = null, l = null; return { setTest: function (t) { e || (t ? ft(2960) : mt(2960)) }, setMask: function (i) { n === i || e || (t.stencilMask(i), n = i) }, setFunc: function (e, n, s) { i === e && r === n && o === s || (t.stencilFunc(e, n, s), i = e, r = n, o = s) }, setOp: function (e, n, i) { s === e && a === n && c === i || (t.stencilOp(e, n, i), s = e, a = n, c = i) }, setLocked: function (t) { e = t }, setClear: function (e) { l !== e && (t.clearStencil(e), l = e) }, reset: function () { e = !1, n = null, i = null, r = null, o = null, s = null, a = null, c = null, l = null } } }; let k = {}, V = null, W = null, j = null, q = null, X = null, Y = null, Z = null, J = null, Q = null, K = !1, $ = null, tt = null, et = null, nt = null, it = null; const rt = t.getParameter(35661); let ot = !1, st = 0; const at = t.getParameter(7938); -1 !== at.indexOf("WebGL") ? (st = parseFloat(/^WebGL (\d)/.exec(at)[1]), ot = st >= 1) : -1 !== at.indexOf("OpenGL ES") && (st = parseFloat(/^OpenGL ES (\d)/.exec(at)[1]), ot = st >= 2); let ct = null, lt = {}; const ht = new sn, ut = new sn; function dt(e, n, i) { const r = new Uint8Array(4), o = t.createTexture(); t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728); for (let e = 0; e < i; e++)t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r); return o } const pt = {}; function ft(e) { !0 !== k[e] && (t.enable(e), k[e] = !0) } function mt(e) { !1 !== k[e] && (t.disable(e), k[e] = !1) } pt[3553] = dt(3553, 3553, 1), pt[34067] = dt(34067, 34069, 6), a.setClear(0, 0, 0, 1), c.setClear(1), l.setClear(0), ft(2929), c.setFunc(B), xt(!1), _t(r), ft(2884), yt(d); const gt = { [y]: 32774, [x]: 32778, [_]: 32779 }; if (s) gt[b] = 32775, gt[w] = 32776; else { const t = e.get("EXT_blend_minmax"); null !== t && (gt[b] = t.MIN_EXT, gt[w] = t.MAX_EXT) } const vt = { [M]: 0, [S]: 1, [E]: 768, [A]: 770, [O]: 776, [C]: 774, [R]: 772, [T]: 769, [L]: 771, [I]: 775, [P]: 773 }; function yt(e, n, i, r, o, s, a, c) { if (e !== d) { if (W || (ft(3042), W = !0), e === v) o = o || n, s = s || i, a = a || r, n === q && o === Z || (t.blendEquationSeparate(gt[n], gt[o]), q = n, Z = o), i === X && r === Y && s === J && a === Q || (t.blendFuncSeparate(vt[i], vt[r], vt[s], vt[a]), X = i, Y = r, J = s, Q = a), j = e, K = null; else if (e !== j || c !== K) { if (q === y && Z === y || (t.blendEquation(32774), q = y, Z = y), c) switch (e) { case p: t.blendFuncSeparate(1, 771, 1, 771); break; case f: t.blendFunc(1, 1); break; case m: t.blendFuncSeparate(0, 0, 769, 771); break; case g: t.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) { case p: t.blendFuncSeparate(770, 771, 1, 771); break; case f: t.blendFunc(770, 1); break; case m: t.blendFunc(0, 769); break; case g: t.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) }X = null, Y = null, J = null, Q = null, j = e, K = c } } else W && (mt(3042), W = !1) } function xt(e) { $ !== e && (e ? t.frontFace(2304) : t.frontFace(2305), $ = e) } function _t(e) { e !== i ? (ft(2884), e !== tt && (e === r ? t.cullFace(1029) : e === o ? t.cullFace(1028) : t.cullFace(1032))) : mt(2884), tt = e } function bt(e, n, i) { e ? (ft(32823), nt === n && it === i || (t.polygonOffset(n, i), nt = n, it = i)) : mt(32823) } function wt(e) { void 0 === e && (e = 33984 + rt - 1), ct !== e && (t.activeTexture(e), ct = e) } return { buffers: { color: a, depth: c, stencil: l }, enable: ft, disable: mt, useProgram: function (e) { return V !== e && (t.useProgram(e), V = e, !0) }, setBlending: yt, setMaterial: function (t, e) { t.side === u ? mt(2884) : ft(2884); let n = t.side === h; e && (n = !n), xt(n), t.blending === p && !1 === t.transparent ? yt(d) : yt(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), c.setFunc(t.depthFunc), c.setTest(t.depthTest), c.setMask(t.depthWrite), a.setMask(t.colorWrite); const i = t.stencilWrite; l.setTest(i), i && (l.setMask(t.stencilWriteMask), l.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), l.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), bt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits) }, setFlipSided: xt, setCullFace: _t, setLineWidth: function (e) { e !== et && (ot && t.lineWidth(e), et = e) }, setPolygonOffset: bt, setScissorTest: function (t) { t ? ft(3089) : mt(3089) }, activeTexture: wt, bindTexture: function (e, n) { null === ct && wt(); let i = lt[ct]; void 0 === i && (i = { type: void 0, texture: void 0 }, lt[ct] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || pt[e]), i.type = e, i.texture = n) }, unbindTexture: function () { const e = lt[ct]; void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0) }, compressedTexImage2D: function () { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage2D: function () { try { t.texImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage3D: function () { try { t.texImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, scissor: function (e) { !1 === ht.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ht.copy(e)) }, viewport: function (e) { !1 === ut.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), ut.copy(e)) }, reset: function () { k = {}, ct = null, lt = {}, V = null, W = null, j = null, q = null, X = null, Y = null, Z = null, J = null, Q = null, K = !1, $ = null, tt = null, et = null, nt = null, it = null, a.reset(), c.reset(), l.reset() } } } function Ws(t, e, n, i, r, o, s) { const a = r.isWebGL2, c = r.maxTextures, l = r.maxCubemapSize, h = r.maxTextureSize, u = r.maxSamples, d = new WeakMap; let p, f = !1; try { f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (t) { } function m(t, e) { return f ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function g(t, e, n, i) { let r = 1; if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) { const i = e ? Qe.floorPowerOfTwo : Math.floor, o = i(r * t.width), s = i(r * t.height); void 0 === p && (p = m(o, s)); const a = n ? m(o, s) : p; return a.width = o, a.height = s, a.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), a } return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t } return t } function v(t) { return Qe.isPowerOfTwo(t.width) && Qe.isPowerOfTwo(t.height) } function y(t, e) { return t.generateMipmaps && e && t.minFilter !== st && t.minFilter !== lt } function x(e, n, r, o) { t.generateMipmap(e), i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E } function _(n, i, r) { if (!1 === a) return i; if (null !== n) { if (void 0 !== t[n]) return t[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let o = i; return 6403 === i && (5126 === r && (o = 33326), 5131 === r && (o = 33325), 5121 === r && (o = 33321)), 6407 === i && (5126 === r && (o = 34837), 5131 === r && (o = 34843), 5121 === r && (o = 32849)), 6408 === i && (5126 === r && (o = 34836), 5131 === r && (o = 34842), 5121 === r && (o = 32856)), 33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"), o } function b(t) { return t === st || t === at || t === ct ? 9728 : 9729 } function w(e) { const n = e.target; n.removeEventListener("dispose", w), function (e) { const n = i.get(e); if (void 0 === n.__webglInit) return; t.deleteTexture(n.__webglTexture), i.remove(e) }(n), n.isVideoTexture && d.delete(n), s.memory.textures-- } function M(e) { const n = e.target; n.removeEventListener("dispose", M), function (e) { const n = i.get(e), r = i.get(e.texture); if (!e) return; void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture); e.depthTexture && e.depthTexture.dispose(); if (e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++)t.deleteFramebuffer(n.__webglFramebuffer[e]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[e]); else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer), n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer); i.remove(e.texture), i.remove(e) }(n), s.memory.textures-- } let S = 0; function E(t, e) { const r = i.get(t); if (t.isVideoTexture && function (t) { const e = s.render.frame; d.get(t) !== e && (d.set(t, e), t.update()) }(t), t.version > 0 && r.__version !== t.version) { const n = t.image; if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== n.complete) return void C(r, t, e); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture) } function T(e, r) { const s = i.get(e); e.version > 0 && s.__version !== e.version ? function (e, i, r) { if (6 !== i.image.length) return; P(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment); const s = i && (i.isCompressedTexture || i.image[0].isCompressedTexture), c = i.image[0] && i.image[0].isDataTexture, h = []; for (let t = 0; t < 6; t++)h[t] = s || c ? c ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, l); const u = h[0], d = v(u) || a, p = o.convert(i.format), f = o.convert(i.type), m = _(i.internalFormat, p, f); let b; if (R(34067, i, d), s) { for (let t = 0; t < 6; t++) { b = h[t].mipmaps; for (let e = 0; e < b.length; e++) { const r = b[e]; i.format !== Tt && i.format !== Et ? null !== p ? n.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data) } } e.__maxMipLevel = b.length - 1 } else { b = i.mipmaps; for (let t = 0; t < 6; t++)if (c) { n.texImage2D(34069 + t, 0, m, h[t].width, h[t].height, 0, p, f, h[t].data); for (let e = 0; e < b.length; e++) { const i = b[e].image[t].image; n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, p, f, i.data) } } else { n.texImage2D(34069 + t, 0, m, p, f, h[t]); for (let e = 0; e < b.length; e++) { const i = b[e]; n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t]) } } e.__maxMipLevel = b.length } y(i, d) && x(34067, i, u.width, u.height); e.__version = i.version, i.onUpdate && i.onUpdate(i) }(s, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, s.__webglTexture)) } const A = { [it]: 10497, [rt]: 33071, [ot]: 33648 }, L = { [st]: 9728, [at]: 9984, [ct]: 9986, [lt]: 9729, [ht]: 9985, [ut]: 9987 }; function R(n, o, s) { s ? (t.texParameteri(n, 10242, A[o.wrapS]), t.texParameteri(n, 10243, A[o.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, A[o.wrapR]), t.texParameteri(n, 10240, L[o.magFilter]), t.texParameteri(n, 10241, L[o.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), o.wrapS === rt && o.wrapT === rt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, b(o.magFilter)), t.texParameteri(n, 10241, b(o.minFilter)), o.minFilter !== st && o.minFilter !== lt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")); const c = e.get("EXT_texture_filter_anisotropic"); if (c) { if (o.type === yt && null === e.get("OES_texture_float_linear")) return; if (o.type === xt && null === (a || e.get("OES_texture_half_float_linear"))) return; (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy) } } function P(e, n) { void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w), e.__webglTexture = t.createTexture(), s.memory.textures++) } function C(e, i, r) { let s = 3553; i.isDataTexture2DArray && (s = 35866), i.isDataTexture3D && (s = 32879), P(e, i), n.activeTexture(33984 + r), n.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment); const c = function (t) { return !a && (t.wrapS !== rt || t.wrapT !== rt || t.minFilter !== st && t.minFilter !== lt) }(i) && !1 === v(i.image), l = g(i.image, c, !1, h), u = v(l) || a, d = o.convert(i.format); let p, f = o.convert(i.type), m = _(i.internalFormat, d, f); R(s, i, u); const b = i.mipmaps; if (i.isDepthTexture) m = 6402, a ? m = i.type === yt ? 36012 : i.type === vt ? 33190 : i.type === Mt ? 35056 : 33189 : i.type === yt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Rt && 6402 === m && i.type !== mt && i.type !== vt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = mt, f = o.convert(i.type)), i.format === Pt && 6402 === m && (m = 34041, i.type !== Mt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Mt, f = o.convert(i.type))), n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, null); else if (i.isDataTexture) if (b.length > 0 && u) { for (let t = 0, e = b.length; t < e; t++)p = b[t], n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data); i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1 } else n.texImage2D(3553, 0, m, l.width, l.height, 0, d, f, l.data), e.__maxMipLevel = 0; else if (i.isCompressedTexture) { for (let t = 0, e = b.length; t < e; t++)p = b[t], i.format !== Tt && i.format !== Et ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data); e.__maxMipLevel = b.length - 1 } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, l.width, l.height, l.depth, 0, d, f, l.data), e.__maxMipLevel = 0; else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, l.width, l.height, l.depth, 0, d, f, l.data), e.__maxMipLevel = 0; else if (b.length > 0 && u) { for (let t = 0, e = b.length; t < e; t++)p = b[t], n.texImage2D(3553, t, m, d, f, p); i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1 } else n.texImage2D(3553, 0, m, d, f, l), e.__maxMipLevel = 0; y(i, u) && x(s, i, l.width, l.height), e.__version = i.version, i.onUpdate && i.onUpdate(i) } function I(e, r, s, a) { const c = o.convert(r.texture.format), l = o.convert(r.texture.type), h = _(r.texture.internalFormat, c, l); n.texImage2D(a, 0, h, r.width, r.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, s, a, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null) } function O(e, n, i) { if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) { let r = 33189; if (i) { const e = n.depthTexture; e && e.isDepthTexture && (e.type === yt ? r = 36012 : e.type === vt && (r = 33190)); const i = N(n); t.renderbufferStorageMultisample(36161, i, r, n.width, n.height) } else t.renderbufferStorage(36161, r, n.width, n.height); t.framebufferRenderbuffer(36160, 36096, 36161, e) } else if (n.depthBuffer && n.stencilBuffer) { if (i) { const e = N(n); t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height) } else t.renderbufferStorage(36161, 34041, n.width, n.height); t.framebufferRenderbuffer(36160, 33306, 36161, e) } else { const e = o.convert(n.texture.format), r = o.convert(n.texture.type), s = _(n.texture.internalFormat, e, r); if (i) { const e = N(n); t.renderbufferStorageMultisample(36161, e, s, n.width, n.height) } else t.renderbufferStorage(36161, s, n.width, n.height) } t.bindRenderbuffer(36161, null) } function D(e) { const n = i.get(e), r = !0 === e.isWebGLCubeRenderTarget; if (e.depthTexture) { if (r) throw new Error("target.depthTexture not supported in Cube render targets"); !function (e, n) { if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), E(n.depthTexture, 0); const r = i.get(n.depthTexture).__webglTexture; if (n.depthTexture.format === Rt) t.framebufferTexture2D(36160, 36096, 3553, r, 0); else { if (n.depthTexture.format !== Pt) throw new Error("Unknown depthTexture format"); t.framebufferTexture2D(36160, 33306, 3553, r, 0) } }(n.__webglFramebuffer, e) } else if (r) { n.__webglDepthbuffer = []; for (let i = 0; i < 6; i++)t.bindFramebuffer(36160, n.__webglFramebuffer[i]), n.__webglDepthbuffer[i] = t.createRenderbuffer(), O(n.__webglDepthbuffer[i], e, !1) } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), O(n.__webglDepthbuffer, e, !1); t.bindFramebuffer(36160, null) } function N(t) { return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0 } let z = !1, B = !1; this.allocateTextureUnit = function () { const t = S; return t >= c && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + c), S += 1, t }, this.resetTextureUnits = function () { S = 0 }, this.setTexture2D = E, this.setTexture2DArray = function (t, e) { const r = i.get(t); t.version > 0 && r.__version !== t.version ? C(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture)) }, this.setTexture3D = function (t, e) { const r = i.get(t); t.version > 0 && r.__version !== t.version ? C(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture)) }, this.setTextureCube = T, this.setupRenderTarget = function (e) { const r = i.get(e), c = i.get(e.texture); e.addEventListener("dispose", M), c.__webglTexture = t.createTexture(), s.memory.textures++; const l = !0 === e.isWebGLCubeRenderTarget, h = !0 === e.isWebGLMultisampleRenderTarget, u = v(e) || a; if (!a || e.texture.format !== Et || e.texture.type !== yt && e.texture.type !== xt || (e.texture.format = Tt, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), l) { r.__webglFramebuffer = []; for (let e = 0; e < 6; e++)r.__webglFramebuffer[e] = t.createFramebuffer() } else if (r.__webglFramebuffer = t.createFramebuffer(), h) if (a) { r.__webglMultisampledFramebuffer = t.createFramebuffer(), r.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, r.__webglColorRenderbuffer); const n = o.convert(e.texture.format), i = o.convert(e.texture.type), s = _(e.texture.internalFormat, n, i), a = N(e); t.renderbufferStorageMultisample(36161, a, s, e.width, e.height), t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (r.__webglDepthRenderbuffer = t.createRenderbuffer(), O(r.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (l) { n.bindTexture(34067, c.__webglTexture), R(34067, e.texture, u); for (let t = 0; t < 6; t++)I(r.__webglFramebuffer[t], e, 36064, 34069 + t); y(e.texture, u) && x(34067, e.texture, e.width, e.height), n.bindTexture(34067, null) } else n.bindTexture(3553, c.__webglTexture), R(3553, e.texture, u), I(r.__webglFramebuffer, e, 36064, 3553), y(e.texture, u) && x(3553, e.texture, e.width, e.height), n.bindTexture(3553, null); e.depthBuffer && D(e) }, this.updateRenderTargetMipmap = function (t) { const e = t.texture; if (y(e, v(t) || a)) { const r = t.isWebGLCubeRenderTarget ? 34067 : 3553, o = i.get(e).__webglTexture; n.bindTexture(r, o), x(r, e, t.width, t.height), n.bindTexture(r, null) } }, this.updateMultisampleRenderTarget = function (e) { if (e.isWebGLMultisampleRenderTarget) if (a) { const n = i.get(e); t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer); const r = e.width, o = e.height; let s = 16384; e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024), t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (t, e) { t && t.isWebGLRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), z = !0), t = t.texture), E(t, e) }, this.safeSetTextureCube = function (t, e) { t && t.isWebGLCubeRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), T(t, e) } } function js(t, e, n) { const i = n.isWebGL2; return { convert: function (t) { let n; if (t === dt) return 5121; if (t === _t) return 32819; if (t === bt) return 32820; if (t === wt) return 33635; if (t === pt) return 5120; if (t === ft) return 5122; if (t === mt) return 5123; if (t === gt) return 5124; if (t === vt) return 5125; if (t === yt) return 5126; if (t === xt) return i ? 5131 : null !== (n = e.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null; if (t === St) return 6406; if (t === Et) return 6407; if (t === Tt) return 6408; if (t === At) return 6409; if (t === Lt) return 6410; if (t === Rt) return 6402; if (t === Pt) return 34041; if (t === Ct) return 6403; if (t === It) return 36244; if (t === Ot) return 33319; if (t === Dt) return 33320; if (t === Nt) return 36248; if (t === zt) return 36249; if (t === Bt || t === Ht || t === Ut || t === Ft) { if (null === (n = e.get("WEBGL_compressed_texture_s3tc"))) return null; if (t === Bt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (t === Ht) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (t === Ut) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (t === Ft) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (t === Gt || t === kt || t === Vt || t === Wt) { if (null === (n = e.get("WEBGL_compressed_texture_pvrtc"))) return null; if (t === Gt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (t === kt) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (t === Vt) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (t === Wt) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (t === jt) return null !== (n = e.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null; if ((t === qt || t === Xt) && null !== (n = e.get("WEBGL_compressed_texture_etc"))) { if (t === qt) return n.COMPRESSED_RGB8_ETC2; if (t === Xt) return n.COMPRESSED_RGBA8_ETC2_EAC } return t === Yt || t === Zt || t === Jt || t === Qt || t === Kt || t === $t || t === te || t === ee || t === ne || t === ie || t === re || t === oe || t === se || t === ae || t === le || t === he || t === ue || t === de || t === pe || t === fe || t === me || t === ge || t === ve || t === ye || t === xe || t === _e || t === be || t === we ? null !== (n = e.get("WEBGL_compressed_texture_astc")) ? t : null : t === ce ? null !== (n = e.get("EXT_texture_compression_bptc")) ? t : null : t === Mt ? i ? 34042 : null !== (n = e.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } } function qs(t = []) { Ir.call(this), this.cameras = t } function Xs() { ci.call(this), this.type = "Group" } function Ys() { this._targetRay = null, this._grip = null, this._hand = null } function Zs(t, e) { const n = this; let i = null, r = 1, o = null, s = "local-floor", a = null; const c = [], l = new Map, h = new Ir; h.layers.enable(1), h.viewport = new sn; const u = new Ir; u.layers.enable(2), u.viewport = new sn; const d = [h, u], p = new qs; p.layers.enable(1), p.layers.enable(2); let f = null, m = null; function g(t) { const e = l.get(t.inputSource); e && e.dispatchEvent({ type: t.type, data: t.inputSource }) } function v() { l.forEach(function (t, e) { t.disconnect(e) }), l.clear(), f = null, m = null, t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), M.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } function y(t) { const e = i.inputSources; for (let t = 0; t < c.length; t++)l.set(e[t], c[t]); for (let e = 0; e < t.removed.length; e++) { const n = t.removed[e], i = l.get(n); i && (i.dispatchEvent({ type: "disconnected", data: n }), l.delete(n)) } for (let e = 0; e < t.added.length; e++) { const n = t.added[e], i = l.get(n); i && i.dispatchEvent({ type: "connected", data: n }) } } this.enabled = !1, this.isPresenting = !1, this.getController = function (t) { let e = c[t]; return void 0 === e && (e = new Ys, c[t] = e), e.getTargetRaySpace() }, this.getControllerGrip = function (t) { let e = c[t]; return void 0 === e && (e = new Ys, c[t] = e), e.getGripSpace() }, this.getHand = function (t) { let e = c[t]; return void 0 === e && (e = new Ys, c[t] = e), e.getHandSpace() }, this.setFramebufferScaleFactor = function (t) { r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (t) { s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return o }, this.getSession = function () { return i }, this.setSession = async function (t) { if (null !== (i = t)) { i.addEventListener("select", g), i.addEventListener("selectstart", g), i.addEventListener("selectend", g), i.addEventListener("squeeze", g), i.addEventListener("squeezestart", g), i.addEventListener("squeezeend", g), i.addEventListener("end", v), i.addEventListener("inputsourceschange", y); const t = e.getContextAttributes(); !0 !== t.xrCompatible && await e.makeXRCompatible(); const a = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: r }, c = new XRWebGLLayer(i, e, a); i.updateRenderState({ baseLayer: c }), o = await i.requestReferenceSpace(s), M.setContext(i), M.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }; const x = new ln, _ = new ln; function b(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert() } this.getCamera = function (t) { p.near = u.near = h.near = t.near, p.far = u.far = h.far = t.far, f === p.near && m === p.far || (i.updateRenderState({ depthNear: p.near, depthFar: p.far }), f = p.near, m = p.far); const e = t.parent, n = p.cameras; b(p, e); for (let t = 0; t < n.length; t++)b(n[t], e); t.matrixWorld.copy(p.matrixWorld), t.matrix.copy(p.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale); const r = t.children; for (let t = 0, e = r.length; t < e; t++)r[t].updateMatrixWorld(!0); return 2 === n.length ? function (t, e, n) { x.setFromMatrixPosition(e.matrixWorld), _.setFromMatrixPosition(n.matrixWorld); const i = x.distanceTo(_), r = e.projectionMatrix.elements, o = n.projectionMatrix.elements, s = r[14] / (r[10] - 1), a = r[14] / (r[10] + 1), c = (r[9] + 1) / r[5], l = (r[9] - 1) / r[5], h = (r[8] - 1) / r[0], u = (o[8] + 1) / o[0], d = s * h, p = s * u, f = i / (-h + u), m = f * -h; e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert(); const g = s + f, v = a + f, y = d - m, b = p + (i - m), w = c * a / v * g, M = l * a / v * g; t.projectionMatrix.makePerspective(y, b, w, M, g, v) }(p, h, u) : p.projectionMatrix.copy(h.projectionMatrix), p }; let w = null; const M = new kr; M.setAnimationLoop(function (e, n) { if (null !== (a = n.getViewerPose(o))) { const e = a.views, n = i.renderState.baseLayer; t.setFramebuffer(n.framebuffer); let r = !1; e.length !== p.cameras.length && (p.cameras.length = 0, r = !0); for (let t = 0; t < e.length; t++) { const i = e[t], o = n.getViewport(i), s = d[t]; s.matrix.fromArray(i.transform.matrix), s.projectionMatrix.fromArray(i.projectionMatrix), s.viewport.set(o.x, o.y, o.width, o.height), 0 === t && p.matrix.copy(s.matrix), !0 === r && p.cameras.push(s) } } const r = i.inputSources; for (let t = 0; t < c.length; t++) { const e = c[t], i = r[t]; e.update(i, n, o) } w && w(e, n) }), this.setAnimationLoop = function (t) { w = t }, this.dispose = function () { } } function Js(t) { function e(e, n) { e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap); const i = t.get(n).envMap; if (i) { e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio; const r = t.get(i).__maxMipLevel; void 0 !== r && (e.maxMipLevel.value = r) } let r, o; n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? o = n.aoMap : n.lightMap && (o = n.lightMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uv2Transform.value.copy(o.matrix)) } function n(e, n) { e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === h && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === h && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity) } return { refreshFogUniforms: function (t, e) { t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density) }, refreshMaterialUniforms: function (t, i, r, o) { i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function (t, e) { e.emissiveMap && (t.emissiveMap.value = e.emissiveMap) }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function (t, e) { e.gradientMap && (t.gradientMap.value = e.gradientMap); e.emissiveMap && (t.emissiveMap.value = e.emissiveMap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function (t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function (t, e) { n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen); e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap); e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap); e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === h && t.clearcoatNormalScale.value.negate()); t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap) }(t, i) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function (t, e) { e.matcap && (t.matcap.value = e.matcap); e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function (t, e) { e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias); t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function (t, e) { e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === h && (t.bumpScale.value *= -1)); e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === h && t.normalScale.value.negate()); e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) }(t, i)) : i.isLineBasicMaterial ? (function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity }(t, i), i.isLineDashedMaterial && function (t, e) { t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale }(t, i)) : i.isPointsMaterial ? function (t, e, n, i) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map); e.alphaMap && (t.alphaMap.value = e.alphaMap); let r; e.map ? r = e.map : e.alphaMap && (r = e.alphaMap); void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)) }(t, i, r, o) : i.isSpriteMaterial ? function (t, e) { t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map); e.alphaMap && (t.alphaMap.value = e.alphaMap); let n; e.map ? n = e.map : e.alphaMap && (n = e.alphaMap); void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix)) }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1) } } } function Qs(t) { const e = void 0 !== (t = t || {}).canvas ? t.canvas : function () { const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return t.style.display = "block", t }(), n = void 0 !== t.context ? t.context : null, i = void 0 !== t.alpha && t.alpha, r = void 0 === t.depth || t.depth, o = void 0 === t.stencil || t.stencil, s = void 0 !== t.antialias && t.antialias, a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, l = void 0 !== t.powerPreference ? t.powerPreference : "default", h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat; let u = null, d = null; const p = []; this.domElement = e, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Ce, this.physicallyCorrectLights = !1, this.toneMapping = j, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; const f = this; let m = !1, g = null, v = 0, y = 0, x = null, _ = null, b = -1, w = null; const M = new sn, S = new sn; let E = null, T = e.width, A = e.height, L = 1, R = null, P = null; const C = new sn(0, 0, T, A), I = new sn(0, 0, T, A); let O = !1; const D = new Gr; let N = !1, z = !1; const B = new Bn, H = new ln, U = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function F() { return null === x ? L : 1 } let G, k, V, W, q, X, Y, Z, J, Q, K, $, tt, et, nt, it, rt, ot, st, at, ct, lt = n; function ht(t, n) { for (let i = 0; i < t.length; i++) { const r = t[i], o = e.getContext(r, n); if (null !== o) return o } return null } try { const t = { alpha: i, depth: r, stencil: o, antialias: s, premultipliedAlpha: a, preserveDrawingBuffer: c, powerPreference: l, failIfMajorPerformanceCaveat: h }; if (e.addEventListener("webglcontextlost", mt, !1), e.addEventListener("webglcontextrestored", gt, !1), null === lt) { const e = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === f.isWebGL1Renderer && e.shift(), null === (lt = ht(e, t))) throw ht(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === lt.getShaderPrecisionFormat && (lt.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t } function ut() { G = new to(lt), k = new Qr(lt, G, t), G.init(k), at = new js(lt, G, k), (V = new Vs(lt, G, k)).scissor(S.copy(I).multiplyScalar(L).floor()), V.viewport(M.copy(C).multiplyScalar(L).floor()), W = new io(lt), q = new As, X = new Ws(lt, G, V, q, k, at, W), Y = new $r(f), Z = new Vr(lt, k), ct = new Zr(lt, G, Z, k), J = new eo(lt, Z, W, ct), Q = new ao(lt, J, Z, W), rt = new so(lt), nt = new Kr(q), K = new Ts(f, Y, G, k, ct, nt), $ = new Js(q), tt = new Cs(q), et = new Bs(G, k), it = new Yr(f, Y, V, Q, a), ot = new Jr(lt, G, W, k), st = new no(lt, G, W, k), W.programs = K.programs, f.capabilities = k, f.extensions = G, f.properties = q, f.renderLists = tt, f.state = V, f.info = W } ut(); const pt = new Zs(f, lt); this.xr = pt; const ft = new ks(f, Q, k.maxTextureSize); function mt(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), m = !0 } function gt() { console.log("THREE.WebGLRenderer: Context Restored."), m = !1, ut() } function vt(t) { const e = t.target; e.removeEventListener("dispose", vt), function (t) { _t(t), q.remove(t) }(e) } function _t(t) { const e = q.get(t).program; void 0 !== e && K.releaseProgram(e) } this.shadowMap = ft, this.getContext = function () { return lt }, this.getContextAttributes = function () { return lt.getContextAttributes() }, this.forceContextLoss = function () { const t = G.get("WEBGL_lose_context"); t && t.loseContext() }, this.forceContextRestore = function () { const t = G.get("WEBGL_lose_context"); t && t.restoreContext() }, this.getPixelRatio = function () { return L }, this.setPixelRatio = function (t) { void 0 !== t && (L = t, this.setSize(T, A, !1)) }, this.getSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new Ke), t.set(T, A) }, this.setSize = function (t, n, i) { pt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t, A = n, e.width = Math.floor(t * L), e.height = Math.floor(n * L), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n)) }, this.getDrawingBufferSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new Ke), t.set(T * L, A * L).floor() }, this.setDrawingBufferSize = function (t, n, i) { T = t, A = n, L = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n) }, this.getCurrentViewport = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new sn), t.copy(M) }, this.getViewport = function (t) { return t.copy(C) }, this.setViewport = function (t, e, n, i) { t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, i), V.viewport(M.copy(C).multiplyScalar(L).floor()) }, this.getScissor = function (t) { return t.copy(I) }, this.setScissor = function (t, e, n, i) { t.isVector4 ? I.set(t.x, t.y, t.z, t.w) : I.set(t, e, n, i), V.scissor(S.copy(I).multiplyScalar(L).floor()) }, this.getScissorTest = function () { return O }, this.setScissorTest = function (t) { V.setScissorTest(O = t) }, this.setOpaqueSort = function (t) { R = t }, this.setTransparentSort = function (t) { P = t }, this.getClearColor = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), t = new Pi), t.copy(it.getClearColor()) }, this.setClearColor = function () { it.setClearColor.apply(it, arguments) }, this.getClearAlpha = function () { return it.getClearAlpha() }, this.setClearAlpha = function () { it.setClearAlpha.apply(it, arguments) }, this.clear = function (t, e, n) { let i = 0; (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), lt.clear(i) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { e.removeEventListener("webglcontextlost", mt, !1), e.removeEventListener("webglcontextrestored", gt, !1), tt.dispose(), et.dispose(), q.dispose(), Y.dispose(), Q.dispose(), ct.dispose(), pt.dispose(), wt.stop() }, this.renderBufferImmediate = function (t, e) { ct.initAttributes(); const n = q.get(t); t.hasPositions && !n.position && (n.position = lt.createBuffer()), t.hasNormals && !n.normal && (n.normal = lt.createBuffer()), t.hasUvs && !n.uv && (n.uv = lt.createBuffer()), t.hasColors && !n.color && (n.color = lt.createBuffer()); const i = e.getAttributes(); t.hasPositions && (lt.bindBuffer(34962, n.position), lt.bufferData(34962, t.positionArray, 35048), ct.enableAttribute(i.position), lt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (lt.bindBuffer(34962, n.normal), lt.bufferData(34962, t.normalArray, 35048), ct.enableAttribute(i.normal), lt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (lt.bindBuffer(34962, n.uv), lt.bufferData(34962, t.uvArray, 35048), ct.enableAttribute(i.uv), lt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (lt.bindBuffer(34962, n.color), lt.bufferData(34962, t.colorArray, 35048), ct.enableAttribute(i.color), lt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), ct.disableUnusedAttributes(), lt.drawArrays(4, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, e, n, i, r, o) { null === e && (e = U); const s = r.isMesh && r.matrixWorld.determinant() < 0, a = Lt(t, e, i, r); V.setMaterial(i, s); let c = n.index; const l = n.attributes.position; if (null === c) { if (void 0 === l || 0 === l.count) return } else if (0 === c.count) return; let h, u = 1; !0 === i.wireframe && (c = J.getWireframeAttribute(n), u = 2), (i.morphTargets || i.morphNormals) && rt.update(r, n, i, a), ct.setup(r, i, a, n, c); let d = ot; null !== c && (h = Z.get(c), (d = st).setIndex(h)); const p = null !== c ? c.count : l.count, f = n.drawRange.start * u, m = n.drawRange.count * u, g = null !== o ? o.start * u : 0, v = null !== o ? o.count * u : 1 / 0, y = Math.max(f, g), x = Math.min(p, f + m, g + v) - 1, _ = Math.max(0, x - y + 1); if (0 !== _) { if (r.isMesh) !0 === i.wireframe ? (V.setLineWidth(i.wireframeLinewidth * F()), d.setMode(1)) : d.setMode(4); else if (r.isLine) { let t = i.linewidth; void 0 === t && (t = 1), V.setLineWidth(t * F()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3) } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4); if (r.isInstancedMesh) d.renderInstances(y, _, r.count); else if (n.isInstancedBufferGeometry) { const t = Math.min(n.instanceCount, n._maxInstanceCount); d.renderInstances(y, _, t) } else d.render(y, _) } }, this.compile = function (t, e) { (d = et.get(t)).init(), t.traverseVisible(function (t) { t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t)) }), d.setupLights(); const n = new WeakMap; t.traverse(function (e) { const i = e.material; if (i) if (Array.isArray(i)) for (let r = 0; r < i.length; r++) { const o = i[r]; !1 === n.has(o) && (At(o, t, e), n.set(o)) } else !1 === n.has(i) && (At(i, t, e), n.set(i)) }) }; let bt = null; const wt = new kr; function Mt(t, e, n, i) { if (!1 === t.visible) return; if (t.layers.test(e.layers)) if (t.isGroup) n = t.renderOrder; else if (t.isLOD) !0 === t.autoUpdate && t.update(e); else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || D.intersectsSprite(t)) { i && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B); const e = Q.update(t), r = t.material; r.visible && u.push(t, e, r, n, H.z, null) } } else if (t.isImmediateRenderObject) i && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B), u.push(t, null, t.material, n, H.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== W.render.frame && (t.skeleton.update(), t.skeleton.frame = W.render.frame), !t.frustumCulled || D.intersectsObject(t))) { i && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(B); const e = Q.update(t), r = t.material; if (Array.isArray(r)) { const i = e.groups; for (let o = 0, s = i.length; o < s; o++) { const s = i[o], a = r[s.materialIndex]; a && a.visible && u.push(t, e, a, n, H.z, s) } } else r.visible && u.push(t, e, r, n, H.z, null) } const r = t.children; for (let t = 0, o = r.length; t < o; t++)Mt(r[t], e, n, i) } function St(t, e, n) { const i = !0 === e.isScene ? e.overrideMaterial : null; for (let r = 0, o = t.length; r < o; r++) { const o = t[r], s = o.object, a = o.geometry, c = null === i ? o.material : i, l = o.group; if (n.isArrayCamera) { const t = n.cameras; for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; s.layers.test(i.layers) && (V.viewport(M.copy(i.viewport)), d.setupLightsView(i), Et(s, e, i, a, c, l)) } } else Et(s, e, n, a, c, l) } } function Et(t, e, n, i, r, o) { if (t.onBeforeRender(f, e, n, i, r, o), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) { const i = Lt(n, e, r, t); V.setMaterial(r), ct.reset(), function (t, e) { t.render(function (t) { f.renderBufferImmediate(t, e) }) }(t, i) } else f.renderBufferDirect(n, e, i, r, t, o); t.onAfterRender(f, e, n, i, r, o) } function At(t, e, n) { !0 !== e.isScene && (e = U); const i = q.get(t), r = d.state.lights, o = d.state.shadowsArray, s = r.state.version, a = K.getParameters(t, r.state, o, e, n), c = K.getProgramCacheKey(a); let l = i.program, h = !0; if (i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = Y.get(t.envMap || i.environment), void 0 === l) t.addEventListener("dispose", vt); else if (l.cacheKey !== c) _t(t); else if (i.lightsStateVersion !== s) h = !1; else { if (void 0 !== a.shaderID) return; h = !1 } h && (a.uniforms = K.getUniforms(t), t.onBeforeCompile(a, f), l = K.acquireProgram(a, c), i.program = l, i.uniforms = a.uniforms, i.outputEncoding = a.outputEncoding); const u = i.uniforms; (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = nt.numPlanes, i.numIntersection = nt.numIntersection, u.clippingPlanes = nt.uniform), i.needsLights = function (t) { return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights }(t), i.lightsStateVersion = s, i.needsLights && (u.ambientLightColor.value = r.state.ambient, u.lightProbe.value = r.state.probe, u.directionalLights.value = r.state.directional, u.directionalLightShadows.value = r.state.directionalShadow, u.spotLights.value = r.state.spot, u.spotLightShadows.value = r.state.spotShadow, u.rectAreaLights.value = r.state.rectArea, u.ltc_1.value = r.state.rectAreaLTC1, u.ltc_2.value = r.state.rectAreaLTC2, u.pointLights.value = r.state.point, u.pointLightShadows.value = r.state.pointShadow, u.hemisphereLights.value = r.state.hemi, u.directionalShadowMap.value = r.state.directionalShadowMap, u.directionalShadowMatrix.value = r.state.directionalShadowMatrix, u.spotShadowMap.value = r.state.spotShadowMap, u.spotShadowMatrix.value = r.state.spotShadowMatrix, u.pointShadowMap.value = r.state.pointShadowMap, u.pointShadowMatrix.value = r.state.pointShadowMatrix); const p = i.program.getUniforms(), m = os.seqWithValue(p.seq, u); i.uniformsList = m } function Lt(t, e, n, i) { !0 !== e.isScene && (e = U), X.resetTextureUnits(); const r = e.fog, o = n.isMeshStandardMaterial ? e.environment : null, s = null === x ? f.outputEncoding : x.texture.encoding, a = Y.get(n.envMap || o), c = q.get(n), l = d.state.lights; if (!0 === N && (!0 === z || t !== w)) { const e = t === w && n.id === b; nt.setState(n, t, e) } n.version === c.__version ? n.fog && c.fog !== r ? At(n, e, i) : c.environment !== o ? At(n, e, i) : c.needsLights && c.lightsStateVersion !== l.state.version ? At(n, e, i) : void 0 === c.numClippingPlanes || c.numClippingPlanes === nt.numPlanes && c.numIntersection === nt.numIntersection ? c.outputEncoding !== s ? At(n, e, i) : c.envMap !== a && At(n, e, i) : At(n, e, i) : (At(n, e, i), c.__version = n.version); let h = !1, u = !1, p = !1; const m = c.program, g = m.getUniforms(), v = c.uniforms; if (V.useProgram(m.program) && (h = !0, u = !0, p = !0), n.id !== b && (b = n.id, u = !0), h || w !== t) { if (g.setValue(lt, "projectionMatrix", t.projectionMatrix), k.logarithmicDepthBuffer && g.setValue(lt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), w !== t && (w = t, u = !0, p = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) { const e = g.map.cameraPosition; void 0 !== e && e.setValue(lt, H.setFromMatrixPosition(t.matrixWorld)) } (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && g.setValue(lt, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && g.setValue(lt, "viewMatrix", t.matrixWorldInverse) } if (n.skinning) { g.setOptional(lt, i, "bindMatrix"), g.setOptional(lt, i, "bindMatrixInverse"); const t = i.skeleton; if (t) { const e = t.bones; if (k.floatVertexTextures) { if (null === t.boneTexture) { let n = Math.sqrt(4 * e.length); n = Qe.ceilPowerOfTwo(n), n = Math.max(n, 4); const i = new Float32Array(n * n * 4); i.set(t.boneMatrices); const r = new Hr(i, n, n, Tt, yt); t.boneMatrices = i, t.boneTexture = r, t.boneTextureSize = n } g.setValue(lt, "boneTexture", t.boneTexture, X), g.setValue(lt, "boneTextureSize", t.boneTextureSize) } else g.setOptional(lt, t, "boneMatrices") } } var y, _; return (u || c.receiveShadow !== i.receiveShadow) && (c.receiveShadow = i.receiveShadow, g.setValue(lt, "receiveShadow", i.receiveShadow)), u && (g.setValue(lt, "toneMappingExposure", f.toneMappingExposure), c.needsLights && (_ = p, (y = v).ambientLightColor.needsUpdate = _, y.lightProbe.needsUpdate = _, y.directionalLights.needsUpdate = _, y.directionalLightShadows.needsUpdate = _, y.pointLights.needsUpdate = _, y.pointLightShadows.needsUpdate = _, y.spotLights.needsUpdate = _, y.spotLightShadows.needsUpdate = _, y.rectAreaLights.needsUpdate = _, y.hemisphereLights.needsUpdate = _), r && n.fog && $.refreshFogUniforms(v, r), $.refreshMaterialUniforms(v, n, L, A), os.upload(lt, c.uniformsList, v, X)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (os.upload(lt, c.uniformsList, v, X), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && g.setValue(lt, "center", i.center), g.setValue(lt, "modelViewMatrix", i.modelViewMatrix), g.setValue(lt, "normalMatrix", i.normalMatrix), g.setValue(lt, "modelMatrix", i.matrixWorld), m } wt.setAnimationLoop(function (t) { pt.isPresenting || bt && bt(t) }), "undefined" != typeof window && wt.setContext(window), this.setAnimationLoop = function (t) { bt = t, pt.setAnimationLoop(t), null === t ? wt.stop() : wt.start() }, this.render = function (t, e) { let n, i; if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); if (!0 === m) return; ct.resetDefaultState(), b = -1, w = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === pt.enabled && !0 === pt.isPresenting && (e = pt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(f, t, e, n || x), (d = et.get(t, p.length)).init(), p.push(d), B.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), D.setFromProjectionMatrix(B), z = this.localClippingEnabled, N = nt.init(this.clippingPlanes, z, e), (u = tt.get(t, e)).init(), Mt(t, e, 0, f.sortObjects), u.finish(), !0 === f.sortObjects && u.sort(R, P), !0 === N && nt.beginShadows(); const r = d.state.shadowsArray; ft.render(r, t, e), d.setupLights(), d.setupLightsView(e), !0 === N && nt.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), it.render(u, t, e, i); const o = u.opaque, s = u.transparent; o.length > 0 && St(o, t, e), s.length > 0 && St(s, t, e), !0 === t.isScene && t.onAfterRender(f, t, e), null !== x && (X.updateRenderTargetMipmap(x), X.updateMultisampleRenderTarget(x)), V.buffers.depth.setTest(!0), V.buffers.depth.setMask(!0), V.buffers.color.setMask(!0), V.setPolygonOffset(!1), p.pop(), d = p.length > 0 ? p[p.length - 1] : null, u = null }, this.setFramebuffer = function (t) { g !== t && null === x && lt.bindFramebuffer(36160, t), g = t }, this.getActiveCubeFace = function () { return v }, this.getActiveMipmapLevel = function () { return y }, this.getRenderList = function () { return u }, this.setRenderList = function (t) { u = t }, this.getRenderTarget = function () { return x }, this.setRenderTarget = function (t, e = 0, n = 0) { x = t, v = e, y = n, t && void 0 === q.get(t).__webglFramebuffer && X.setupRenderTarget(t); let i = g, r = !1; if (t) { const n = q.get(t).__webglFramebuffer; t.isWebGLCubeRenderTarget ? (i = n[e], r = !0) : i = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : n, M.copy(t.viewport), S.copy(t.scissor), E = t.scissorTest } else M.copy(C).multiplyScalar(L).floor(), S.copy(I).multiplyScalar(L).floor(), E = O; if (_ !== i && (lt.bindFramebuffer(36160, i), _ = i), V.viewport(M), V.scissor(S), V.setScissorTest(E), r) { const i = q.get(t.texture); lt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n) } }, this.readRenderTargetPixels = function (t, e, n, i, r, o, s) { if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); let a = q.get(t).__webglFramebuffer; if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) { let s = !1; a !== _ && (lt.bindFramebuffer(36160, a), s = !0); try { const a = t.texture, c = a.format, l = a.type; if (c !== Tt && at.convert(c) !== lt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); const h = l === xt && (G.has("EXT_color_buffer_half_float") || k.isWebGL2 && G.has("EXT_color_buffer_float")); if (!(l === dt || at.convert(l) === lt.getParameter(35738) || l === yt && (k.isWebGL2 || G.has("OES_texture_float") || G.has("WEBGL_color_buffer_float")) || h)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === lt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && lt.readPixels(e, n, i, r, at.convert(c), at.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { s && lt.bindFramebuffer(36160, _) } } }, this.copyFramebufferToTexture = function (t, e, n = 0) { const i = Math.pow(2, -n), r = Math.floor(e.image.width * i), o = Math.floor(e.image.height * i), s = at.convert(e.format); X.setTexture2D(e, 0), lt.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0), V.unbindTexture() }, this.copyTextureToTexture = function (t, e, n, i = 0) { const r = e.image.width, o = e.image.height, s = at.convert(n.format), a = at.convert(n.type); X.setTexture2D(n, 0), lt.pixelStorei(37440, n.flipY), lt.pixelStorei(37441, n.premultiplyAlpha), lt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? lt.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? lt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : lt.texSubImage2D(3553, i, t.x, t.y, s, a, e.image), 0 === i && n.generateMipmaps && lt.generateMipmap(3553), V.unbindTexture() }, this.initTexture = function (t) { X.setTexture2D(t, 0), V.unbindTexture() }, this.resetState = function () { V.reset(), ct.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } function Ks(t) { Qs.call(this, t) } qs.prototype = Object.assign(Object.create(Ir.prototype), { constructor: qs, isArrayCamera: !0 }), Xs.prototype = Object.assign(Object.create(ci.prototype), { constructor: Xs, isGroup: !0 }), Object.assign(Ys.prototype, { constructor: Ys, getHandSpace: function () { return null === this._hand && (this._hand = new Xs, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand }, getTargetRaySpace: function () { return null === this._targetRay && (this._targetRay = new Xs, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay }, getGripSpace: function () { return null === this._grip && (this._grip = new Xs, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip }, dispatchEvent: function (t) { return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this }, disconnect: function (t) { return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this }, update: function (t, e, n) { let i = null, r = null, o = null; const s = this._targetRay, a = this._grip, c = this._hand; if (t && "visible-blurred" !== e.session.visibilityState) if (c && t.hand) { o = !0; for (const i of t.hand.values()) { const t = e.getJointPose(i, n); if (void 0 === c.joints[i.jointName]) { const t = new Xs; t.matrixAutoUpdate = !1, t.visible = !1, c.joints[i.jointName] = t, c.add(t) } const r = c.joints[i.jointName]; null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t } const i = c.joints["index-finger-tip"], r = c.joints["thumb-tip"], s = i.position.distanceTo(r.position), a = .02, l = .005; c.inputState.pinching && s > a + l ? (c.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !c.inputState.pinching && s <= a - l && (c.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this })) } else null !== s && null !== (i = e.getPose(t.targetRaySpace, n)) && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale)), null !== a && t.gripSpace && null !== (r = e.getPose(t.gripSpace, n)) && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)); return null !== s && (s.visible = null !== i), null !== a && (a.visible = null !== r), null !== c && (c.visible = null !== o), this } }), Object.assign(Zs.prototype, Ye.prototype), Ks.prototype = Object.assign(Object.create(Qs.prototype), { constructor: Ks, isWebGL1Renderer: !0 }); class $s { constructor(t, e, n) { Object.defineProperty(this, "isFog", { value: !0 }), this.name = "", this.color = new Pi(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3 } clone() { return new $s(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } class ta extends ci { constructor() { super(), Object.defineProperty(this, "isScene", { value: !0 }), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(t, e) { return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this } toJSON(t) { const e = super.toJSON(t); return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e } } function ea(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = je, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Qe.generateUUID() } Object.defineProperty(ea.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(ea.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setUsage: function (t) { return this.usage = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this }, copyAt: function (t, e, n) { t *= this.stride, n *= e.stride; for (let i = 0, r = this.stride; i < r; i++)this.array[t + i] = e.array[n + i]; return this }, set: function (t, e = 0) { return this.array.set(t, e), this }, clone: function (t) { void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Qe.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const e = new ea(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride); return e.setUsage(this.usage), e }, onUpload: function (t) { return this.onUploadCallback = t, this }, toJSON: function (t) { return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Qe.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } }); const na = new ln; function ia(t, e, n, i) { this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i } function ra(t) { Oi.call(this), this.type = "SpriteMaterial", this.color = new Pi(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t) } let oa; Object.defineProperties(ia.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } }, needsUpdate: { set: function (t) { this.data.needsUpdate = t } } }), Object.assign(ia.prototype, { isInterleavedBufferAttribute: !0, applyMatrix4: function (t) { for (let e = 0, n = this.data.count; e < n; e++)na.x = this.getX(e), na.y = this.getY(e), na.z = this.getZ(e), na.applyMatrix4(t), this.setXYZ(e, na.x, na.y, na.z); return this }, setX: function (t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }, setY: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }, setZ: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }, setW: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }, getX: function (t) { return this.data.array[t * this.data.stride + this.offset] }, getY: function (t) { return this.data.array[t * this.data.stride + this.offset + 1] }, getZ: function (t) { return this.data.array[t * this.data.stride + this.offset + 2] }, getW: function (t) { return this.data.array[t * this.data.stride + this.offset + 3] }, setXY: function (t, e, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this }, setXYZ: function (t, e, n, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this }, setXYZW: function (t, e, n, i, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this }, clone: function (t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return new Bi(new this.array.constructor(t), this.itemSize, this.normalized) } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ia(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) }, toJSON: function (t) { if (void 0 === t) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { const n = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[n + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } }), ra.prototype = Object.create(Oi.prototype), ra.prototype.constructor = ra, ra.prototype.isSpriteMaterial = !0, ra.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this }; const sa = new ln, aa = new ln, ca = new ln, la = new Ke, ha = new Ke, ua = new Bn, da = new ln, pa = new ln, fa = new ln, ma = new Ke, ga = new Ke, va = new Ke; function ya(t) { if (ci.call(this), this.type = "Sprite", void 0 === oa) { oa = new rr; const t = new ea(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5); oa.setIndex([0, 1, 2, 0, 2, 3]), oa.setAttribute("position", new ia(t, 3, 0, !1)), oa.setAttribute("uv", new ia(t, 2, 3, !1)) } this.geometry = oa, this.material = void 0 !== t ? t : new ra, this.center = new Ke(.5, .5) } function xa(t, e, n, i, r, o) { la.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (ha.x = o * la.x - r * la.y, ha.y = r * la.x + o * la.y) : ha.copy(la), t.copy(e), t.x += ha.x, t.y += ha.y, t.applyMatrix4(ua) } ya.prototype = Object.assign(Object.create(ci.prototype), { constructor: ya, isSprite: !0, raycast: function (t, e) { null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), aa.setFromMatrixScale(this.matrixWorld), ua.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ca.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && aa.multiplyScalar(-ca.z); const n = this.material.rotation; let i, r; 0 !== n && (r = Math.cos(n), i = Math.sin(n)); const o = this.center; xa(da.set(-.5, -.5, 0), ca, o, aa, i, r), xa(pa.set(.5, -.5, 0), ca, o, aa, i, r), xa(fa.set(.5, .5, 0), ca, o, aa, i, r), ma.set(0, 0), ga.set(1, 0), va.set(1, 1); let s = t.ray.intersectTriangle(da, pa, fa, !1, sa); if (null === s && (xa(pa.set(-.5, .5, 0), ca, o, aa, i, r), ga.set(0, 1), null === (s = t.ray.intersectTriangle(da, fa, pa, !1, sa)))) return; const a = t.ray.origin.distanceTo(sa); a < t.near || a > t.far || e.push({ distance: a, point: sa.clone(), uv: Mi.getUV(sa, da, pa, fa, ma, ga, va, new Ke), face: null, object: this }) }, copy: function (t) { return ci.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this } }); const _a = new ln, ba = new ln; function wa() { ci.call(this), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }), this.autoUpdate = !0 } wa.prototype = Object.assign(Object.create(ci.prototype), { constructor: wa, isLOD: !0, copy: function (t) { ci.prototype.copy.call(this, t, !1); const e = t.levels; for (let t = 0, n = e.length; t < n; t++) { const n = e[t]; this.addLevel(n.object.clone(), n.distance) } return this.autoUpdate = t.autoUpdate, this }, addLevel: function (t, e = 0) { e = Math.abs(e); const n = this.levels; let i; for (i = 0; i < n.length && !(e < n[i].distance); i++); return n.splice(i, 0, { distance: e, object: t }), this.add(t), this }, getCurrentLevel: function () { return this._currentLevel }, getObjectForDistance: function (t) { const e = this.levels; if (e.length > 0) { let n, i; for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++); return e[n - 1].object } return null }, raycast: function (t, e) { if (this.levels.length > 0) { _a.setFromMatrixPosition(this.matrixWorld); const n = t.ray.origin.distanceTo(_a); this.getObjectForDistance(n).raycast(t, e) } }, update: function (t) { const e = this.levels; if (e.length > 1) { _a.setFromMatrixPosition(t.matrixWorld), ba.setFromMatrixPosition(this.matrixWorld); const n = _a.distanceTo(ba) / t.zoom; let i, r; for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++)e[i - 1].object.visible = !1, e[i].object.visible = !0; for (this._currentLevel = i - 1; i < r; i++)e[i].object.visible = !1 } }, toJSON: function (t) { const e = ci.prototype.toJSON.call(this, t); !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = []; const n = this.levels; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; e.object.levels.push({ object: i.object.uuid, distance: i.distance }) } return e } }); const Ma = new ln, Sa = new sn, Ea = new sn, Ta = new ln, Aa = new Bn; function La(t, e) { t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), wr.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Bn, this.bindMatrixInverse = new Bn } function Ra() { ci.call(this), this.type = "Bone" } La.prototype = Object.assign(Object.create(wr.prototype), { constructor: La, isSkinnedMesh: !0, copy: function (t) { return wr.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this }, bind: function (t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert() }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { const t = new sn, e = this.geometry.attributes.skinWeight; for (let n = 0, i = e.count; n < i; n++) { t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n); const i = 1 / t.manhattanLength(); i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w) } }, updateMatrixWorld: function (t) { wr.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, boneTransform: function (t, e) { const n = this.skeleton, i = this.geometry; Sa.fromBufferAttribute(i.attributes.skinIndex, t), Ea.fromBufferAttribute(i.attributes.skinWeight, t), Ma.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0); for (let t = 0; t < 4; t++) { const i = Ea.getComponent(t); if (0 !== i) { const r = Sa.getComponent(t); Aa.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Ta.copy(Ma).applyMatrix4(Aa), i) } } return e.applyMatrix4(this.bindMatrixInverse) } }), Ra.prototype = Object.assign(Object.create(ci.prototype), { constructor: Ra, isBone: !0 }); const Pa = new Bn, Ca = new Bn; function Ia(t = [], e = []) { this.uuid = Qe.generateUUID(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } Object.assign(Ia.prototype, { init: function () { const t = this.bones, e = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses(); else if (t.length !== e.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let t = 0, e = this.bones.length; t < e; t++)this.boneInverses.push(new Bn) } }, calculateInverses: function () { this.boneInverses.length = 0; for (let t = 0, e = this.bones.length; t < e; t++) { const e = new Bn; this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e) } }, pose: function () { for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && e.matrixWorld.copy(this.boneInverses[t]).invert() } for (let t = 0, e = this.bones.length; t < e; t++) { const e = this.bones[t]; e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)) } }, update: function () { const t = this.bones, e = this.boneInverses, n = this.boneMatrices, i = this.boneTexture; for (let i = 0, r = t.length; i < r; i++) { const r = t[i] ? t[i].matrixWorld : Ca; Pa.multiplyMatrices(r, e[i]), Pa.toArray(n, 16 * i) } null !== i && (i.needsUpdate = !0) }, clone: function () { return new Ia(this.bones, this.boneInverses) }, getBoneByName: function (t) { for (let e = 0, n = this.bones.length; e < n; e++) { const n = this.bones[e]; if (n.name === t) return n } }, dispose: function () { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) }, fromJSON: function (t, e) { this.uuid = t.uuid; for (let n = 0, i = t.bones.length; n < i; n++) { const i = t.bones[n]; let r = e[i]; void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Ra), this.bones.push(r), this.boneInverses.push((new Bn).fromArray(t.boneInverses[n])) } return this.init(), this }, toJSON: function () { const t = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; t.uuid = this.uuid; const e = this.bones, n = this.boneInverses; for (let i = 0, r = e.length; i < r; i++) { const r = e[i]; t.bones.push(r.uuid); const o = n[i]; t.boneInverses.push(o.toArray()) } return t } }); const Oa = new Bn, Da = new Bn, Na = [], za = new wr; function Ba(t, e, n) { wr.call(this, t, e), this.instanceMatrix = new Bi(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1 } function Ha(t) { Oi.call(this), this.type = "LineBasicMaterial", this.color = new Pi(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t) } Ba.prototype = Object.assign(Object.create(wr.prototype), { constructor: Ba, isInstancedMesh: !0, copy: function (t) { return wr.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this }, getColorAt: function (t, e) { e.fromArray(this.instanceColor.array, 3 * t) }, getMatrixAt: function (t, e) { e.fromArray(this.instanceMatrix.array, 16 * t) }, raycast: function (t, e) { const n = this.matrixWorld, i = this.count; if (za.geometry = this.geometry, za.material = this.material, void 0 !== za.material) for (let r = 0; r < i; r++) { this.getMatrixAt(r, Oa), Da.multiplyMatrices(n, Oa), za.matrixWorld = Da, za.raycast(t, Na); for (let t = 0, n = Na.length; t < n; t++) { const n = Na[t]; n.instanceId = r, n.object = this, e.push(n) } Na.length = 0 } }, setColorAt: function (t, e) { null === this.instanceColor && (this.instanceColor = new Bi(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t) }, setMatrixAt: function (t, e) { e.toArray(this.instanceMatrix.array, 16 * t) }, updateMorphTargets: function () { }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Ha.prototype = Object.create(Oi.prototype), Ha.prototype.constructor = Ha, Ha.prototype.isLineBasicMaterial = !0, Ha.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this }; const Ua = new ln, Fa = new ln, Ga = new Bn, ka = new zn, Va = new Ln; function Wa(t = new rr, e = new Ha) { ci.call(this), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets() } Wa.prototype = Object.assign(Object.create(ci.prototype), { constructor: Wa, isLine: !0, copy: function (t) { return ci.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this }, computeLineDistances: function () { const t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { const e = t.attributes.position, n = [0]; for (let t = 1, i = e.count; t < i; t++)Ua.fromBufferAttribute(e, t - 1), Fa.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Ua.distanceTo(Fa); t.setAttribute("lineDistance", new qi(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this }, raycast: function (t, e) { const n = this.geometry, i = this.matrixWorld, r = t.params.Line.threshold; if (null === n.boundingSphere && n.computeBoundingSphere(), Va.copy(n.boundingSphere), Va.applyMatrix4(i), Va.radius += r, !1 === t.ray.intersectsSphere(Va)) return; Ga.copy(i).invert(), ka.copy(t.ray).applyMatrix4(Ga); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o, a = new ln, c = new ln, l = new ln, h = new ln, u = this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { const i = n.index, r = n.attributes.position; if (null !== i) { const n = i.array; for (let i = 0, o = n.length - 1; i < o; i += u) { const o = n[i], u = n[i + 1]; if (a.fromBufferAttribute(r, o), c.fromBufferAttribute(r, u), ka.distanceSqToSegment(a, c, h, l) > s) continue; h.applyMatrix4(this.matrixWorld); const d = t.ray.origin.distanceTo(h); d < t.near || d > t.far || e.push({ distance: d, point: l.clone().applyMatrix4(this.matrixWorld), index: i, face: null, faceIndex: null, object: this }) } } else for (let n = 0, i = r.count - 1; n < i; n += u) { if (a.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1), ka.distanceSqToSegment(a, c, h, l) > s) continue; h.applyMatrix4(this.matrixWorld); const i = t.ray.origin.distanceTo(h); i < t.near || i > t.far || e.push({ distance: i, point: l.clone().applyMatrix4(this.matrixWorld), index: n, face: null, faceIndex: null, object: this }) } } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }); const ja = new ln, qa = new ln; function Xa(t, e) { Wa.call(this, t, e), this.type = "LineSegments" } function Ya(t, e) { Wa.call(this, t, e), this.type = "LineLoop" } function Za(t) { Oi.call(this), this.type = "PointsMaterial", this.color = new Pi(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t) } Xa.prototype = Object.assign(Object.create(Wa.prototype), { constructor: Xa, isLineSegments: !0, computeLineDistances: function () { const t = this.geometry; if (t.isBufferGeometry) if (null === t.index) { const e = t.attributes.position, n = []; for (let t = 0, i = e.count; t < i; t += 2)ja.fromBufferAttribute(e, t), qa.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + ja.distanceTo(qa); t.setAttribute("lineDistance", new qi(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } }), Ya.prototype = Object.assign(Object.create(Wa.prototype), { constructor: Ya, isLineLoop: !0 }), Za.prototype = Object.create(Oi.prototype), Za.prototype.constructor = Za, Za.prototype.isPointsMaterial = !0, Za.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this }; const Ja = new Bn, Qa = new zn, Ka = new Ln, $a = new ln; function tc(t = new rr, e = new Za) { ci.call(this), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets() } function ec(t, e, n, i, r, o, s) { const a = Qa.distanceSqToPoint(t); if (a < n) { const n = new ln; Qa.closestPointToPoint(t, n), n.applyMatrix4(i); const c = r.ray.origin.distanceTo(n); if (c < r.near || c > r.far) return; o.push({ distance: c, distanceToRay: Math.sqrt(a), point: n, index: e, face: null, object: s }) } } function nc(t, e, n, i, r, o, s, a, c) { rn.call(this, t, e, n, i, r, o, s, a, c), this.format = void 0 !== s ? s : Et, this.minFilter = void 0 !== o ? o : lt, this.magFilter = void 0 !== r ? r : lt, this.generateMipmaps = !1; const l = this; "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() { l.needsUpdate = !0, t.requestVideoFrameCallback(e) }) } function ic(t, e, n, i, r, o, s, a, c, l, h, u) { rn.call(this, null, o, s, a, c, l, i, r, h, u), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1 } function rc(t, e, n, i, r, o, s, a, c) { rn.call(this, t, e, n, i, r, o, s, a, c), this.needsUpdate = !0 } function oc(t, e, n, i, r, o, s, a, c, l) { if ((l = void 0 !== l ? l : Rt) !== Rt && l !== Pt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === n && l === Rt && (n = mt), void 0 === n && l === Pt && (n = Mt), rn.call(this, null, i, r, o, s, a, l, n, c), this.image = { width: t, height: e }, this.magFilter = void 0 !== s ? s : st, this.minFilter = void 0 !== a ? a : st, this.flipY = !1, this.generateMipmaps = !1 } tc.prototype = Object.assign(Object.create(ci.prototype), { constructor: tc, isPoints: !0, copy: function (t) { return ci.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this }, raycast: function (t, e) { const n = this.geometry, i = this.matrixWorld, r = t.params.Points.threshold; if (null === n.boundingSphere && n.computeBoundingSphere(), Ka.copy(n.boundingSphere), Ka.applyMatrix4(i), Ka.radius += r, !1 === t.ray.intersectsSphere(Ka)) return; Ja.copy(i).invert(), Qa.copy(t.ray).applyMatrix4(Ja); const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = o * o; if (n.isBufferGeometry) { const r = n.index, o = n.attributes.position; if (null !== r) { const n = r.array; for (let r = 0, a = n.length; r < a; r++) { const a = n[r]; $a.fromBufferAttribute(o, a), ec($a, a, s, i, t, e, this) } } else for (let n = 0, r = o.count; n < r; n++)$a.fromBufferAttribute(o, n), ec($a, n, s, i, t, e, this) } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") }, updateMorphTargets: function () { const t = this.geometry; if (t.isBufferGeometry) { const e = t.morphAttributes, n = Object.keys(e); if (n.length > 0) { const t = e[n[0]]; if (void 0 !== t) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, n = t.length; e < n; e++) { const n = t[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e } } } } else { const e = t.morphTargets; void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } }), nc.prototype = Object.assign(Object.create(rn.prototype), { constructor: nc, clone: function () { return new this.constructor(this.image).copy(this) }, isVideoTexture: !0, update: function () { const t = this.image; !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), ic.prototype = Object.create(rn.prototype), ic.prototype.constructor = ic, ic.prototype.isCompressedTexture = !0, rc.prototype = Object.create(rn.prototype), rc.prototype.constructor = rc, rc.prototype.isCanvasTexture = !0, oc.prototype = Object.create(rn.prototype), oc.prototype.constructor = oc, oc.prototype.isDepthTexture = !0; class sc extends rr { constructor(t, e, n = 1, i = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: i }; const r = [], o = []; function s(t, e, n, i) { const r = i + 1, o = []; for (let i = 0; i <= r; i++) { o[i] = []; const s = t.clone().lerp(n, i / r), a = e.clone().lerp(n, i / r), c = r - i; for (let t = 0; t <= c; t++)o[i][t] = 0 === t && i === r ? s : s.clone().lerp(a, t / c) } for (let t = 0; t < r; t++)for (let e = 0; e < 2 * (r - t) - 1; e++) { const n = Math.floor(e / 2); e % 2 == 0 ? (a(o[t][n + 1]), a(o[t + 1][n]), a(o[t][n])) : (a(o[t][n + 1]), a(o[t + 1][n + 1]), a(o[t + 1][n])) } } function a(t) { r.push(t.x, t.y, t.z) } function c(e, n) { const i = 3 * e; n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2] } function l(t, e, n, i) { i < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + .5) } function h(t) { return Math.atan2(t.z, -t.x) } !function (t) { const n = new ln, i = new ln, r = new ln; for (let o = 0; o < e.length; o += 3)c(e[o + 0], n), c(e[o + 1], i), c(e[o + 2], r), s(n, i, r, t) }(i), function (t) { const e = new ln; for (let n = 0; n < r.length; n += 3)e.x = r[n + 0], e.y = r[n + 1], e.z = r[n + 2], e.normalize().multiplyScalar(t), r[n + 0] = e.x, r[n + 1] = e.y, r[n + 2] = e.z }(n), function () { const t = new ln; for (let n = 0; n < r.length; n += 3) { t.x = r[n + 0], t.y = r[n + 1], t.z = r[n + 2]; const i = h(t) / 2 / Math.PI + .5, s = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5); o.push(i, 1 - s) } var e; (function () { const t = new ln, e = new ln, n = new ln, i = new ln, s = new Ke, a = new Ke, c = new Ke; for (let u = 0, d = 0; u < r.length; u += 9, d += 6) { t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), n.set(r[u + 6], r[u + 7], r[u + 8]), s.set(o[d + 0], o[d + 1]), a.set(o[d + 2], o[d + 3]), c.set(o[d + 4], o[d + 5]), i.copy(t).add(e).add(n).divideScalar(3); const p = h(i); l(s, d + 0, t, p), l(a, d + 2, e, p), l(c, d + 4, n, p) } })(), function () { for (let t = 0; t < o.length; t += 6) { const e = o[t + 0], n = o[t + 2], i = o[t + 4], r = Math.max(e, n, i), s = Math.min(e, n, i); r > .9 && s < .1 && (e < .2 && (o[t + 0] += 1), n < .2 && (o[t + 2] += 1), i < .2 && (o[t + 4] += 1)) } }() }(), this.setAttribute("position", new qi(r, 3)), this.setAttribute("normal", new qi(r.slice(), 3)), this.setAttribute("uv", new qi(o, 2)), 0 === i ? this.computeVertexNormals() : this.normalizeNormals() } } new ln, new ln, new ln, new Mi; const ac = function (t, e, n) { n = n || 2; const i = e && e.length, r = i ? e[0] * n : t.length; let o = cc(t, 0, r, n, !0); const s = []; if (!o || o.next === o.prev) return s; let a, c, l, h, u, d, p; if (i && (o = function (t, e, n, i) { const r = []; let o, s, a, c, l; for (o = 0, s = e.length; o < s; o++)a = e[o] * i, c = o < s - 1 ? e[o + 1] * i : t.length, (l = cc(t, a, c, i, !1)) === l.next && (l.steiner = !0), r.push(xc(l)); for (r.sort(mc), o = 0; o < r.length; o++)gc(r[o], n), n = lc(n, n.next); return n }(t, e, o, n)), t.length > 80 * n) { a = l = t[0], c = h = t[1]; for (let e = n; e < r; e += n)(u = t[e]) < a && (a = u), (d = t[e + 1]) < c && (c = d), u > l && (l = u), d > h && (h = d); p = 0 !== (p = Math.max(l - a, h - c)) ? 1 / p : 0 } return hc(o, s, n, a, c, p), s }; function cc(t, e, n, i, r) { let o, s; if (r === function (t, e, n, i) { let r = 0; for (let o = e, s = n - i; o < n; o += i)r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o; return r }(t, e, n, i) > 0) for (o = e; o < n; o += i)s = Rc(o, t[o], t[o + 1], s); else for (o = n - i; o >= e; o -= i)s = Rc(o, t[o], t[o + 1], s); return s && Mc(s, s.next) && (Pc(s), s = s.next), s } function lc(t, e) { if (!t) return t; e || (e = t); let n, i = t; do { if (n = !1, i.steiner || !Mc(i, i.next) && 0 !== wc(i.prev, i, i.next)) i = i.next; else { if (Pc(i), (i = e = i.prev) === i.next) break; n = !0 } } while (n || i !== e); return e } function hc(t, e, n, i, r, o, s) { if (!t) return; !s && o && function (t, e, n, i) { let r = t; do { null === r.z && (r.z = yc(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next } while (r !== t); r.prevZ.nextZ = null, r.prevZ = null, function (t) { let e, n, i, r, o, s, a, c, l = 1; do { for (n = t, t = null, o = null, s = 0; n;) { for (s++, i = n, a = 0, e = 0; e < l && (a++, i = i.nextZ); e++); for (c = l; a > 0 || c > 0 && i;)0 !== a && (0 === c || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r; n = i } o.nextZ = null, l *= 2 } while (s > 1) }(r) }(t, i, r, o); let a, c, l = t; for (; t.prev !== t.next;)if (a = t.prev, c = t.next, o ? dc(t, i, r, o) : uc(t)) e.push(a.i / n), e.push(t.i / n), e.push(c.i / n), Pc(t), t = c.next, l = c.next; else if ((t = c) === l) { s ? 1 === s ? hc(t = pc(lc(t), e, n), e, n, i, r, o, 2) : 2 === s && fc(t, e, n, i, r, o) : hc(lc(t), e, n, i, r, o, 1); break } } function uc(t) { const e = t.prev, n = t, i = t.next; if (wc(e, n, i) >= 0) return !1; let r = t.next.next; for (; r !== t.prev;) { if (_c(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && wc(r.prev, r, r.next) >= 0) return !1; r = r.next } return !0 } function dc(t, e, n, i) { const r = t.prev, o = t, s = t.next; if (wc(r, o, s) >= 0) return !1; const a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x, c = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y, l = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x, h = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y, u = yc(a, c, e, n, i), d = yc(l, h, e, n, i); let p = t.prevZ, f = t.nextZ; for (; p && p.z >= u && f && f.z <= d;) { if (p !== t.prev && p !== t.next && _c(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && wc(p.prev, p, p.next) >= 0) return !1; if (p = p.prevZ, f !== t.prev && f !== t.next && _c(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && wc(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } for (; p && p.z >= u;) { if (p !== t.prev && p !== t.next && _c(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && wc(p.prev, p, p.next) >= 0) return !1; p = p.prevZ } for (; f && f.z <= d;) { if (f !== t.prev && f !== t.next && _c(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && wc(f.prev, f, f.next) >= 0) return !1; f = f.nextZ } return !0 } function pc(t, e, n) { let i = t; do { const r = i.prev, o = i.next.next; !Mc(r, o) && Sc(r, i, i.next, o) && Ac(r, o) && Ac(o, r) && (e.push(r.i / n), e.push(i.i / n), e.push(o.i / n), Pc(i), Pc(i.next), i = t = o), i = i.next } while (i !== t); return lc(i) } function fc(t, e, n, i, r, o) { let s = t; do { let t = s.next.next; for (; t !== s.prev;) { if (s.i !== t.i && bc(s, t)) { let a = Lc(s, t); return s = lc(s, s.next), a = lc(a, a.next), hc(s, e, n, i, r, o), void hc(a, e, n, i, r, o) } t = t.next } s = s.next } while (s !== t) } function mc(t, e) { return t.x - e.x } function gc(t, e) { if (e = function (t, e) { let n = e; const i = t.x, r = t.y; let o, s = -1 / 0; do { if (r <= n.y && r >= n.next.y && n.next.y !== n.y) { const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (t <= i && t > s) { if (s = t, t === i) { if (r === n.y) return n; if (r === n.next.y) return n.next } o = n.x < n.next.x ? n : n.next } } n = n.next } while (n !== e); if (!o) return null; if (i === s) return o; const a = o, c = o.x, l = o.y; let h, u = 1 / 0; n = o; do { i >= n.x && n.x >= c && i !== n.x && _c(r < l ? i : s, r, c, l, r < l ? s : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x), Ac(n, t) && (h < u || h === u && (n.x > o.x || n.x === o.x && vc(o, n))) && (o = n, u = h)), n = n.next } while (n !== a); return o }(t, e)) { const n = Lc(e, t); lc(e, e.next), lc(n, n.next) } } function vc(t, e) { return wc(t.prev, t, e.prev) < 0 && wc(e.next, t, t.next) < 0 } function yc(t, e, n, i, r) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function xc(t) { let e = t, n = t; do { (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next } while (e !== t); return n } function _c(t, e, n, i, r, o, s, a) { return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (r - s) * (i - a) >= 0 } function bc(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { let n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Sc(n, n.next, t, e)) return !0; n = n.next } while (n !== t); return !1 }(t, e) && (Ac(t, e) && Ac(e, t) && function (t, e) { let n = t, i = !1; const r = (t.x + e.x) / 2, o = (t.y + e.y) / 2; do { n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next } while (n !== t); return i }(t, e) && (wc(t.prev, t, e.prev) || wc(t, e.prev, e)) || Mc(t, e) && wc(t.prev, t, t.next) > 0 && wc(e.prev, e, e.next) > 0) } function wc(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function Mc(t, e) { return t.x === e.x && t.y === e.y } function Sc(t, e, n, i) { const r = Tc(wc(t, e, n)), o = Tc(wc(t, e, i)), s = Tc(wc(n, i, t)), a = Tc(wc(n, i, e)); return r !== o && s !== a || (!(0 !== r || !Ec(t, n, e)) || (!(0 !== o || !Ec(t, i, e)) || (!(0 !== s || !Ec(n, t, i)) || !(0 !== a || !Ec(n, e, i))))) } function Ec(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) } function Tc(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function Ac(t, e) { return wc(t.prev, t, t.next) < 0 ? wc(t, e, t.next) >= 0 && wc(t, t.prev, e) >= 0 : wc(t, e, t.prev) < 0 || wc(t, t.next, e) < 0 } function Lc(t, e) { const n = new Cc(t.i, t.x, t.y), i = new Cc(e.i, e.x, e.y), r = t.next, o = e.prev; return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i } function Rc(t, e, n, i) { const r = new Cc(t, e, n); return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r } function Pc(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function Cc(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } const Ic = { area: function (t) { const e = t.length; let n = 0; for (let i = e - 1, r = 0; r < e; i = r++)n += t[i].x * t[r].y - t[r].x * t[i].y; return .5 * n }, isClockWise: function (t) { return Ic.area(t) < 0 }, triangulateShape: function (t, e) { const n = [], i = [], r = []; Oc(t), Dc(n, t); let o = t.length; e.forEach(Oc); for (let t = 0; t < e.length; t++)i.push(o), o += e[t].length, Dc(n, e[t]); const s = ac(n, i); for (let t = 0; t < s.length; t += 3)r.push(s.slice(t, t + 3)); return r } }; function Oc(t) { const e = t.length; e > 2 && t[e - 1].equals(t[0]) && t.pop() } function Dc(t, e) { for (let n = 0; n < e.length; n++)t.push(e[n].x), t.push(e[n].y) } class Nc extends rr { constructor(t, e) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t]; const n = this, i = [], r = []; for (let e = 0, n = t.length; e < n; e++) { o(t[e]) } function o(t) { const o = [], s = void 0 !== e.curveSegments ? e.curveSegments : 12, a = void 0 !== e.steps ? e.steps : 1; let c = void 0 !== e.depth ? e.depth : 100, l = void 0 === e.bevelEnabled || e.bevelEnabled, h = void 0 !== e.bevelThickness ? e.bevelThickness : 6, u = void 0 !== e.bevelSize ? e.bevelSize : h - 2, d = void 0 !== e.bevelOffset ? e.bevelOffset : 0, p = void 0 !== e.bevelSegments ? e.bevelSegments : 3; const f = e.extrudePath, m = void 0 !== e.UVGenerator ? e.UVGenerator : zc; void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount); let g, v, y, x, _, b = !1; f && (g = f.getSpacedPoints(a), b = !0, l = !1, v = f.computeFrenetFrames(a, !1), y = new ln, x = new ln, _ = new ln), l || (p = 0, h = 0, u = 0, d = 0); const w = t.extractPoints(s); let M = w.shape; const S = w.holes; if (!Ic.isClockWise(M)) { M = M.reverse(); for (let t = 0, e = S.length; t < e; t++) { const e = S[t]; Ic.isClockWise(e) && (S[t] = e.reverse()) } } const E = Ic.triangulateShape(M, S), T = M; for (let t = 0, e = S.length; t < e; t++) { const e = S[t]; M = M.concat(e) } function A(t, e, n) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t) } const L = M.length, R = E.length; function P(t, e, n) { let i, r, o; const s = t.x - e.x, a = t.y - e.y, c = n.x - t.x, l = n.y - t.y, h = s * s + a * a, u = s * l - a * c; if (Math.abs(u) > Number.EPSILON) { const u = Math.sqrt(h), d = Math.sqrt(c * c + l * l), p = e.x - a / u, f = e.y + s / u, m = ((n.x - l / d - p) * l - (n.y + c / d - f) * c) / (s * l - a * c), g = (i = p + s * m - t.x) * i + (r = f + a * m - t.y) * r; if (g <= 2) return new Ke(i, r); o = Math.sqrt(g / 2) } else { let t = !1; s > Number.EPSILON ? c > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(l) && (t = !0), t ? (i = -a, r = s, o = Math.sqrt(h)) : (i = s, r = a, o = Math.sqrt(h / 2)) } return new Ke(i / o, r / o) } const C = []; for (let t = 0, e = T.length, n = e - 1, i = t + 1; t < e; t++, n++, i++)n === e && (n = 0), i === e && (i = 0), C[t] = P(T[t], T[n], T[i]); const I = []; let O, D = C.concat(); for (let t = 0, e = S.length; t < e; t++) { const e = S[t]; O = []; for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++)i === n && (i = 0), r === n && (r = 0), O[t] = P(e[t], e[i], e[r]); I.push(O), D = D.concat(O) } for (let t = 0; t < p; t++) { const e = t / p, n = h * Math.cos(e * Math.PI / 2), i = u * Math.sin(e * Math.PI / 2) + d; for (let t = 0, e = T.length; t < e; t++) { const e = A(T[t], C[t], i); B(e.x, e.y, -n) } for (let t = 0, e = S.length; t < e; t++) { const e = S[t]; O = I[t]; for (let t = 0, r = e.length; t < r; t++) { const r = A(e[t], O[t], i); B(r.x, r.y, -n) } } } const N = u + d; for (let t = 0; t < L; t++) { const e = l ? A(M[t], D[t], N) : M[t]; b ? (x.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), _.copy(g[0]).add(x).add(y), B(_.x, _.y, _.z)) : B(e.x, e.y, 0) } for (let t = 1; t <= a; t++)for (let e = 0; e < L; e++) { const n = l ? A(M[e], D[e], N) : M[e]; b ? (x.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), _.copy(g[t]).add(x).add(y), B(_.x, _.y, _.z)) : B(n.x, n.y, c / a * t) } for (let t = p - 1; t >= 0; t--) { const e = t / p, n = h * Math.cos(e * Math.PI / 2), i = u * Math.sin(e * Math.PI / 2) + d; for (let t = 0, e = T.length; t < e; t++) { const e = A(T[t], C[t], i); B(e.x, e.y, c + n) } for (let t = 0, e = S.length; t < e; t++) { const e = S[t]; O = I[t]; for (let t = 0, r = e.length; t < r; t++) { const r = A(e[t], O[t], i); b ? B(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : B(r.x, r.y, c + n) } } } function z(t, e) { let n = t.length; for (; --n >= 0;) { const i = n; let r = n - 1; r < 0 && (r = t.length - 1); for (let t = 0, n = a + 2 * p; t < n; t++) { const n = L * t, o = L * (t + 1); U(e + i + n, e + r + n, e + r + o, e + i + o) } } } function B(t, e, n) { o.push(t), o.push(e), o.push(n) } function H(t, e, r) { F(t), F(e), F(r); const o = i.length / 3, s = m.generateTopUV(n, i, o - 3, o - 2, o - 1); G(s[0]), G(s[1]), G(s[2]) } function U(t, e, r, o) { F(t), F(e), F(o), F(e), F(r), F(o); const s = i.length / 3, a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1); G(a[0]), G(a[1]), G(a[3]), G(a[1]), G(a[2]), G(a[3]) } function F(t) { i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2]) } function G(t) { r.push(t.x), r.push(t.y) } !function () { const t = i.length / 3; if (l) { let t = 0, e = L * t; for (let t = 0; t < R; t++) { const n = E[t]; H(n[2] + e, n[1] + e, n[0] + e) } e = L * (t = a + 2 * p); for (let t = 0; t < R; t++) { const n = E[t]; H(n[0] + e, n[1] + e, n[2] + e) } } else { for (let t = 0; t < R; t++) { const e = E[t]; H(e[2], e[1], e[0]) } for (let t = 0; t < R; t++) { const e = E[t]; H(e[0] + L * a, e[1] + L * a, e[2] + L * a) } } n.addGroup(t, i.length / 3 - t, 0) }(), function () { const t = i.length / 3; let e = 0; z(T, e), e += T.length; for (let t = 0, n = S.length; t < n; t++) { const n = S[t]; z(n, e), e += n.length } n.addGroup(t, i.length / 3 - t, 1) }() } this.setAttribute("position", new qi(i, 3)), this.setAttribute("uv", new qi(r, 2)), this.computeVertexNormals() } toJSON() { const t = rr.prototype.toJSON.call(this); return function (t, e, n) { if (n.shapes = [], Array.isArray(t)) for (let e = 0, i = t.length; e < i; e++) { const i = t[e]; n.shapes.push(i.uuid) } else n.shapes.push(t.uuid); void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()); return n }(this.parameters.shapes, this.parameters.options, t) } } const zc = { generateTopUV: function (t, e, n, i, r) { const o = e[3 * n], s = e[3 * n + 1], a = e[3 * i], c = e[3 * i + 1], l = e[3 * r], h = e[3 * r + 1]; return [new Ke(o, s), new Ke(a, c), new Ke(l, h)] }, generateSideWallUV: function (t, e, n, i, r, o) { const s = e[3 * n], a = e[3 * n + 1], c = e[3 * n + 2], l = e[3 * i], h = e[3 * i + 1], u = e[3 * i + 2], d = e[3 * r], p = e[3 * r + 1], f = e[3 * r + 2], m = e[3 * o], g = e[3 * o + 1], v = e[3 * o + 2]; return Math.abs(a - h) < .01 ? [new Ke(s, 1 - c), new Ke(l, 1 - u), new Ke(d, 1 - f), new Ke(m, 1 - v)] : [new Ke(a, 1 - c), new Ke(h, 1 - u), new Ke(p, 1 - f), new Ke(g, 1 - v)] } }; class Bc extends sc { constructor(t = 1, e = 0) { super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e } } } function Hc(t, e, n) { rr.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: n }; const i = [], r = [], o = [], s = [], a = new ln, c = new ln, l = new ln, h = new ln, u = new ln; t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); const d = e + 1; for (let i = 0; i <= n; i++) { const d = i / n; for (let n = 0; n <= e; n++) { const i = n / e; t(i, d, c), r.push(c.x, c.y, c.z), i - 1e-5 >= 0 ? (t(i - 1e-5, d, l), h.subVectors(c, l)) : (t(i + 1e-5, d, l), h.subVectors(l, c)), d - 1e-5 >= 0 ? (t(i, d - 1e-5, l), u.subVectors(c, l)) : (t(i, d + 1e-5, l), u.subVectors(l, c)), a.crossVectors(h, u).normalize(), o.push(a.x, a.y, a.z), s.push(i, d) } } for (let t = 0; t < n; t++)for (let n = 0; n < e; n++) { const e = t * d + n, r = t * d + n + 1, o = (t + 1) * d + n + 1, s = (t + 1) * d + n; i.push(e, r, s), i.push(r, o, s) } this.setIndex(i), this.setAttribute("position", new qi(r, 3)), this.setAttribute("normal", new qi(o, 3)), this.setAttribute("uv", new qi(s, 2)) } Hc.prototype = Object.create(rr.prototype), Hc.prototype.constructor = Hc; class Uc extends rr { constructor(t = .5, e = 1, n = 8, i = 1, r = 0, o = 2 * Math.PI) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: i, thetaStart: r, thetaLength: o }, n = Math.max(3, n); const s = [], a = [], c = [], l = []; let h = t; const u = (e - t) / (i = Math.max(1, i)), d = new ln, p = new Ke; for (let t = 0; t <= i; t++) { for (let t = 0; t <= n; t++) { const i = r + t / n * o; d.x = h * Math.cos(i), d.y = h * Math.sin(i), a.push(d.x, d.y, d.z), c.push(0, 0, 1), p.x = (d.x / e + 1) / 2, p.y = (d.y / e + 1) / 2, l.push(p.x, p.y) } h += u } for (let t = 0; t < i; t++) { const e = t * (n + 1); for (let t = 0; t < n; t++) { const i = t + e, r = i, o = i + n + 1, a = i + n + 2, c = i + 1; s.push(r, o, c), s.push(o, a, c) } } this.setIndex(s), this.setAttribute("position", new qi(a, 3)), this.setAttribute("normal", new qi(c, 3)), this.setAttribute("uv", new qi(l, 2)) } } class Fc extends rr { constructor(t, e = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: t, curveSegments: e }; const n = [], i = [], r = [], o = []; let s = 0, a = 0; if (!1 === Array.isArray(t)) c(t); else for (let e = 0; e < t.length; e++)c(t[e]), this.addGroup(s, a, e), s += a, a = 0; function c(t) { const s = i.length / 3, c = t.extractPoints(e); let l = c.shape; const h = c.holes; !1 === Ic.isClockWise(l) && (l = l.reverse()); for (let t = 0, e = h.length; t < e; t++) { const e = h[t]; !0 === Ic.isClockWise(e) && (h[t] = e.reverse()) } const u = Ic.triangulateShape(l, h); for (let t = 0, e = h.length; t < e; t++) { const e = h[t]; l = l.concat(e) } for (let t = 0, e = l.length; t < e; t++) { const e = l[t]; i.push(e.x, e.y, 0), r.push(0, 0, 1), o.push(e.x, e.y) } for (let t = 0, e = u.length; t < e; t++) { const e = u[t], i = e[0] + s, r = e[1] + s, o = e[2] + s; n.push(i, r, o), a += 3 } } this.setIndex(n), this.setAttribute("position", new qi(i, 3)), this.setAttribute("normal", new qi(r, 3)), this.setAttribute("uv", new qi(o, 2)) } toJSON() { const t = rr.prototype.toJSON.call(this); return function (t, e) { if (e.shapes = [], Array.isArray(t)) for (let n = 0, i = t.length; n < i; n++) { const i = t[n]; e.shapes.push(i.uuid) } else e.shapes.push(t.uuid); return e }(this.parameters.shapes, t) } } class Gc extends rr { constructor(t) { if (super(), this.type = "WireframeGeometry", !0 === t.isGeometry) return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); const e = [], n = [0, 0], i = {}, r = new ln; if (null !== t.index) { const o = t.attributes.position, s = t.index; let a = t.groups; 0 === a.length && (a = [{ start: 0, count: s.count, materialIndex: 0 }]); for (let t = 0, e = a.length; t < e; ++t) { const e = a[t], r = e.start; for (let t = r, o = r + e.count; t < o; t += 3)for (let e = 0; e < 3; e++) { const r = s.getX(t + e), o = s.getX(t + (e + 1) % 3); n[0] = Math.min(r, o), n[1] = Math.max(r, o); const a = n[0] + "," + n[1]; void 0 === i[a] && (i[a] = { index1: n[0], index2: n[1] }) } } for (const t in i) { const n = i[t]; r.fromBufferAttribute(o, n.index1), e.push(r.x, r.y, r.z), r.fromBufferAttribute(o, n.index2), e.push(r.x, r.y, r.z) } } else { const n = t.attributes.position; for (let t = 0, i = n.count / 3; t < i; t++)for (let i = 0; i < 3; i++) { const o = 3 * t + i; r.fromBufferAttribute(n, o), e.push(r.x, r.y, r.z); const s = 3 * t + (i + 1) % 3; r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z) } } this.setAttribute("position", new qi(e, 3)) } } function kc(t) { Oi.call(this), this.type = "ShadowMaterial", this.color = new Pi(0), this.transparent = !0, this.setValues(t) } function Vc(t) { Pr.call(this, t), this.type = "RawShaderMaterial" } function Wc(t) { Oi.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Pi(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ge, this.normalScale = new Ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.vertexTangents = !1, this.setValues(t) } function jc(t) { Wc.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ke(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", { get: function () { return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity) }, set: function (t) { this.reflectivity = Qe.clamp(2.5 * (t - 1) / (t + 1), 0, 1) } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t) } function qc(t) { Oi.call(this), this.type = "MeshPhongMaterial", this.color = new Pi(16777215), this.specular = new Pi(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ge, this.normalScale = new Ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = k, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Xc(t) { Oi.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Pi(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ge, this.normalScale = new Ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Yc(t) { Oi.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ge, this.normalScale = new Ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Zc(t) { Oi.call(this), this.type = "MeshLambertMaterial", this.color = new Pi(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Pi(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = k, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Jc(t) { Oi.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Pi(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ge, this.normalScale = new Ke(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t) } function Qc(t) { Ha.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) } kc.prototype = Object.create(Oi.prototype), kc.prototype.constructor = kc, kc.prototype.isShadowMaterial = !0, kc.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.color.copy(t.color), this }, Vc.prototype = Object.create(Pr.prototype), Vc.prototype.constructor = Vc, Vc.prototype.isRawShaderMaterial = !0, Wc.prototype = Object.create(Oi.prototype), Wc.prototype.constructor = Wc, Wc.prototype.isMeshStandardMaterial = !0, Wc.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.vertexTangents = t.vertexTangents, this }, jc.prototype = Object.create(Wc.prototype), jc.prototype.constructor = jc, jc.prototype.isMeshPhysicalMaterial = !0, jc.prototype.copy = function (t) { return Wc.prototype.copy.call(this, t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Pi).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this }, qc.prototype = Object.create(Oi.prototype), qc.prototype.constructor = qc, qc.prototype.isMeshPhongMaterial = !0, qc.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Xc.prototype = Object.create(Oi.prototype), Xc.prototype.constructor = Xc, Xc.prototype.isMeshToonMaterial = !0, Xc.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Yc.prototype = Object.create(Oi.prototype), Yc.prototype.constructor = Yc, Yc.prototype.isMeshNormalMaterial = !0, Yc.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Zc.prototype = Object.create(Oi.prototype), Zc.prototype.constructor = Zc, Zc.prototype.isMeshLambertMaterial = !0, Zc.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Jc.prototype = Object.create(Oi.prototype), Jc.prototype.constructor = Jc, Jc.prototype.isMeshMatcapMaterial = !0, Jc.prototype.copy = function (t) { return Oi.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, Qc.prototype = Object.create(Ha.prototype), Qc.prototype.constructor = Qc, Qc.prototype.isLineDashedMaterial = !0, Qc.prototype.copy = function (t) { return Ha.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }; var Kc = Object.freeze({ __proto__: null, ShadowMaterial: kc, SpriteMaterial: ra, RawShaderMaterial: Vc, ShaderMaterial: Pr, PointsMaterial: Za, MeshPhysicalMaterial: jc, MeshStandardMaterial: Wc, MeshPhongMaterial: qc, MeshToonMaterial: Xc, MeshNormalMaterial: Yc, MeshLambertMaterial: Zc, MeshDepthMaterial: Hs, MeshDistanceMaterial: Us, MeshBasicMaterial: Di, MeshMatcapMaterial: Jc, LineDashedMaterial: Qc, LineBasicMaterial: Ha, Material: Oi }); const $c = { arraySlice: function (t, e, n) { return $c.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n) }, convertArray: function (t, e, n) { return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) }, isTypedArray: function (t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) }, getKeyframeOrder: function (t) { const e = t.length, n = new Array(e); for (let t = 0; t !== e; ++t)n[t] = t; return n.sort(function (e, n) { return t[e] - t[n] }), n }, sortedArray: function (t, e, n) { const i = t.length, r = new t.constructor(i); for (let o = 0, s = 0; s !== i; ++o) { const i = n[o] * e; for (let n = 0; n !== e; ++n)r[s++] = t[i + n] } return r }, flattenJSON: function (t, e, n, i) { let r = 1, o = t[0]; for (; void 0 !== o && void 0 === o[i];)o = t[r++]; if (void 0 === o) return; let s = o[i]; if (void 0 !== s) if (Array.isArray(s)) do { void 0 !== (s = o[i]) && (e.push(o.time), n.push.apply(n, s)), o = t[r++] } while (void 0 !== o); else if (void 0 !== s.toArray) do { void 0 !== (s = o[i]) && (e.push(o.time), s.toArray(n, n.length)), o = t[r++] } while (void 0 !== o); else do { void 0 !== (s = o[i]) && (e.push(o.time), n.push(s)), o = t[r++] } while (void 0 !== o) }, subclip: function (t, e, n, i, r = 30) { const o = t.clone(); o.name = e; const s = []; for (let t = 0; t < o.tracks.length; ++t) { const e = o.tracks[t], a = e.getValueSize(), c = [], l = []; for (let t = 0; t < e.times.length; ++t) { const o = e.times[t] * r; if (!(o < n || o >= i)) { c.push(e.times[t]); for (let n = 0; n < a; ++n)l.push(e.values[t * a + n]) } } 0 !== c.length && (e.times = $c.convertArray(c, e.times.constructor), e.values = $c.convertArray(l, e.values.constructor), s.push(e)) } o.tracks = s; let a = 1 / 0; for (let t = 0; t < o.tracks.length; ++t)a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]); for (let t = 0; t < o.tracks.length; ++t)o.tracks[t].shift(-1 * a); return o.resetDuration(), o }, makeClipAdditive: function (t, e = 0, n = t, i = 30) { i <= 0 && (i = 30); const r = n.tracks.length, o = e / i; for (let e = 0; e < r; ++e) { const i = n.tracks[e], r = i.ValueTypeName; if ("bool" === r || "string" === r) continue; const s = t.tracks.find(function (t) { return t.name === i.name && t.ValueTypeName === r }); if (void 0 === s) continue; let a = 0; const c = i.getValueSize(); i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = c / 3); let l = 0; const h = s.getValueSize(); s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (l = h / 3); const u = i.times.length - 1; let d; if (o <= i.times[0]) { const t = a, e = c - a; d = $c.arraySlice(i.values, t, e) } else if (o >= i.times[u]) { const t = u * c + a, e = t + c - a; d = $c.arraySlice(i.values, t, e) } else { const t = i.createInterpolant(), e = a, n = c - a; t.evaluate(o), d = $c.arraySlice(t.resultBuffer, e, n) } if ("quaternion" === r) { (new cn).fromArray(d).normalize().conjugate().toArray(d) } const p = s.times.length; for (let t = 0; t < p; ++t) { const e = t * h + l; if ("quaternion" === r) cn.multiplyQuaternionsFlat(s.values, e, d, 0, s.values, e); else { const t = h - 2 * l; for (let n = 0; n < t; ++n)s.values[e + n] -= d[n] } } } return t.blendMode = Pe, t } }; function tl(t, e, n, i) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n } function el(t, e, n, i) { tl.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 } function nl(t, e, n, i) { tl.call(this, t, e, n, i) } function il(t, e, n, i) { tl.call(this, t, e, n, i) } function rl(t, e, n, i) { if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = $c.convertArray(e, this.TimeBufferType), this.values = $c.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation) } function ol(t, e, n) { rl.call(this, t, e, n) } function sl(t, e, n, i) { rl.call(this, t, e, n, i) } function al(t, e, n, i) { rl.call(this, t, e, n, i) } function cl(t, e, n, i) { tl.call(this, t, e, n, i) } function ll(t, e, n, i) { rl.call(this, t, e, n, i) } function hl(t, e, n, i) { rl.call(this, t, e, n, i) } function ul(t, e, n, i) { rl.call(this, t, e, n, i) } function dl(t, e = -1, n, i = Re) { this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = Qe.generateUUID(), this.duration < 0 && this.resetDuration() } function pl(t) { if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const e = function (t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return al; case "vector": case "vector2": case "vector3": case "vector4": return ul; case "color": return sl; case "quaternion": return ll; case "bool": case "boolean": return ol; case "string": return hl }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t) }(t.type); if (void 0 === t.times) { const e = [], n = []; $c.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n } return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation) } Object.assign(tl.prototype, { evaluate: function (t) { const e = this.parameterPositions; let n = this._cachedIndex, i = e[n], r = e[n - 1]; t: { e: { let o; n: { i: if (!(t < i)) { for (let o = n + 2; ;) { if (void 0 === i) { if (t < r) break i; return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r) } if (n === o) break; if (r = i, t < (i = e[++n])) break e } o = e.length; break n } if (t >= r) break t; { const s = e[1]; t < s && (n = 2, r = s); for (let o = n - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (n === o) break; if (i = r, t >= (r = e[--n - 1])) break e } o = n, n = 0 } } for (; n < o;) { const i = n + o >>> 1; t < e[i] ? o = i : n = i + 1 } if (i = e[n], void 0 === (r = e[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, i); if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t) } this._cachedIndex = n, this.intervalChanged_(n, r, i) } return this.interpolate_(n, r, t, i) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (t) { const e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i; for (let t = 0; t !== i; ++t)e[t] = n[r + t]; return e }, interpolate_: function () { throw new Error("call to abstract method") }, intervalChanged_: function () { } }), Object.assign(tl.prototype, { beforeStart_: tl.prototype.copySampleValue_, afterEnd_: tl.prototype.copySampleValue_ }), el.prototype = Object.assign(Object.create(tl.prototype), { constructor: el, DefaultSettings_: { endingStart: Te, endingEnd: Te }, intervalChanged_: function (t, e, n) { const i = this.parameterPositions; let r = t - 2, o = t + 1, s = i[r], a = i[o]; if (void 0 === s) switch (this.getSettings_().endingStart) { case Ae: r = t, s = 2 * e - n; break; case Le: s = e + i[r = i.length - 2] - i[r + 1]; break; default: r = t, s = n }if (void 0 === a) switch (this.getSettings_().endingEnd) { case Ae: o = t, a = 2 * n - e; break; case Le: o = 1, a = n + i[1] - i[0]; break; default: o = t - 1, a = e }const c = .5 * (n - e), l = this.valueSize; this._weightPrev = c / (e - s), this._weightNext = c / (a - n), this._offsetPrev = r * l, this._offsetNext = o * l }, interpolate_: function (t, e, n, i) { const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, c = a - s, l = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (n - e) / (i - e), f = p * p, m = f * p, g = -u * m + 2 * u * f - u * p, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, x = d * m - d * f; for (let t = 0; t !== s; ++t)r[t] = g * o[l + t] + v * o[c + t] + y * o[a + t] + x * o[h + t]; return r } }), nl.prototype = Object.assign(Object.create(tl.prototype), { constructor: nl, interpolate_: function (t, e, n, i) { const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = t * s, c = a - s, l = (n - e) / (i - e), h = 1 - l; for (let t = 0; t !== s; ++t)r[t] = o[c + t] * h + o[a + t] * l; return r } }), il.prototype = Object.assign(Object.create(tl.prototype), { constructor: il, interpolate_: function (t) { return this.copySampleValue_(t - 1) } }), Object.assign(rl, { toJSON: function (t) { const e = t.constructor; let n; if (void 0 !== e.toJSON) n = e.toJSON(t); else { n = { name: t.name, times: $c.convertArray(t.times, Array), values: $c.convertArray(t.values, Array) }; const e = t.getInterpolation(); e !== t.DefaultInterpolation && (n.interpolation = e) } return n.type = t.ValueTypeName, n } }), Object.assign(rl.prototype, { constructor: rl, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (t) { return new il(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodLinear: function (t) { return new nl(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: function (t) { return new el(this.times, this.values, this.getValueSize(), t) }, setInterpolation: function (t) { let e; switch (t) { case 2300: e = this.InterpolantFactoryMethodDiscrete; break; case 2301: e = this.InterpolantFactoryMethodLinear; break; case 2302: e = this.InterpolantFactoryMethodSmooth }if (void 0 === e) { const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw new Error(e); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", e), this } return this.createInterpolant = e, this }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (t) { if (0 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n)e[n] += t } return this }, scale: function (t) { if (1 !== t) { const e = this.times; for (let n = 0, i = e.length; n !== i; ++n)e[n] *= t } return this }, trim: function (t, e) { const n = this.times, i = n.length; let r = 0, o = i - 1; for (; r !== i && n[r] < t;)++r; for (; -1 !== o && n[o] > e;)--o; if (++o, 0 !== r || o !== i) { r >= o && (r = (o = Math.max(o, 1)) - 1); const t = this.getValueSize(); this.times = $c.arraySlice(n, r, o), this.values = $c.arraySlice(this.values, r * t, o * t) } return this }, validate: function () { let t = !0; const e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); const n = this.times, i = this.values, r = n.length; 0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); let o = null; for (let e = 0; e !== r; e++) { const i = n[e]; if ("number" == typeof i && isNaN(i)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1; break } if (null !== o && o > i) { console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, o), t = !1; break } o = i } if (void 0 !== i && $c.isTypedArray(i)) for (let e = 0, n = i.length; e !== n; ++e) { const n = i[e]; if (isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1; break } } return t }, optimize: function () { const t = $c.arraySlice(this.times), e = $c.arraySlice(this.values), n = this.getValueSize(), i = 2302 === this.getInterpolation(), r = t.length - 1; let o = 1; for (let s = 1; s < r; ++s) { let r = !1; const a = t[s]; if (a !== t[s + 1] && (1 !== s || a !== t[0])) if (i) r = !0; else { const t = s * n, i = t - n, o = t + n; for (let s = 0; s !== n; ++s) { const n = e[t + s]; if (n !== e[i + s] || n !== e[o + s]) { r = !0; break } } } if (r) { if (s !== o) { t[o] = t[s]; const i = s * n, r = o * n; for (let t = 0; t !== n; ++t)e[r + t] = e[i + t] } ++o } } if (r > 0) { t[o] = t[r]; for (let t = r * n, i = o * n, s = 0; s !== n; ++s)e[i + s] = e[t + s]; ++o } return o !== t.length ? (this.times = $c.arraySlice(t, 0, o), this.values = $c.arraySlice(e, 0, o * n)) : (this.times = t, this.values = e), this }, clone: function () { const t = $c.arraySlice(this.times, 0), e = $c.arraySlice(this.values, 0), n = new (0, this.constructor)(this.name, t, e); return n.createInterpolant = this.createInterpolant, n } }), ol.prototype = Object.assign(Object.create(rl.prototype), { constructor: ol, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), sl.prototype = Object.assign(Object.create(rl.prototype), { constructor: sl, ValueTypeName: "color" }), al.prototype = Object.assign(Object.create(rl.prototype), { constructor: al, ValueTypeName: "number" }), cl.prototype = Object.assign(Object.create(tl.prototype), { constructor: cl, interpolate_: function (t, e, n, i) { const r = this.resultBuffer, o = this.sampleValues, s = this.valueSize, a = (n - e) / (i - e); let c = t * s; for (let t = c + s; c !== t; c += 4)cn.slerpFlat(r, 0, o, c - s, o, c, a); return r } }), ll.prototype = Object.assign(Object.create(rl.prototype), { constructor: ll, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (t) { return new cl(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: void 0 }), hl.prototype = Object.assign(Object.create(rl.prototype), { constructor: hl, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), ul.prototype = Object.assign(Object.create(rl.prototype), { constructor: ul, ValueTypeName: "vector" }), Object.assign(dl, { parse: function (t) { const e = [], n = t.tracks, i = 1 / (t.fps || 1); for (let t = 0, r = n.length; t !== r; ++t)e.push(pl(n[t]).scale(i)); const r = new dl(t.name, t.duration, e, t.blendMode); return r.uuid = t.uuid, r }, toJSON: function (t) { const e = [], n = t.tracks, i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }; for (let t = 0, i = n.length; t !== i; ++t)e.push(rl.toJSON(n[t])); return i }, CreateFromMorphTargetSequence: function (t, e, n, i) { const r = e.length, o = []; for (let t = 0; t < r; t++) { let s = [], a = []; s.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0); const c = $c.getKeyframeOrder(s); s = $c.sortedArray(s, 1, c), a = $c.sortedArray(a, 1, c), i || 0 !== s[0] || (s.push(r), a.push(a[0])), o.push(new al(".morphTargetInfluences[" + e[t].name + "]", s, a).scale(1 / n)) } return new dl(t, -1, o) }, findByName: function (t, e) { let n = t; if (!Array.isArray(t)) { const e = t; n = e.geometry && e.geometry.animations || e.animations } for (let t = 0; t < n.length; t++)if (n[t].name === e) return n[t]; return null }, CreateClipsFromMorphTargetSequences: function (t, e, n) { const i = {}, r = /^([\w-]*?)([\d]+)$/; for (let e = 0, n = t.length; e < n; e++) { const n = t[e], o = n.name.match(r); if (o && o.length > 1) { const t = o[1]; let e = i[t]; e || (i[t] = e = []), e.push(n) } } const o = []; for (const t in i) o.push(dl.CreateFromMorphTargetSequence(t, i[t], e, n)); return o }, parseAnimation: function (t, e) { if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const n = function (t, e, n, i, r) { if (0 !== n.length) { const o = [], s = []; $c.flattenJSON(n, o, s, i), 0 !== o.length && r.push(new t(e, o, s)) } }, i = [], r = t.name || "default", o = t.fps || 30, s = t.blendMode; let a = t.length || -1; const c = t.hierarchy || []; for (let t = 0; t < c.length; t++) { const r = c[t].keys; if (r && 0 !== r.length) if (r[0].morphTargets) { const t = {}; let e; for (e = 0; e < r.length; e++)if (r[e].morphTargets) for (let n = 0; n < r[e].morphTargets.length; n++)t[r[e].morphTargets[n]] = -1; for (const n in t) { const t = [], o = []; for (let i = 0; i !== r[e].morphTargets.length; ++i) { const i = r[e]; t.push(i.time), o.push(i.morphTarget === n ? 1 : 0) } i.push(new al(".morphTargetInfluence[" + n + "]", t, o)) } a = t.length * (o || 1) } else { const o = ".bones[" + e[t].name + "]"; n(ul, o + ".position", r, "pos", i), n(ll, o + ".quaternion", r, "rot", i), n(ul, o + ".scale", r, "scl", i) } } return 0 === i.length ? null : new dl(r, a, i, s) } }), Object.assign(dl.prototype, { resetDuration: function () { let t = 0; for (let e = 0, n = this.tracks.length; e !== n; ++e) { const n = this.tracks[e]; t = Math.max(t, n.times[n.times.length - 1]) } return this.duration = t, this }, trim: function () { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this }, validate: function () { let t = !0; for (let e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t }, optimize: function () { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this }, clone: function () { const t = []; for (let e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new dl(this.name, this.duration, t, this.blendMode) }, toJSON: function () { return dl.toJSON(this) } }); const fl = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }; function ml(t, e, n) { const i = this; let r = !1, o = 0, s = 0, a = void 0; const c = []; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) { s++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, s), r = !0 }, this.itemEnd = function (t) { o++, void 0 !== i.onProgress && i.onProgress(t, o, s), o === s && (r = !1, void 0 !== i.onLoad && i.onLoad()) }, this.itemError = function (t) { void 0 !== i.onError && i.onError(t) }, this.resolveURL = function (t) { return a ? a(t) : t }, this.setURLModifier = function (t) { return a = t, this }, this.addHandler = function (t, e) { return c.push(t, e), this }, this.removeHandler = function (t) { const e = c.indexOf(t); return -1 !== e && c.splice(e, 2), this }, this.getHandler = function (t) { for (let e = 0, n = c.length; e < n; e += 2) { const n = c[e], i = c[e + 1]; if (n.global && (n.lastIndex = 0), n.test(t)) return i } return null } } const gl = new ml; function vl(t) { this.manager = void 0 !== t ? t : gl, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } Object.assign(vl.prototype, { load: function () { }, loadAsync: function (t, e) { const n = this; return new Promise(function (i, r) { n.load(t, i, e, r) }) }, parse: function () { }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this }, setPath: function (t) { return this.path = t, this }, setResourcePath: function (t) { return this.resourcePath = t, this }, setRequestHeader: function (t) { return this.requestHeader = t, this } }); const yl = {}; function xl(t) { vl.call(this, t) } function _l(t) { vl.call(this, t) } function bl(t) { vl.call(this, t) } function wl(t) { vl.call(this, t) } function Ml(t) { vl.call(this, t) } function Sl(t) { vl.call(this, t) } function El(t) { vl.call(this, t) } function Tl() { this.type = "Curve", this.arcLengthDivisions = 200 } function Al(t, e, n, i, r, o, s, a) { Tl.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = a || 0 } function Ll(t, e, n, i, r, o) { Al.call(this, t, e, n, n, i, r, o), this.type = "ArcCurve" } function Rl() { let t = 0, e = 0, n = 0, i = 0; function r(r, o, s, a) { t = r, e = s, n = -3 * r + 3 * o - 2 * s - a, i = 2 * r - 2 * o + s + a } return { initCatmullRom: function (t, e, n, i, o) { r(e, n, o * (n - t), o * (i - e)) }, initNonuniformCatmullRom: function (t, e, n, i, o, s, a) { let c = (e - t) / o - (n - t) / (o + s) + (n - e) / s, l = (n - e) / s - (i - e) / (s + a) + (i - n) / a; r(e, n, c *= s, l *= s) }, calc: function (r) { const o = r * r; return t + e * r + n * o + i * (o * r) } } } xl.prototype = Object.assign(Object.create(vl.prototype), { constructor: xl, load: function (t, e, n, i) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, o = fl.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () { e && e(o), r.manager.itemEnd(t) }, 0), o; if (void 0 !== yl[t]) return void yl[t].push({ onLoad: e, onProgress: n, onError: i }); const s = t.match(/^data:(.*?)(;base64)?,(.*)$/); let a; if (s) { const n = s[1], o = !!s[2]; let a = s[3]; a = decodeURIComponent(a), o && (a = atob(a)); try { let o; const s = (this.responseType || "").toLowerCase(); switch (s) { case "arraybuffer": case "blob": const t = new Uint8Array(a.length); for (let e = 0; e < a.length; e++)t[e] = a.charCodeAt(e); o = "blob" === s ? new Blob([t.buffer], { type: n }) : t.buffer; break; case "document": const e = new DOMParser; o = e.parseFromString(a, n); break; case "json": o = JSON.parse(a); break; default: o = a }setTimeout(function () { e && e(o), r.manager.itemEnd(t) }, 0) } catch (e) { setTimeout(function () { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) }, 0) } } else { yl[t] = [], yl[t].push({ onLoad: e, onProgress: n, onError: i }), (a = new XMLHttpRequest).open("GET", t, !0), a.addEventListener("load", function (e) { const n = this.response, i = yl[t]; if (delete yl[t], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), fl.add(t, n); for (let t = 0, e = i.length; t < e; t++) { const e = i[t]; e.onLoad && e.onLoad(n) } r.manager.itemEnd(t) } else { for (let t = 0, n = i.length; t < n; t++) { const n = i[t]; n.onError && n.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) } }, !1), a.addEventListener("progress", function (e) { const n = yl[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onProgress && i.onProgress(e) } }, !1), a.addEventListener("error", function (e) { const n = yl[t]; delete yl[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onError && i.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) }, !1), a.addEventListener("abort", function (e) { const n = yl[t]; delete yl[t]; for (let t = 0, i = n.length; t < i; t++) { const i = n[t]; i.onError && i.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) }, !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]); a.send(null) } return r.manager.itemStart(t), a }, setResponseType: function (t) { return this.responseType = t, this }, setMimeType: function (t) { return this.mimeType = t, this } }), _l.prototype = Object.assign(Object.create(vl.prototype), { constructor: _l, load: function (t, e, n, i) { const r = this, o = new xl(r.manager); o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, function (n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }, n, i) }, parse: function (t) { const e = []; for (let n = 0; n < t.length; n++) { const i = dl.parse(t[n]); e.push(i) } return e } }), bl.prototype = Object.assign(Object.create(vl.prototype), { constructor: bl, load: function (t, e, n, i) { const r = this, o = [], s = new ic, a = new xl(this.manager); a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(r.withCredentials); let c = 0; function l(l) { a.load(t[l], function (t) { const n = r.parse(t, !0); o[l] = { width: n.width, height: n.height, format: n.format, mipmaps: n.mipmaps }, 6 === (c += 1) && (1 === n.mipmapCount && (s.minFilter = lt), s.image = o, s.format = n.format, s.needsUpdate = !0, e && e(s)) }, n, i) } if (Array.isArray(t)) for (let e = 0, n = t.length; e < n; ++e)l(e); else a.load(t, function (t) { const n = r.parse(t, !0); if (n.isCubemap) { const t = n.mipmaps.length / n.mipmapCount; for (let e = 0; e < t; e++) { o[e] = { mipmaps: [] }; for (let t = 0; t < n.mipmapCount; t++)o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), o[e].format = n.format, o[e].width = n.width, o[e].height = n.height } s.image = o } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps; 1 === n.mipmapCount && (s.minFilter = lt), s.format = n.format, s.needsUpdate = !0, e && e(s) }, n, i); return s } }), wl.prototype = Object.assign(Object.create(vl.prototype), { constructor: wl, load: function (t, e, n, i) { void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, o = fl.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () { e && e(o), r.manager.itemEnd(t) }, 0), o; const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function a() { s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), fl.add(t, this), e && e(this), r.manager.itemEnd(t) } function c(e) { s.removeEventListener("load", a, !1), s.removeEventListener("error", c, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) } return s.addEventListener("load", a, !1), s.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(t), s.src = t, s } }), Ml.prototype = Object.assign(Object.create(vl.prototype), { constructor: Ml, load: function (t, e, n, i) { const r = new zr, o = new wl(this.manager); o.setCrossOrigin(this.crossOrigin), o.setPath(this.path); let s = 0; function a(n) { o.load(t[n], function (t) { r.images[n] = t, 6 === ++s && (r.needsUpdate = !0, e && e(r)) }, void 0, i) } for (let e = 0; e < t.length; ++e)a(e); return r } }), Sl.prototype = Object.assign(Object.create(vl.prototype), { constructor: Sl, load: function (t, e, n, i) { const r = this, o = new Hr, s = new xl(this.manager); return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(r.withCredentials), s.load(t, function (t) { const n = r.parse(t); n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : rt, o.wrapT = void 0 !== n.wrapT ? n.wrapT : rt, o.magFilter = void 0 !== n.magFilter ? n.magFilter : lt, o.minFilter = void 0 !== n.minFilter ? n.minFilter : lt, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (o.encoding = n.encoding), void 0 !== n.flipY && (o.flipY = n.flipY), void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = ut), 1 === n.mipmapCount && (o.minFilter = lt), o.needsUpdate = !0, e && e(o, n)) }, n, i), o } }), El.prototype = Object.assign(Object.create(vl.prototype), { constructor: El, load: function (t, e, n, i) { const r = new rn, o = new wl(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function (n) { r.image = n; const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/); r.format = i ? Et : Tt, r.needsUpdate = !0, void 0 !== e && e(r) }, n, i), r } }), Object.assign(Tl.prototype, { getPoint: function () { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function (t, e) { const n = this.getUtoTmapping(t); return this.getPoint(n, e) }, getPoints: function (t = 5) { const e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return e }, getSpacedPoints: function (t = 5) { const e = []; for (let n = 0; n <= t; n++)e.push(this.getPointAt(n / t)); return e }, getLength: function () { const t = this.getLengths(); return t[t.length - 1] }, getLengths: function (t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const e = []; let n, i = this.getPoint(0), r = 0; e.push(0); for (let o = 1; o <= t; o++)r += (n = this.getPoint(o / t)).distanceTo(i), e.push(r), i = n; return this.cacheArcLengths = e, e }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (t, e) { const n = this.getLengths(); let i = 0; const r = n.length; let o; o = e || t * n[r - 1]; let s, a = 0, c = r - 1; for (; a <= c;)if ((s = n[i = Math.floor(a + (c - a) / 2)] - o) < 0) a = i + 1; else { if (!(s > 0)) { c = i; break } c = i - 1 } if (n[i = c] === o) return i / (r - 1); const l = n[i]; return (i + (o - l) / (n[i + 1] - l)) / (r - 1) }, getTangent: function (t, e) { let n = t - 1e-4, i = t + 1e-4; n < 0 && (n = 0), i > 1 && (i = 1); const r = this.getPoint(n), o = this.getPoint(i), s = e || (r.isVector2 ? new Ke : new ln); return s.copy(o).sub(r).normalize(), s }, getTangentAt: function (t, e) { const n = this.getUtoTmapping(t); return this.getTangent(n, e) }, computeFrenetFrames: function (t, e) { const n = new ln, i = [], r = [], o = [], s = new ln, a = new Bn; for (let e = 0; e <= t; e++) { const n = e / t; i[e] = this.getTangentAt(n, new ln), i[e].normalize() } r[0] = new ln, o[0] = new ln; let c = Number.MAX_VALUE; const l = Math.abs(i[0].x), h = Math.abs(i[0].y), u = Math.abs(i[0].z); l <= c && (c = l, n.set(1, 0, 0)), h <= c && (c = h, n.set(0, 1, 0)), u <= c && n.set(0, 0, 1), s.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], s), o[0].crossVectors(i[0], r[0]); for (let e = 1; e <= t; e++) { if (r[e] = r[e - 1].clone(), o[e] = o[e - 1].clone(), s.crossVectors(i[e - 1], i[e]), s.length() > Number.EPSILON) { s.normalize(); const t = Math.acos(Qe.clamp(i[e - 1].dot(i[e]), -1, 1)); r[e].applyMatrix4(a.makeRotationAxis(s, t)) } o[e].crossVectors(i[e], r[e]) } if (!0 === e) { let e = Math.acos(Qe.clamp(r[0].dot(r[t]), -1, 1)); e /= t, i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e); for (let n = 1; n <= t; n++)r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), o[n].crossVectors(i[n], r[n]) } return { tangents: i, normals: r, binormals: o } }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }, toJSON: function () { const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t }, fromJSON: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } }), Al.prototype = Object.create(Tl.prototype), Al.prototype.constructor = Al, Al.prototype.isEllipseCurve = !0, Al.prototype.getPoint = function (t, e) { const n = e || new Ke, i = 2 * Math.PI; let r = this.aEndAngle - this.aStartAngle; const o = Math.abs(r) < Number.EPSILON; for (; r < 0;)r += i; for (; r > i;)r -= i; r < Number.EPSILON && (r = o ? 0 : i), !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i); const s = this.aStartAngle + t * r; let a = this.aX + this.xRadius * Math.cos(s), c = this.aY + this.yRadius * Math.sin(s); if (0 !== this.aRotation) { const t = Math.cos(this.aRotation), e = Math.sin(this.aRotation), n = a - this.aX, i = c - this.aY; a = n * t - i * e + this.aX, c = n * e + i * t + this.aY } return n.set(a, c) }, Al.prototype.copy = function (t) { return Tl.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, Al.prototype.toJSON = function () { const t = Tl.prototype.toJSON.call(this); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t }, Al.prototype.fromJSON = function (t) { return Tl.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, Ll.prototype = Object.create(Al.prototype), Ll.prototype.constructor = Ll, Ll.prototype.isArcCurve = !0; const Pl = new ln, Cl = new Rl, Il = new Rl, Ol = new Rl; function Dl(t = [], e = !1, n = "centripetal", i = .5) { Tl.call(this), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i } function Nl(t, e, n, i, r) { const o = .5 * (i - e), s = .5 * (r - n), a = t * t; return (2 * n - 2 * i + o + s) * (t * a) + (-3 * n + 3 * i - 2 * o - s) * a + o * t + n } function zl(t, e, n, i) { return function (t, e) { const n = 1 - t; return n * n * e }(t, e) + function (t, e) { return 2 * (1 - t) * t * e }(t, n) + function (t, e) { return t * t * e }(t, i) } function Bl(t, e, n, i, r) { return function (t, e) { const n = 1 - t; return n * n * n * e }(t, e) + function (t, e) { const n = 1 - t; return 3 * n * n * t * e }(t, n) + function (t, e) { return 3 * (1 - t) * t * t * e }(t, i) + function (t, e) { return t * t * t * e }(t, r) } function Hl(t = new Ke, e = new Ke, n = new Ke, i = new Ke) { Tl.call(this), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i } function Ul(t = new ln, e = new ln, n = new ln, i = new ln) { Tl.call(this), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i } function Fl(t = new Ke, e = new Ke) { Tl.call(this), this.type = "LineCurve", this.v1 = t, this.v2 = e } function Gl(t = new ln, e = new ln) { Tl.call(this), this.type = "LineCurve3", this.v1 = t, this.v2 = e } function kl(t = new Ke, e = new Ke, n = new Ke) { Tl.call(this), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n } function Vl(t = new ln, e = new ln, n = new ln) { Tl.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n } function Wl(t = []) { Tl.call(this), this.type = "SplineCurve", this.points = t } Dl.prototype = Object.create(Tl.prototype), Dl.prototype.constructor = Dl, Dl.prototype.isCatmullRomCurve3 = !0, Dl.prototype.getPoint = function (t, e = new ln) { const n = e, i = this.points, r = i.length, o = (r - (this.closed ? 0 : 1)) * t; let s, a, c = Math.floor(o), l = o - c; this.closed ? c += c > 0 ? 0 : (Math.floor(Math.abs(c) / r) + 1) * r : 0 === l && c === r - 1 && (c = r - 2, l = 1), this.closed || c > 0 ? s = i[(c - 1) % r] : (Pl.subVectors(i[0], i[1]).add(i[0]), s = Pl); const h = i[c % r], u = i[(c + 1) % r]; if (this.closed || c + 2 < r ? a = i[(c + 2) % r] : (Pl.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), a = Pl), "centripetal" === this.curveType || "chordal" === this.curveType) { const t = "chordal" === this.curveType ? .5 : .25; let e = Math.pow(s.distanceToSquared(h), t), n = Math.pow(h.distanceToSquared(u), t), i = Math.pow(u.distanceToSquared(a), t); n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Cl.initNonuniformCatmullRom(s.x, h.x, u.x, a.x, e, n, i), Il.initNonuniformCatmullRom(s.y, h.y, u.y, a.y, e, n, i), Ol.initNonuniformCatmullRom(s.z, h.z, u.z, a.z, e, n, i) } else "catmullrom" === this.curveType && (Cl.initCatmullRom(s.x, h.x, u.x, a.x, this.tension), Il.initCatmullRom(s.y, h.y, u.y, a.y, this.tension), Ol.initCatmullRom(s.z, h.z, u.z, a.z, this.tension)); return n.set(Cl.calc(l), Il.calc(l), Ol.calc(l)), n }, Dl.prototype.copy = function (t) { Tl.prototype.copy.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push(n.clone()) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, Dl.prototype.toJSON = function () { const t = Tl.prototype.toJSON.call(this); t.points = []; for (let e = 0, n = this.points.length; e < n; e++) { const n = this.points[e]; t.points.push(n.toArray()) } return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t }, Dl.prototype.fromJSON = function (t) { Tl.prototype.fromJSON.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push((new ln).fromArray(n)) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, Hl.prototype = Object.create(Tl.prototype), Hl.prototype.constructor = Hl, Hl.prototype.isCubicBezierCurve = !0, Hl.prototype.getPoint = function (t, e = new Ke) { const n = e, i = this.v0, r = this.v1, o = this.v2, s = this.v3; return n.set(Bl(t, i.x, r.x, o.x, s.x), Bl(t, i.y, r.y, o.y, s.y)), n }, Hl.prototype.copy = function (t) { return Tl.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, Hl.prototype.toJSON = function () { const t = Tl.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, Hl.prototype.fromJSON = function (t) { return Tl.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, Ul.prototype = Object.create(Tl.prototype), Ul.prototype.constructor = Ul, Ul.prototype.isCubicBezierCurve3 = !0, Ul.prototype.getPoint = function (t, e = new ln) { const n = e, i = this.v0, r = this.v1, o = this.v2, s = this.v3; return n.set(Bl(t, i.x, r.x, o.x, s.x), Bl(t, i.y, r.y, o.y, s.y), Bl(t, i.z, r.z, o.z, s.z)), n }, Ul.prototype.copy = function (t) { return Tl.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, Ul.prototype.toJSON = function () { const t = Tl.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, Ul.prototype.fromJSON = function (t) { return Tl.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, Fl.prototype = Object.create(Tl.prototype), Fl.prototype.constructor = Fl, Fl.prototype.isLineCurve = !0, Fl.prototype.getPoint = function (t, e = new Ke) { const n = e; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }, Fl.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, Fl.prototype.getTangent = function (t, e) { const n = e || new Ke; return n.copy(this.v2).sub(this.v1).normalize(), n }, Fl.prototype.copy = function (t) { return Tl.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Fl.prototype.toJSON = function () { const t = Tl.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Fl.prototype.fromJSON = function (t) { return Tl.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, Gl.prototype = Object.create(Tl.prototype), Gl.prototype.constructor = Gl, Gl.prototype.isLineCurve3 = !0, Gl.prototype.getPoint = function (t, e = new ln) { const n = e; return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n }, Gl.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, Gl.prototype.copy = function (t) { return Tl.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Gl.prototype.toJSON = function () { const t = Tl.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Gl.prototype.fromJSON = function (t) { return Tl.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, kl.prototype = Object.create(Tl.prototype), kl.prototype.constructor = kl, kl.prototype.isQuadraticBezierCurve = !0, kl.prototype.getPoint = function (t, e = new Ke) { const n = e, i = this.v0, r = this.v1, o = this.v2; return n.set(zl(t, i.x, r.x, o.x), zl(t, i.y, r.y, o.y)), n }, kl.prototype.copy = function (t) { return Tl.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, kl.prototype.toJSON = function () { const t = Tl.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, kl.prototype.fromJSON = function (t) { return Tl.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, Vl.prototype = Object.create(Tl.prototype), Vl.prototype.constructor = Vl, Vl.prototype.isQuadraticBezierCurve3 = !0, Vl.prototype.getPoint = function (t, e = new ln) { const n = e, i = this.v0, r = this.v1, o = this.v2; return n.set(zl(t, i.x, r.x, o.x), zl(t, i.y, r.y, o.y), zl(t, i.z, r.z, o.z)), n }, Vl.prototype.copy = function (t) { return Tl.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Vl.prototype.toJSON = function () { const t = Tl.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Vl.prototype.fromJSON = function (t) { return Tl.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, Wl.prototype = Object.create(Tl.prototype), Wl.prototype.constructor = Wl, Wl.prototype.isSplineCurve = !0, Wl.prototype.getPoint = function (t, e = new Ke) { const n = e, i = this.points, r = (i.length - 1) * t, o = Math.floor(r), s = r - o, a = i[0 === o ? o : o - 1], c = i[o], l = i[o > i.length - 2 ? i.length - 1 : o + 1], h = i[o > i.length - 3 ? i.length - 1 : o + 2]; return n.set(Nl(s, a.x, c.x, l.x, h.x), Nl(s, a.y, c.y, l.y, h.y)), n }, Wl.prototype.copy = function (t) { Tl.prototype.copy.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push(n.clone()) } return this }, Wl.prototype.toJSON = function () { const t = Tl.prototype.toJSON.call(this); t.points = []; for (let e = 0, n = this.points.length; e < n; e++) { const n = this.points[e]; t.points.push(n.toArray()) } return t }, Wl.prototype.fromJSON = function (t) { Tl.prototype.fromJSON.call(this, t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { const n = t.points[e]; this.points.push((new Ke).fromArray(n)) } return this }; var jl = Object.freeze({ __proto__: null, ArcCurve: Ll, CatmullRomCurve3: Dl, CubicBezierCurve: Hl, CubicBezierCurve3: Ul, EllipseCurve: Al, LineCurve: Fl, LineCurve3: Gl, QuadraticBezierCurve: kl, QuadraticBezierCurve3: Vl, SplineCurve: Wl }); function ql() { Tl.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } function Xl(t) { ql.call(this), this.type = "Path", this.currentPoint = new Ke, t && this.setFromPoints(t) } function Yl(t) { Xl.call(this, t), this.uuid = Qe.generateUUID(), this.type = "Shape", this.holes = [] } function Zl(t, e = 1) { ci.call(this), this.type = "Light", this.color = new Pi(t), this.intensity = e } function Jl(t, e, n) { Zl.call(this, t, n), this.type = "HemisphereLight", this.position.copy(ci.DefaultUp), this.updateMatrix(), this.groundColor = new Pi(e) } function Ql(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new Ke(512, 512), this.map = null, this.mapPass = null, this.matrix = new Bn, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Gr, this._frameExtents = new Ke(1, 1), this._viewportCount = 1, this._viewports = [new sn(0, 0, 1, 1)] } function Kl() { Ql.call(this, new Ir(50, 1, .5, 500)), this.focus = 1 } function $l(t, e, n, i, r, o) { Zl.call(this, t, e), this.type = "SpotLight", this.position.copy(ci.DefaultUp), this.updateMatrix(), this.target = new ci, Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (t) { this.intensity = t / Math.PI } }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Kl } function th() { Ql.call(this, new Ir(90, 1, .5, 500)), this._frameExtents = new Ke(4, 2), this._viewportCount = 6, this._viewports = [new sn(2, 1, 1, 1), new sn(0, 1, 1, 1), new sn(3, 1, 1, 1), new sn(1, 1, 1, 1), new sn(3, 0, 1, 1), new sn(1, 0, 1, 1)], this._cubeDirections = [new ln(1, 0, 0), new ln(-1, 0, 0), new ln(0, 0, 1), new ln(0, 0, -1), new ln(0, 1, 0), new ln(0, -1, 0)], this._cubeUps = [new ln(0, 1, 0), new ln(0, 1, 0), new ln(0, 1, 0), new ln(0, 1, 0), new ln(0, 0, 1), new ln(0, 0, -1)] } function eh(t, e, n, i) { Zl.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (t) { this.intensity = t / (4 * Math.PI) } }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new th } function nh(t = -1, e = 1, n = 1, i = -1, r = .1, o = 2e3) { Cr.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = o, this.updateProjectionMatrix() } function ih() { Ql.call(this, new nh(-5, 5, 5, -5, .5, 500)) } function rh(t, e) { Zl.call(this, t, e), this.type = "DirectionalLight", this.position.copy(ci.DefaultUp), this.updateMatrix(), this.target = new ci, this.shadow = new ih } function oh(t, e) { Zl.call(this, t, e), this.type = "AmbientLight" } function sh(t, e, n, i) { Zl.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10 } ql.prototype = Object.assign(Object.create(Tl.prototype), { constructor: ql, add: function (t) { this.curves.push(t) }, closePath: function () { const t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new Fl(e, t)) }, getPoint: function (t) { const e = t * this.getLength(), n = this.getCurveLengths(); let i = 0; for (; i < n.length;) { if (n[i] >= e) { const t = n[i] - e, r = this.curves[i], o = r.getLength(), s = 0 === o ? 0 : 1 - t / o; return r.getPointAt(s) } i++ } return null }, getLength: function () { const t = this.getCurveLengths(); return t[t.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const t = []; let e = 0; for (let n = 0, i = this.curves.length; n < i; n++)e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t, t }, getSpacedPoints: function (t = 40) { const e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e }, getPoints: function (t = 12) { const e = []; let n; for (let i = 0, r = this.curves; i < r.length; i++) { const o = r[i], s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, a = o.getPoints(s); for (let t = 0; t < a.length; t++) { const i = a[t]; n && n.equals(i) || (e.push(i), n = i) } } return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e }, copy: function (t) { Tl.prototype.copy.call(this, t), this.curves = []; for (let e = 0, n = t.curves.length; e < n; e++) { const n = t.curves[e]; this.curves.push(n.clone()) } return this.autoClose = t.autoClose, this }, toJSON: function () { const t = Tl.prototype.toJSON.call(this); t.autoClose = this.autoClose, t.curves = []; for (let e = 0, n = this.curves.length; e < n; e++) { const n = this.curves[e]; t.curves.push(n.toJSON()) } return t }, fromJSON: function (t) { Tl.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = []; for (let e = 0, n = t.curves.length; e < n; e++) { const n = t.curves[e]; this.curves.push((new jl[n.type]).fromJSON(n)) } return this } }), Xl.prototype = Object.assign(Object.create(ql.prototype), { constructor: Xl, setFromPoints: function (t) { this.moveTo(t[0].x, t[0].y); for (let e = 1, n = t.length; e < n; e++)this.lineTo(t[e].x, t[e].y); return this }, moveTo: function (t, e) { return this.currentPoint.set(t, e), this }, lineTo: function (t, e) { const n = new Fl(this.currentPoint.clone(), new Ke(t, e)); return this.curves.push(n), this.currentPoint.set(t, e), this }, quadraticCurveTo: function (t, e, n, i) { const r = new kl(this.currentPoint.clone(), new Ke(t, e), new Ke(n, i)); return this.curves.push(r), this.currentPoint.set(n, i), this }, bezierCurveTo: function (t, e, n, i, r, o) { const s = new Hl(this.currentPoint.clone(), new Ke(t, e), new Ke(n, i), new Ke(r, o)); return this.curves.push(s), this.currentPoint.set(r, o), this }, splineThru: function (t) { const e = new Wl([this.currentPoint.clone()].concat(t)); return this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this }, arc: function (t, e, n, i, r, o) { const s = this.currentPoint.x, a = this.currentPoint.y; return this.absarc(t + s, e + a, n, i, r, o), this }, absarc: function (t, e, n, i, r, o) { return this.absellipse(t, e, n, n, i, r, o), this }, ellipse: function (t, e, n, i, r, o, s, a) { const c = this.currentPoint.x, l = this.currentPoint.y; return this.absellipse(t + c, e + l, n, i, r, o, s, a), this }, absellipse: function (t, e, n, i, r, o, s, a) { const c = new Al(t, e, n, i, r, o, s, a); if (this.curves.length > 0) { const t = c.getPoint(0); t.equals(this.currentPoint) || this.lineTo(t.x, t.y) } this.curves.push(c); const l = c.getPoint(1); return this.currentPoint.copy(l), this }, copy: function (t) { return ql.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this }, toJSON: function () { const t = ql.prototype.toJSON.call(this); return t.currentPoint = this.currentPoint.toArray(), t }, fromJSON: function (t) { return ql.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this } }), Yl.prototype = Object.assign(Object.create(Xl.prototype), { constructor: Yl, getPointsHoles: function (t) { const e = []; for (let n = 0, i = this.holes.length; n < i; n++)e[n] = this.holes[n].getPoints(t); return e }, extractPoints: function (t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }, copy: function (t) { Xl.prototype.copy.call(this, t), this.holes = []; for (let e = 0, n = t.holes.length; e < n; e++) { const n = t.holes[e]; this.holes.push(n.clone()) } return this }, toJSON: function () { const t = Xl.prototype.toJSON.call(this); t.uuid = this.uuid, t.holes = []; for (let e = 0, n = this.holes.length; e < n; e++) { const n = this.holes[e]; t.holes.push(n.toJSON()) } return t }, fromJSON: function (t) { Xl.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = []; for (let e = 0, n = t.holes.length; e < n; e++) { const n = t.holes[e]; this.holes.push((new Xl).fromJSON(n)) } return this } }), Zl.prototype = Object.assign(Object.create(ci.prototype), { constructor: Zl, isLight: !0, copy: function (t) { return ci.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this }, toJSON: function (t) { const e = ci.prototype.toJSON.call(this, t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e } }), Jl.prototype = Object.assign(Object.create(Zl.prototype), { constructor: Jl, isHemisphereLight: !0, copy: function (t) { return Zl.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this } }), Object.assign(Ql.prototype, { _projScreenMatrix: new Bn, _lightPositionWorld: new ln, _lookTarget: new ln, getViewportCount: function () { return this._viewportCount }, getFrustum: function () { return this._frustum }, updateMatrices: function (t) { const e = this.camera, n = this.matrix, i = this._projScreenMatrix, r = this._lookTarget, o = this._lightPositionWorld; o.setFromMatrixPosition(t.matrixWorld), e.position.copy(o), r.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(r), e.updateMatrixWorld(), i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(i), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse) }, getViewport: function (t) { return this._viewports[t] }, getFrameExtents: function () { return this._frameExtents }, copy: function (t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { const t = {}; return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } }), Kl.prototype = Object.assign(Object.create(Ql.prototype), { constructor: Kl, isSpotLightShadow: !0, updateMatrices: function (t) { const e = this.camera, n = 2 * Qe.RAD2DEG * t.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = t.distance || e.far; n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), Ql.prototype.updateMatrices.call(this, t) } }), $l.prototype = Object.assign(Object.create(Zl.prototype), { constructor: $l, isSpotLight: !0, copy: function (t) { return Zl.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), th.prototype = Object.assign(Object.create(Ql.prototype), { constructor: th, isPointLightShadow: !0, updateMatrices: function (t, e = 0) { const n = this.camera, i = this.matrix, r = this._lightPositionWorld, o = this._lookTarget, s = this._projScreenMatrix; r.setFromMatrixPosition(t.matrixWorld), n.position.copy(r), o.copy(n.position), o.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(o), n.updateMatrixWorld(), i.makeTranslation(-r.x, -r.y, -r.z), s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(s) } }), eh.prototype = Object.assign(Object.create(Zl.prototype), { constructor: eh, isPointLight: !0, copy: function (t) { return Zl.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }), nh.prototype = Object.assign(Object.create(Cr.prototype), { constructor: nh, isOrthographicCamera: !0, copy: function (t, e) { return Cr.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }, setViewOffset: function (t, e, n, i, r, o) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2; let r = n - t, o = n + t, s = i + e, a = i - e; if (null !== this.view && this.view.enabled) { const t = (this.right - this.left) / this.view.fullWidth / this.zoom, e = (this.top - this.bottom) / this.view.fullHeight / this.zoom; o = (r += t * this.view.offsetX) + t * this.view.width, a = (s -= e * this.view.offsetY) - e * this.view.height } this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() }, toJSON: function (t) { const e = ci.prototype.toJSON.call(this, t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e } }), ih.prototype = Object.assign(Object.create(Ql.prototype), { constructor: ih, isDirectionalLightShadow: !0, updateMatrices: function (t) { Ql.prototype.updateMatrices.call(this, t) } }), rh.prototype = Object.assign(Object.create(Zl.prototype), { constructor: rh, isDirectionalLight: !0, copy: function (t) { return Zl.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), oh.prototype = Object.assign(Object.create(Zl.prototype), { constructor: oh, isAmbientLight: !0 }), sh.prototype = Object.assign(Object.create(Zl.prototype), { constructor: sh, isRectAreaLight: !0, copy: function (t) { return Zl.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this }, toJSON: function (t) { const e = Zl.prototype.toJSON.call(this, t); return e.object.width = this.width, e.object.height = this.height, e } }); class ah { constructor() { Object.defineProperty(this, "isSphericalHarmonics3", { value: !0 }), this.coefficients = []; for (let t = 0; t < 9; t++)this.coefficients.push(new ln) } set(t) { for (let e = 0; e < 9; e++)this.coefficients[e].copy(t[e]); return this } zero() { for (let t = 0; t < 9; t++)this.coefficients[t].set(0, 0, 0); return this } getAt(t, e) { const n = t.x, i = t.y, r = t.z, o = this.coefficients; return e.copy(o[0]).multiplyScalar(.282095), e.addScaledVector(o[1], .488603 * i), e.addScaledVector(o[2], .488603 * r), e.addScaledVector(o[3], .488603 * n), e.addScaledVector(o[4], n * i * 1.092548), e.addScaledVector(o[5], i * r * 1.092548), e.addScaledVector(o[6], .315392 * (3 * r * r - 1)), e.addScaledVector(o[7], n * r * 1.092548), e.addScaledVector(o[8], .546274 * (n * n - i * i)), e } getIrradianceAt(t, e) { const n = t.x, i = t.y, r = t.z, o = this.coefficients; return e.copy(o[0]).multiplyScalar(.886227), e.addScaledVector(o[1], 1.023328 * i), e.addScaledVector(o[2], 1.023328 * r), e.addScaledVector(o[3], 1.023328 * n), e.addScaledVector(o[4], .858086 * n * i), e.addScaledVector(o[5], .858086 * i * r), e.addScaledVector(o[6], .743125 * r * r - .247708), e.addScaledVector(o[7], .858086 * n * r), e.addScaledVector(o[8], .429043 * (n * n - i * i)), e } add(t) { for (let e = 0; e < 9; e++)this.coefficients[e].add(t.coefficients[e]); return this } addScaledSH(t, e) { for (let n = 0; n < 9; n++)this.coefficients[n].addScaledVector(t.coefficients[n], e); return this } scale(t) { for (let e = 0; e < 9; e++)this.coefficients[e].multiplyScalar(t); return this } lerp(t, e) { for (let n = 0; n < 9; n++)this.coefficients[n].lerp(t.coefficients[n], e); return this } equals(t) { for (let e = 0; e < 9; e++)if (!this.coefficients[e].equals(t.coefficients[e])) return !1; return !0 } copy(t) { return this.set(t.coefficients) } clone() { return (new this.constructor).copy(this) } fromArray(t, e = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++)n[i].fromArray(t, e + 3 * i); return this } toArray(t = [], e = 0) { const n = this.coefficients; for (let i = 0; i < 9; i++)n[i].toArray(t, e + 3 * i); return t } static getBasisAt(t, e) { const n = t.x, i = t.y, r = t.z; e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i) } } function ch(t, e) { Zl.call(this, void 0, e), this.type = "LightProbe", this.sh = void 0 !== t ? t : new ah } function lh(t) { vl.call(this, t), this.textures = {} } ch.prototype = Object.assign(Object.create(Zl.prototype), { constructor: ch, isLightProbe: !0, copy: function (t) { return Zl.prototype.copy.call(this, t), this.sh.copy(t.sh), this }, fromJSON: function (t) { return this.intensity = t.intensity, this.sh.fromArray(t.sh), this }, toJSON: function (t) { const e = Zl.prototype.toJSON.call(this, t); return e.object.sh = this.sh.toArray(), e } }), lh.prototype = Object.assign(Object.create(vl.prototype), { constructor: lh, load: function (t, e, n, i) { const r = this, o = new xl(r.manager); o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, function (n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }, n, i) }, parse: function (t) { const e = this.textures; function n(t) { return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t] } const i = new Kc[t.type]; if (void 0 !== t.uuid && (i.uuid = t.uuid), void 0 !== t.name && (i.name = t.name), void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color), void 0 !== t.roughness && (i.roughness = t.roughness), void 0 !== t.metalness && (i.metalness = t.metalness), void 0 !== t.sheen && (i.sheen = (new Pi).setHex(t.sheen)), void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular), void 0 !== t.shininess && (i.shininess = t.shininess), void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (i.fog = t.fog), void 0 !== t.flatShading && (i.flatShading = t.flatShading), void 0 !== t.blending && (i.blending = t.blending), void 0 !== t.combine && (i.combine = t.combine), void 0 !== t.side && (i.side = t.side), void 0 !== t.opacity && (i.opacity = t.opacity), void 0 !== t.transparent && (i.transparent = t.transparent), void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest), void 0 !== t.depthTest && (i.depthTest = t.depthTest), void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (i.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (i.rotation = t.rotation), 1 !== t.linewidth && (i.linewidth = t.linewidth), void 0 !== t.dashSize && (i.dashSize = t.dashSize), void 0 !== t.gapSize && (i.gapSize = t.gapSize), void 0 !== t.scale && (i.scale = t.scale), void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (i.skinning = t.skinning), void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals), void 0 !== t.dithering && (i.dithering = t.dithering), void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors), void 0 !== t.uniforms) for (const e in t.uniforms) { const r = t.uniforms[e]; switch (i.uniforms[e] = {}, r.type) { case "t": i.uniforms[e].value = n(r.value); break; case "c": i.uniforms[e].value = (new Pi).setHex(r.value); break; case "v2": i.uniforms[e].value = (new Ke).fromArray(r.value); break; case "v3": i.uniforms[e].value = (new ln).fromArray(r.value); break; case "v4": i.uniforms[e].value = (new sn).fromArray(r.value); break; case "m3": i.uniforms[e].value = (new $e).fromArray(r.value); break; case "m4": i.uniforms[e].value = (new Bn).fromArray(r.value); break; default: i.uniforms[e].value = r.value } } if (void 0 !== t.defines && (i.defines = t.defines), void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (const e in t.extensions) i.extensions[e] = t.extensions[e]; if (void 0 !== t.shading && (i.flatShading = 1 === t.shading), void 0 !== t.size && (i.size = t.size), void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (i.map = n(t.map)), void 0 !== t.matcap && (i.matcap = n(t.matcap)), void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale), void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType), void 0 !== t.normalScale) { let e = t.normalScale; !1 === Array.isArray(e) && (e = [e, e]), i.normalScale = (new Ke).fromArray(e) } return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)), void 0 !== t.envMap && (i.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new Ke).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (i.transmission = t.transmission), void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)), i }, setTextures: function (t) { return this.textures = t, this } }); const hh = { decodeText: function (t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); let e = ""; for (let n = 0, i = t.length; n < i; n++)e += String.fromCharCode(t[n]); try { return decodeURIComponent(escape(e)) } catch (t) { return e } }, extractUrlBase: function (t) { const e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) } }; function uh() { rr.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } function dh(t, e, n, i) { "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Bi.call(this, t, e, n), this.meshPerAttribute = i || 1 } function ph(t) { vl.call(this, t) } uh.prototype = Object.assign(Object.create(rr.prototype), { constructor: uh, isInstancedBufferGeometry: !0, copy: function (t) { return rr.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { const t = rr.prototype.toJSON.call(this); return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t } }), dh.prototype = Object.assign(Object.create(Bi.prototype), { constructor: dh, isInstancedBufferAttribute: !0, copy: function (t) { return Bi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, toJSON: function () { const t = Bi.prototype.toJSON.call(this); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t } }), ph.prototype = Object.assign(Object.create(vl.prototype), { constructor: ph, load: function (t, e, n, i) { const r = this, o = new xl(r.manager); o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, function (n) { try { e(r.parse(JSON.parse(n))) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }, n, i) }, parse: function (t) { const e = {}, n = {}; function i(t, i) { if (void 0 !== e[i]) return e[i]; const r = t.interleavedBuffers[i], o = function (t, e) { if (void 0 !== n[e]) return n[e]; const i = t.arrayBuffers[e], r = new Uint32Array(i).buffer; return n[e] = r, r }(t, r.buffer), s = new ea(Ji(r.type, o), r.stride); return s.uuid = r.uuid, e[i] = s, s } const r = t.isInstancedBufferGeometry ? new uh : new rr, o = t.data.index; if (void 0 !== o) { const t = Ji(o.type, o.array); r.setIndex(new Bi(t, 1)) } const s = t.data.attributes; for (const e in s) { const n = s[e]; let o; if (n.isInterleavedBufferAttribute) { o = new ia(i(t.data, n.data), n.itemSize, n.offset, n.normalized) } else { const t = Ji(n.type, n.array); o = new (n.isInstancedBufferAttribute ? dh : Bi)(t, n.itemSize, n.normalized) } void 0 !== n.name && (o.name = n.name), r.setAttribute(e, o) } const a = t.data.morphAttributes; if (a) for (const e in a) { const n = a[e], o = []; for (let e = 0, r = n.length; e < r; e++) { const r = n[e]; let s; if (r.isInterleavedBufferAttribute) { s = new ia(i(t.data, r.data), r.itemSize, r.offset, r.normalized) } else { s = new Bi(Ji(r.type, r.array), r.itemSize, r.normalized) } void 0 !== r.name && (s.name = r.name), o.push(s) } r.morphAttributes[e] = o } t.data.morphTargetsRelative && (r.morphTargetsRelative = !0); const c = t.data.groups || t.data.drawcalls || t.data.offsets; if (void 0 !== c) for (let t = 0, e = c.length; t !== e; ++t) { const e = c[t]; r.addGroup(e.start, e.count, e.materialIndex) } const l = t.data.boundingSphere; if (void 0 !== l) { const t = new ln; void 0 !== l.center && t.fromArray(l.center), r.boundingSphere = new Ln(t, l.radius) } return t.name && (r.name = t.name), t.userData && (r.userData = t.userData), r } }); function fh(t) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), vl.call(this, t), this.options = { premultiplyAlpha: "none" } } function mh() { this.type = "ShapePath", this.color = new Pi, this.subPaths = [], this.currentPath = null } fh.prototype = Object.assign(Object.create(vl.prototype), { constructor: fh, isImageBitmapLoader: !0, setOptions: function (t) { return this.options = t, this }, load: function (t, e, n, i) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const r = this, o = fl.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function () { e && e(o), r.manager.itemEnd(t) }, 0), o; const s = {}; s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", fetch(t, s).then(function (t) { return t.blob() }).then(function (t) { return createImageBitmap(t, r.options) }).then(function (n) { fl.add(t, n), e && e(n), r.manager.itemEnd(t) }).catch(function (e) { i && i(e), r.manager.itemError(t), r.manager.itemEnd(t) }), r.manager.itemStart(t) } }), Object.assign(mh.prototype, { moveTo: function (t, e) { return this.currentPath = new Xl, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this }, lineTo: function (t, e) { return this.currentPath.lineTo(t, e), this }, quadraticCurveTo: function (t, e, n, i) { return this.currentPath.quadraticCurveTo(t, e, n, i), this }, bezierCurveTo: function (t, e, n, i, r, o) { return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this }, splineThru: function (t) { return this.currentPath.splineThru(t), this }, toShapes: function (t, e) { function n(t) { const e = []; for (let n = 0, i = t.length; n < i; n++) { const i = t[n], r = new Yl; r.curves = i.curves, e.push(r) } return e } function i(t, e) { const n = e.length; let i = !1; for (let r = n - 1, o = 0; o < n; r = o++) { let n = e[r], s = e[o], a = s.x - n.x, c = s.y - n.y; if (Math.abs(c) > Number.EPSILON) { if (c < 0 && (n = e[o], a = -a, s = e[r], c = -c), t.y < n.y || t.y > s.y) continue; if (t.y === n.y) { if (t.x === n.x) return !0 } else { const e = c * (t.x - n.x) - a * (t.y - n.y); if (0 === e) return !0; if (e < 0) continue; i = !i } } else { if (t.y !== n.y) continue; if (s.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= s.x) return !0 } } return i } const r = Ic.isClockWise, o = this.subPaths; if (0 === o.length) return []; if (!0 === e) return n(o); let s, a, c; const l = []; if (1 === o.length) return a = o[0], (c = new Yl).curves = a.curves, l.push(c), l; let h = !r(o[0].getPoints()); h = t ? !h : h; const u = [], d = []; let p, f, m = [], g = 0; d[g] = void 0, m[g] = []; for (let e = 0, n = o.length; e < n; e++)s = r(p = (a = o[e]).getPoints()), (s = t ? !s : s) ? (!h && d[g] && g++, d[g] = { s: new Yl, p: p }, d[g].s.curves = a.curves, h && g++, m[g] = []) : m[g].push({ h: a, p: p[0] }); if (!d[0]) return n(o); if (d.length > 1) { let t = !1; const e = []; for (let t = 0, e = d.length; t < e; t++)u[t] = []; for (let n = 0, r = d.length; n < r; n++) { const r = m[n]; for (let o = 0; o < r.length; o++) { const s = r[o]; let a = !0; for (let r = 0; r < d.length; r++)i(s.p, d[r].p) && (n !== r && e.push({ froms: n, tos: r, hole: o }), a ? (a = !1, u[r].push(s)) : t = !0); a && u[n].push(s) } } e.length > 0 && (t || (m = u)) } for (let t = 0, e = d.length; t < e; t++) { c = d[t].s, l.push(c); for (let e = 0, n = (f = m[t]).length; e < n; e++)c.holes.push(f[e].h) } return l } }); class gh { constructor(t) { Object.defineProperty(this, "isFont", { value: !0 }), this.type = "Font", this.data = t } generateShapes(t, e = 100) { const n = [], i = function (t, e, n) { const i = Array.from ? Array.from(t) : String(t).split(""), r = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, s = []; let a = 0, c = 0; for (let t = 0; t < i.length; t++) { const e = i[t]; if ("\n" === e) a = 0, c -= o; else { const t = vh(e, r, a, c, n); a += t.offsetX, s.push(t.path) } } return s }(t, e, this.data); for (let t = 0, e = i.length; t < e; t++)Array.prototype.push.apply(n, i[t].toShapes()); return n } } function vh(t, e, n, i, r) { const o = r.glyphs[t] || r.glyphs["?"]; if (!o) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + "."); const s = new mh; let a, c, l, h, u, d, p, f; if (o.o) { const t = o._cachedOutline || (o._cachedOutline = o.o.split(" ")); for (let r = 0, o = t.length; r < o;) { switch (t[r++]) { case "m": a = t[r++] * e + n, c = t[r++] * e + i, s.moveTo(a, c); break; case "l": a = t[r++] * e + n, c = t[r++] * e + i, s.lineTo(a, c); break; case "q": l = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, d = t[r++] * e + i, s.quadraticCurveTo(u, d, l, h); break; case "b": l = t[r++] * e + n, h = t[r++] * e + i, u = t[r++] * e + n, d = t[r++] * e + i, p = t[r++] * e + n, f = t[r++] * e + i, s.bezierCurveTo(u, d, p, f, l, h) } } } return { offsetX: o.ha * e, path: s } } function yh(t) { vl.call(this, t) } let xh; yh.prototype = Object.assign(Object.create(vl.prototype), { constructor: yh, load: function (t, e, n, i) { const r = this, o = new xl(this.manager); o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, function (t) { let n; try { n = JSON.parse(t) } catch (e) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2)) } const i = r.parse(n); e && e(i) }, n, i) }, parse: function (t) { return new gh(t) } }); const _h = { getContext: function () { return void 0 === xh && (xh = new (window.AudioContext || window.webkitAudioContext)), xh }, setContext: function (t) { xh = t } }; function bh(t) { vl.call(this, t) } function wh(t, e, n) { ch.call(this, void 0, n); const i = (new Pi).set(t), r = (new Pi).set(e), o = new ln(i.r, i.g, i.b), s = new ln(r.r, r.g, r.b), a = Math.sqrt(Math.PI), c = a * Math.sqrt(.75); this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a), this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c) } function Mh(t, e) { ch.call(this, void 0, e); const n = (new Pi).set(t); this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } bh.prototype = Object.assign(Object.create(vl.prototype), { constructor: bh, load: function (t, e, n, i) { const r = this, o = new xl(r.manager); o.setResponseType("arraybuffer"), o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(t, function (n) { try { const o = n.slice(0); _h.getContext().decodeAudioData(o, function (t) { e(t) }) } catch (e) { i ? i(e) : console.error(e), r.manager.itemError(t) } }, n, i) } }), wh.prototype = Object.assign(Object.create(ch.prototype), { constructor: wh, isHemisphereLightProbe: !0, copy: function (t) { return ch.prototype.copy.call(this, t), this }, toJSON: function (t) { return ch.prototype.toJSON.call(this, t) } }), Mh.prototype = Object.assign(Object.create(ch.prototype), { constructor: Mh, isAmbientLightProbe: !0, copy: function (t) { return ch.prototype.copy.call(this, t), this }, toJSON: function (t) { return ch.prototype.toJSON.call(this, t) } }); const Sh = new Bn, Eh = new Bn; Object.assign(function () { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Ir, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ir, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } }.prototype, { update: function (t) { const e = this._cache; if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) { e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep; const n = t.projectionMatrix.clone(), i = e.eyeSep / 2, r = i * e.near / e.focus, o = e.near * Math.tan(Qe.DEG2RAD * e.fov * .5) / e.zoom; let s, a; Eh.elements[12] = -i, Sh.elements[12] = i, s = -o * e.aspect + r, a = o * e.aspect + r, n.elements[0] = 2 * e.near / (a - s), n.elements[8] = (a + s) / (a - s), this.cameraL.projectionMatrix.copy(n), s = -o * e.aspect - r, a = o * e.aspect - r, n.elements[0] = 2 * e.near / (a - s), n.elements[8] = (a + s) / (a - s), this.cameraR.projectionMatrix.copy(n) } this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Eh), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Sh) } }); class Th extends ci { constructor(t) { super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this } setMediaElementSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this } setMediaStreamSource(t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this } setBuffer(t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this } play(t = 0) { if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing."); if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control."); this._startedAt = this.context.currentTime + t; const e = this.context.createBufferSource(); return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } pause() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") } stop() { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") } connect() { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (let t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].connect(this.filters[t]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (let t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].disconnect(this.filters[t]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(t) { return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this } setDetune(t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(t) { return this.setFilters(t ? [t] : []) } setPlaybackRate(t) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(t) { if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") } setLoopStart(t) { return this.loopStart = t, this } setLoopEnd(t) { return this.loopEnd = t, this } getVolume() { return this.gain.gain.value } setVolume(t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this } } function Ah(t, e, n) { let i, r, o; switch (this.binding = t, this.valueSize = n, e) { case "quaternion": i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5; break; case "string": case "bool": i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n); break; default: i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n) }this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } Object.assign(Ah.prototype, { accumulate: function (t, e) { const n = this.buffer, i = this.valueSize, r = t * i + i; let o = this.cumulativeWeight; if (0 === o) { for (let t = 0; t !== i; ++t)n[r + t] = n[t]; o = e } else { const t = e / (o += e); this._mixBufferRegion(n, r, 0, t, i) } this.cumulativeWeight = o }, accumulateAdditive: function (t) { const e = this.buffer, n = this.valueSize, i = n * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t }, apply: function (t) { const e = this.valueSize, n = this.buffer, i = t * e + e, r = this.cumulativeWeight, o = this.cumulativeWeightAdditive, s = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) { const t = e * this._origIndex; this._mixBufferRegion(n, i, t, 1 - r, e) } o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e); for (let t = e, r = e + e; t !== r; ++t)if (n[t] !== n[t + e]) { s.setValue(n, i); break } }, saveOriginalState: function () { const t = this.binding, e = this.buffer, n = this.valueSize, i = n * this._origIndex; t.getValue(e, i); for (let t = n, r = i; t !== r; ++t)e[t] = e[i + t % n]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 }, restoreOriginalState: function () { const t = 3 * this.valueSize; this.binding.setValue(this.buffer, t) }, _setAdditiveIdentityNumeric: function () { const t = this._addIndex * this.valueSize, e = t + this.valueSize; for (let n = t; n < e; n++)this.buffer[n] = 0 }, _setAdditiveIdentityQuaternion: function () { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 }, _setAdditiveIdentityOther: function () { const t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize; for (let n = 0; n < this.valueSize; n++)this.buffer[e + n] = this.buffer[t + n] }, _select: function (t, e, n, i, r) { if (i >= .5) for (let i = 0; i !== r; ++i)t[e + i] = t[n + i] }, _slerp: function (t, e, n, i) { cn.slerpFlat(t, e, t, e, t, n, i) }, _slerpAdditive: function (t, e, n, i, r) { const o = this._workIndex * r; cn.multiplyQuaternionsFlat(t, o, t, e, t, n), cn.slerpFlat(t, e, t, e, t, o, i) }, _lerp: function (t, e, n, i, r) { const o = 1 - i; for (let s = 0; s !== r; ++s) { const r = e + s; t[r] = t[r] * o + t[n + s] * i } }, _lerpAdditive: function (t, e, n, i, r) { for (let o = 0; o !== r; ++o) { const r = e + o; t[r] = t[r] + t[n + o] * i } } }); const Lh = new RegExp("[\\[\\]\\.:\\/]", "g"), Rh = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Ph = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Ch = /(WCOD+)?/.source.replace("WCOD", Rh), Ih = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Oh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Dh = new RegExp("^" + Ph + Ch + Ih + Oh + "$"), Nh = ["material", "materials", "bones"]; function zh(t, e, n) { const i = n || Bh.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, i) } function Bh(t, e, n) { this.path = e, this.parsedPath = n || Bh.parseTrackName(e), this.node = Bh.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t } Object.assign(zh.prototype, { getValue: function (t, e) { this.bind(); const n = this._targetGroup.nCachedObjects_, i = this._bindings[n]; void 0 !== i && i.getValue(t, e) }, setValue: function (t, e) { const n = this._bindings; for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)n[i].setValue(t, e) }, bind: function () { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind() }, unbind: function () { const t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind() } }), Object.assign(Bh, { Composite: zh, create: function (t, e, n) { return t && t.isAnimationObjectGroup ? new Bh.Composite(t, e, n) : new Bh(t, e, n) }, sanitizeNodeName: function (t) { return t.replace(/\s/g, "_").replace(Lh, "") }, parseTrackName: function (t) { const e = Dh.exec(t); if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t); const n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, i = n.nodeName && n.nodeName.lastIndexOf("."); if (void 0 !== i && -1 !== i) { const t = n.nodeName.substring(i + 1); -1 !== Nh.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t) } if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t); return n }, findNode: function (t, e) { if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t; if (t.skeleton) { const n = t.skeleton.getBoneByName(e); if (void 0 !== n) return n } if (t.children) { const n = function (t) { for (let i = 0; i < t.length; i++) { const r = t[i]; if (r.name === e || r.uuid === e) return r; const o = n(r.children); if (o) return o } return null }, i = n(t.children); if (i) return i } return null } }), Object.assign(Bh.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (t, e) { t[e] = this.node[this.propertyName] }, function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)t[e++] = n[i] }, function (t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }, function (t, e) { this.resolvedProperty.toArray(t, e) }], SetterByBindingTypeAndVersioning: [[function (t, e) { this.targetObject[this.propertyName] = t[e] }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++] }, function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.needsUpdate = !0 }, function (t, e) { const n = this.resolvedProperty; for (let i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty.fromArray(t, e) }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (t, e) { this.bind(), this.getValue(t, e) }, setValue: function (t, e) { this.bind(), this.setValue(t, e) }, bind: function () { let t = this.node; const e = this.parsedPath, n = e.objectName, i = e.propertyName; let r = e.propertyIndex; if (t || (t = Bh.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); if (n) { let i = e.objectIndex; switch (n) { case "materials": if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); t = t.material.materials; break; case "bones": if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); t = t.skeleton.bones; for (let e = 0; e < t.length; e++)if (t[e].name === i) { i = e; break } break; default: if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); t = t[n] }if (void 0 !== i) { if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t); t = t[i] } } const o = t[i]; if (void 0 === o) { const n = e.nodeName; return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t) } let s = this.Versioning.None; this.targetObject = t, void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate); let a = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === i) { if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r]) } a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i; this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s] }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign(Bh.prototype, { _getValue_unbound: Bh.prototype.getValue, _setValue_unbound: Bh.prototype.setValue }), Object.assign(function () { this.uuid = Qe.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const t = {}; this._indicesByUUID = t; for (let e = 0, n = arguments.length; e !== n; ++e)t[arguments[e].uuid] = e; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const e = this; this.stats = { objects: { get total() { return e._objects.length }, get inUse() { return this.total - e.nCachedObjects_ } }, get bindingsPerObject() { return e._bindings.length } } }.prototype, { isAnimationObjectGroup: !0, add: function () { const t = this._objects, e = this._indicesByUUID, n = this._paths, i = this._parsedPaths, r = this._bindings, o = r.length; let s = void 0, a = t.length, c = this.nCachedObjects_; for (let l = 0, h = arguments.length; l !== h; ++l) { const h = arguments[l], u = h.uuid; let d = e[u]; if (void 0 === d) { d = a++, e[u] = d, t.push(h); for (let t = 0, e = o; t !== e; ++t)r[t].push(new Bh(h, n[t], i[t])) } else if (d < c) { s = t[d]; const a = --c, l = t[a]; e[l.uuid] = d, t[d] = l, e[u] = a, t[a] = h; for (let t = 0, e = o; t !== e; ++t) { const e = r[t], o = e[a]; let s = e[d]; e[d] = o, void 0 === s && (s = new Bh(h, n[t], i[t])), e[a] = s } } else t[d] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = c }, remove: function () { const t = this._objects, e = this._indicesByUUID, n = this._bindings, i = n.length; let r = this.nCachedObjects_; for (let o = 0, s = arguments.length; o !== s; ++o) { const s = arguments[o], a = s.uuid, c = e[a]; if (void 0 !== c && c >= r) { const o = r++, l = t[o]; e[l.uuid] = c, t[c] = l, e[a] = o, t[o] = s; for (let t = 0, e = i; t !== e; ++t) { const e = n[t], i = e[o], r = e[c]; e[c] = i, e[o] = r } } } this.nCachedObjects_ = r }, uncache: function () { const t = this._objects, e = this._indicesByUUID, n = this._bindings, i = n.length; let r = this.nCachedObjects_, o = t.length; for (let s = 0, a = arguments.length; s !== a; ++s) { const a = arguments[s].uuid, c = e[a]; if (void 0 !== c) if (delete e[a], c < r) { const s = --r, a = t[s], l = --o, h = t[l]; e[a.uuid] = c, t[c] = a, e[h.uuid] = s, t[s] = h, t.pop(); for (let t = 0, e = i; t !== e; ++t) { const e = n[t], i = e[s], r = e[l]; e[c] = i, e[s] = r, e.pop() } } else { const r = --o, s = t[r]; r > 0 && (e[s.uuid] = c), t[c] = s, t.pop(); for (let t = 0, e = i; t !== e; ++t) { const e = n[t]; e[c] = e[r], e.pop() } } } this.nCachedObjects_ = r }, subscribe_: function (t, e) { const n = this._bindingsIndicesByPath; let i = n[t]; const r = this._bindings; if (void 0 !== i) return r[i]; const o = this._paths, s = this._parsedPaths, a = this._objects, c = a.length, l = this.nCachedObjects_, h = new Array(c); i = r.length, n[t] = i, o.push(t), s.push(e), r.push(h); for (let n = l, i = a.length; n !== i; ++n) { const i = a[n]; h[n] = new Bh(i, t, e) } return h }, unsubscribe_: function (t) { const e = this._bindingsIndicesByPath, n = e[t]; if (void 0 !== n) { const i = this._paths, r = this._parsedPaths, o = this._bindings, s = o.length - 1, a = o[s]; e[t[s]] = n, o[n] = a, o.pop(), r[n] = r[s], r.pop(), i[n] = i[s], i.pop() } } }); class Hh { constructor(t, e, n = null, i = e.blendMode) { this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i; const r = e.tracks, o = r.length, s = new Array(o), a = { endingStart: Te, endingEnd: Te }; for (let t = 0; t !== o; ++t) { const e = r[t].createInterpolant(null); s[t] = e, e.settings = a } this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Se, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(t) { return this._startTime = t, this } setLoop(t, e) { return this.loop = t, this.repetitions = e, this } setEffectiveWeight(t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(t) { return this._scheduleFading(t, 0, 1) } fadeOut(t) { return this._scheduleFading(t, 1, 0) } crossFadeFrom(t, e, n) { if (t.fadeOut(e), this.fadeIn(e), n) { const n = this._clip.duration, i = t._clip.duration, r = i / n, o = n / i; t.warp(1, r, e), this.warp(o, 1, e) } return this } crossFadeTo(t, e, n) { return t.crossFadeFrom(this, e, n) } stopFading() { const t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this } setEffectiveTimeScale(t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(t) { return this.timeScale = this._clip.duration / t, this.stopWarping() } syncWith(t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() } halt(t) { return this.warp(this._effectiveTimeScale, 0, t) } warp(t, e, n) { const i = this._mixer, r = i.time, o = this.timeScale; let s = this._timeScaleInterpolant; null === s && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s); const a = s.parameterPositions, c = s.sampleValues; return a[0] = r, a[1] = r + n, c[0] = t / o, c[1] = e / o, this } stopWarping() { const t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(t, e, n, i) { if (!this.enabled) return void this._updateWeight(t); const r = this._startTime; if (null !== r) { const i = (t - r) * n; if (i < 0 || 0 === n) return; this._startTime = null, e = n * i } e *= this._updateTimeScale(t); const o = this._updateTime(e), s = this._updateWeight(t); if (s > 0) { const t = this._interpolants, e = this._propertyBindings; switch (this.blendMode) { case Pe: for (let n = 0, i = t.length; n !== i; ++n)t[n].evaluate(o), e[n].accumulateAdditive(s); break; case Re: default: for (let n = 0, r = t.length; n !== r; ++n)t[n].evaluate(o), e[n].accumulate(i, s) } } } _updateWeight(t) { let e = 0; if (this.enabled) { e = this.weight; const n = this._weightInterpolant; if (null !== n) { const i = n.evaluate(t)[0]; e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1)) } } return this._effectiveWeight = e, e } _updateTimeScale(t) { let e = 0; if (!this.paused) { e = this.timeScale; const n = this._timeScaleInterpolant; if (null !== n) { e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e) } } return this._effectiveTimeScale = e, e } _updateTime(t) { const e = this._clip.duration, n = this.loop; let i = this.time + t, r = this._loopCount; const o = n === Ee; if (0 === t) return -1 === r ? i : o && 1 == (1 & r) ? e - i : i; if (n === Me) { -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)); t: { if (i >= e) i = e; else { if (!(i < 0)) { this.time = i; break t } i = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 }) } } else { if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), i >= e || i < 0) { const n = Math.floor(i / e); i -= e * n, r += Math.abs(n); const s = this.repetitions - r; if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 }); else { if (1 === s) { const e = t < 0; this._setEndings(e, !e, o) } else this._setEndings(!1, !1, o); this._loopCount = r, this.time = i, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n }) } } else this.time = i; if (o && 1 == (1 & r)) return e - i } return i } _setEndings(t, e, n) { const i = this._interpolantSettings; n ? (i.endingStart = Ae, i.endingEnd = Ae) : (i.endingStart = t ? this.zeroSlopeAtStart ? Ae : Te : Le, i.endingEnd = e ? this.zeroSlopeAtEnd ? Ae : Te : Le) } _scheduleFading(t, e, n) { const i = this._mixer, r = i.time; let o = this._weightInterpolant; null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o); const s = o.parameterPositions, a = o.sampleValues; return s[0] = r, a[0] = e, s[1] = r + t, a[1] = n, this } } function Uh(t) { this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } Uh.prototype = Object.assign(Object.create(Ye.prototype), { constructor: Uh, _bindAction: function (t, e) { const n = t._localRoot || this._root, i = t._clip.tracks, r = i.length, o = t._propertyBindings, s = t._interpolants, a = n.uuid, c = this._bindingsByRootAndName; let l = c[a]; void 0 === l && (l = {}, c[a] = l); for (let t = 0; t !== r; ++t) { const r = i[t], c = r.name; let h = l[c]; if (void 0 !== h) o[t] = h; else { if (void 0 !== (h = o[t])) { null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, a, c)); continue } const i = e && e._propertyBindings[t].binding.parsedPath; ++(h = new Ah(Bh.create(n, c, i), r.ValueTypeName, r.getValueSize())).referenceCount, this._addInactiveBinding(h, a, c), o[t] = h } s[t].resultBuffer = h.buffer } }, _activateAction: function (t) { if (!this._isActiveAction(t)) { if (null === t._cacheIndex) { const e = (t._localRoot || this._root).uuid, n = t._clip.uuid, i = this._actionsByClip[n]; this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e) } const e = t._propertyBindings; for (let t = 0, n = e.length; t !== n; ++t) { const n = e[t]; 0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState()) } this._lendAction(t) } }, _deactivateAction: function (t) { if (this._isActiveAction(t)) { const e = t._propertyBindings; for (let t = 0, n = e.length; t !== n; ++t) { const n = e[t]; 0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n)) } this._takeBackAction(t) } }, _initMemoryManager: function () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const t = this; this.stats = { actions: { get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: { get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: { get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } } }, _isActiveAction: function (t) { const e = t._cacheIndex; return null !== e && e < this._nActiveActions }, _addInactiveAction: function (t, e, n) { const i = this._actions, r = this._actionsByClip; let o = r[e]; if (void 0 === o) o = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, r[e] = o; else { const e = o.knownActions; t._byClipCacheIndex = e.length, e.push(t) } t._cacheIndex = i.length, i.push(t), o.actionByRoot[n] = t }, _removeInactiveAction: function (t) { const e = this._actions, n = e[e.length - 1], i = t._cacheIndex; n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null; const r = t._clip.uuid, o = this._actionsByClip, s = o[r], a = s.knownActions, c = a[a.length - 1], l = t._byClipCacheIndex; c._byClipCacheIndex = l, a[l] = c, a.pop(), t._byClipCacheIndex = null, delete s.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete o[r], this._removeInactiveBindingsForAction(t) }, _removeInactiveBindingsForAction: function (t) { const e = t._propertyBindings; for (let t = 0, n = e.length; t !== n; ++t) { const n = e[t]; 0 == --n.referenceCount && this._removeInactiveBinding(n) } }, _lendAction: function (t) { const e = this._actions, n = t._cacheIndex, i = this._nActiveActions++, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _takeBackAction: function (t) { const e = this._actions, n = t._cacheIndex, i = --this._nActiveActions, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _addInactiveBinding: function (t, e, n) { const i = this._bindingsByRootAndName, r = this._bindings; let o = i[e]; void 0 === o && (o = {}, i[e] = o), o[n] = t, t._cacheIndex = r.length, r.push(t) }, _removeInactiveBinding: function (t) { const e = this._bindings, n = t.binding, i = n.rootNode.uuid, r = n.path, o = this._bindingsByRootAndName, s = o[i], a = e[e.length - 1], c = t._cacheIndex; a._cacheIndex = c, e[c] = a, e.pop(), delete s[r], 0 === Object.keys(s).length && delete o[i] }, _lendBinding: function (t) { const e = this._bindings, n = t._cacheIndex, i = this._nActiveBindings++, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _takeBackBinding: function (t) { const e = this._bindings, n = t._cacheIndex, i = --this._nActiveBindings, r = e[i]; t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r }, _lendControlInterpolant: function () { const t = this._controlInterpolants, e = this._nActiveControlInterpolants++; let n = t[e]; return void 0 === n && ((n = new nl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n }, _takeBackControlInterpolant: function (t) { const e = this._controlInterpolants, n = t.__cacheIndex, i = --this._nActiveControlInterpolants, r = e[i]; t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (t, e, n) { const i = e || this._root, r = i.uuid; let o = "string" == typeof t ? dl.findByName(i, t) : t; const s = null !== o ? o.uuid : t, a = this._actionsByClip[s]; let c = null; if (void 0 === n && (n = null !== o ? o.blendMode : Re), void 0 !== a) { const t = a.actionByRoot[r]; if (void 0 !== t && t.blendMode === n) return t; c = a.knownActions[0], null === o && (o = c._clip) } if (null === o) return null; const l = new Hh(this, o, e, n); return this._bindAction(l, c), this._addInactiveAction(l, s, r), l }, existingAction: function (t, e) { const n = e || this._root, i = n.uuid, r = "string" == typeof t ? dl.findByName(n, t) : t, o = r ? r.uuid : t, s = this._actionsByClip[o]; return void 0 !== s && s.actionByRoot[i] || null }, stopAllAction: function () { const t = this._actions; for (let e = this._nActiveActions - 1; e >= 0; --e)t[e].stop(); return this }, update: function (t) { t *= this.timeScale; const e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1; for (let s = 0; s !== n; ++s) { e[s]._update(i, t, r, o) } const s = this._bindings, a = this._nActiveBindings; for (let t = 0; t !== a; ++t)s[t].apply(o); return this }, setTime: function (t) { this.time = 0; for (let t = 0; t < this._actions.length; t++)this._actions[t].time = 0; return this.update(t) }, getRoot: function () { return this._root }, uncacheClip: function (t) { const e = this._actions, n = t.uuid, i = this._actionsByClip, r = i[n]; if (void 0 !== r) { const t = r.knownActions; for (let n = 0, i = t.length; n !== i; ++n) { const i = t[n]; this._deactivateAction(i); const r = i._cacheIndex, o = e[e.length - 1]; i._cacheIndex = null, i._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(i) } delete i[n] } }, uncacheRoot: function (t) { const e = t.uuid, n = this._actionsByClip; for (const t in n) { const i = n[t].actionByRoot[e]; void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } const i = this._bindingsByRootAndName[e]; if (void 0 !== i) for (const t in i) { const e = i[t]; e.restoreOriginalState(), this._removeInactiveBinding(e) } }, uncacheAction: function (t, e) { const n = this.existingAction(t, e); null !== n && (this._deactivateAction(n), this._removeInactiveAction(n)) } }); class Fh { constructor(t) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t } clone() { return new Fh(void 0 === this.value.clone ? this.value : this.value.clone()) } } function Gh(t, e, n) { ea.call(this, t, e), this.meshPerAttribute = n || 1 } function kh(t, e, n, i, r) { this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0 } function Vh(t, e, n, i) { this.ray = new zn(t, e), this.near = n || 0, this.far = i || 1 / 0, this.camera = null, this.layers = new Yn, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) } function Wh(t, e) { return t.distance - e.distance } function jh(t, e, n, i) { if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) { const i = t.children; for (let t = 0, r = i.length; t < r; t++)jh(i[t], e, n, !0) } } Gh.prototype = Object.assign(Object.create(ea.prototype), { constructor: Gh, isInstancedInterleavedBuffer: !0, copy: function (t) { return ea.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, clone: function (t) { const e = ea.prototype.clone.call(this, t); return e.meshPerAttribute = this.meshPerAttribute, e }, toJSON: function (t) { const e = ea.prototype.toJSON.call(this, t); return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e } }), Object.defineProperty(kh.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(kh.prototype, { isGLBufferAttribute: !0, setBuffer: function (t) { return this.buffer = t, this }, setType: function (t, e) { return this.type = t, this.elementSize = e, this }, setItemSize: function (t) { return this.itemSize = t, this }, setCount: function (t) { return this.count = t, this } }), Object.assign(Vh.prototype, { set: function (t, e) { this.ray.set(t, e) }, setFromCamera: function (t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type) }, intersectObject: function (t, e, n) { const i = n || []; return jh(t, this, i, e), i.sort(Wh), i }, intersectObjects: function (t, e, n) { const i = n || []; if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i; for (let n = 0, r = t.length; n < r; n++)jh(t[n], this, i, e); return i.sort(Wh), i } }); const qh = new Ke; const Xh = new ln, Yh = new ln; function Zh(t) { ci.call(this), this.material = t, this.render = function () { }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } Zh.prototype = Object.create(ci.prototype), Zh.prototype.constructor = Zh, Zh.prototype.isImmediateRenderObject = !0; const Jh = new ln, Qh = new Bn, Kh = new Bn; const $h = new Float32Array(1), tu = (new Int32Array($h.buffer), 4), eu = 8, nu = (Math.pow(2, eu), [.125, .215, .35, .446, .526, .582]), iu = eu - tu + 1 + nu.length, ru = new Di({ side: h, depthWrite: !1, depthTest: !1 }), { _lodPlanes: ou, _sizeLods: su, _sigmas: au } = (new wr(new Sr, ru), cu()); Math.sqrt(5); function cu() { const t = [], e = [], n = []; let i = eu; for (let r = 0; r < iu; r++) { const o = Math.pow(2, i); e.push(o); let s = 1 / o; r > eu - tu ? s = nu[r - eu + tu - 1] : 0 == r && (s = 0), n.push(s); const a = 1 / (o - 1), c = -a / 2, l = 1 + a / 2, h = [c, c, l, c, l, l, c, c, l, l, c, l], u = 6, d = 6, p = 3, f = 2, m = 1, g = new Float32Array(p * d * u), v = new Float32Array(f * d * u), y = new Float32Array(m * d * u); for (let t = 0; t < u; t++) { const e = t % 3 * 2 / 3 - 1, n = t > 2 ? 0 : -1, i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0]; g.set(i, p * d * t), v.set(h, f * d * t); const r = [t, t, t, t, t, t]; y.set(r, m * d * t) } const x = new rr; x.setAttribute("position", new Bi(g, p)), x.setAttribute("uv", new Bi(v, f)), x.setAttribute("faceIndex", new Bi(y, m)), t.push(x), i > tu && i-- } return { _lodPlanes: t, _sizeLods: e, _sigmas: n } } function lu(t) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Dl.call(this, t), this.type = "catmullrom" } Tl.create = function (t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Tl.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, Object.assign(Xl.prototype, { fromPoints: function (t) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) } }), Object.create(Dl.prototype), Object.create(Dl.prototype), lu.prototype = Object.create(Dl.prototype), Object.assign(lu.prototype, { initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), class extends Xa { constructor(t = 10, e = 10, n = 4473924, i = 8947848) { n = new Pi(n), i = new Pi(i); const r = e / 2, o = t / e, s = t / 2, a = [], c = []; for (let t = 0, l = 0, h = -s; t <= e; t++, h += o) { a.push(-s, 0, h, s, 0, h), a.push(h, 0, -s, h, 0, s); const e = t === r ? n : i; e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3, e.toArray(c, l), l += 3 } const l = new rr; l.setAttribute("position", new qi(a, 3)), l.setAttribute("color", new qi(c, 3)), super(l, new Ha({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } }.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, class extends Xa { constructor(t) { const e = function t(e) { const n = []; e && e.isBone && n.push(e); for (let i = 0; i < e.children.length; i++)n.push.apply(n, t(e.children[i])); return n }(t), n = new rr, i = [], r = [], o = new Pi(0, 0, 1), s = new Pi(0, 1, 0); for (let t = 0; t < e.length; t++) { const n = e[t]; n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b)) } n.setAttribute("position", new qi(i, 3)), n.setAttribute("color", new qi(r, 3)), super(n, new Ha({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(t) { const e = this.bones, n = this.geometry, i = n.getAttribute("position"); Kh.copy(this.root.matrixWorld).invert(); for (let t = 0, n = 0; t < e.length; t++) { const r = e[t]; r.parent && r.parent.isBone && (Qh.multiplyMatrices(Kh, r.matrixWorld), Jh.setFromMatrixPosition(Qh), i.setXYZ(n, Jh.x, Jh.y, Jh.z), Qh.multiplyMatrices(Kh, r.parent.matrixWorld), Jh.setFromMatrixPosition(Qh), i.setXYZ(n + 1, Jh.x, Jh.y, Jh.z), n += 2) } n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t) } }.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(vl.prototype, { extractUrlBase: function (t) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), hh.extractUrlBase(t) } }), vl.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, Object.assign(class { constructor(t, e) { Object.defineProperty(this, "isBox2", { value: !0 }), this.min = void 0 !== t ? t : new Ke(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ke(-1 / 0, -1 / 0) } set(t, e) { return this.min.copy(t), this.max.copy(e), this } setFromPoints(t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this } setFromCenterAndSize(t, e) { const n = qh.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.min.copy(t.min), this.max.copy(t.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(t) { return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Ke), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(t) { return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Ke), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) } expandByPoint(t) { return this.min.min(t), this.max.max(t), this } expandByVector(t) { return this.min.sub(t), this.max.add(t), this } expandByScalar(t) { return this.min.addScalar(-t), this.max.addScalar(t), this } containsPoint(t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) } containsBox(t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y } getParameter(t, e) { return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Ke), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) } clampPoint(t, e) { return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Ke), e.copy(t).clamp(this.min, this.max) } distanceToPoint(t) { return qh.copy(t).clamp(this.min, this.max).sub(t).length() } intersect(t) { return this.min.max(t.min), this.max.min(t.max), this } union(t) { return this.min.min(t.min), this.max.max(t.max), this } translate(t) { return this.min.add(t), this.max.add(t), this } equals(t) { return t.min.equals(this.min) && t.max.equals(this.max) } }.prototype, { center: function (t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, size: function (t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(dn.prototype, { center: function (t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, size: function (t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(Ln.prototype, { empty: function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() } }), Gr.prototype.setFromMatrix = function (t) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t) }, class { constructor(t, e) { this.start = void 0 !== t ? t : new ln, this.end = void 0 !== e ? e : new ln } set(t, e) { return this.start.copy(t), this.end.copy(e), this } clone() { return (new this.constructor).copy(this) } copy(t) { return this.start.copy(t.start), this.end.copy(t.end), this } getCenter(t) { return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new ln), t.addVectors(this.start, this.end).multiplyScalar(.5) } delta(t) { return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new ln), t.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(t, e) { return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new ln), this.delta(e).multiplyScalar(t).add(this.start) } closestPointToPointParameter(t, e) { Xh.subVectors(t, this.start), Yh.subVectors(this.end, this.start); const n = Yh.dot(Yh); let i = Yh.dot(Xh) / n; return e && (i = Qe.clamp(i, 0, 1)), i } closestPointToPoint(t, e, n) { const i = this.closestPointToPointParameter(t, e); return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new ln), this.delta(n).multiplyScalar(i).add(this.start) } applyMatrix4(t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this } equals(t) { return t.start.equals(this.start) && t.end.equals(this.end) } }.prototype.center = function (t) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, Object.assign(Qe, { random16: function () { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function (t) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Qe.floorPowerOfTwo(t) }, nextPowerOfTwo: function (t) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Qe.ceilPowerOfTwo(t) } }), Object.assign($e.prototype, { flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, multiplyVector3: function (t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBufferAttribute: function (t) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, getInverse: function (t) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert() } }), Object.assign(Bn.prototype, { extractPosition: function (t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, getPosition: function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new ln).setFromMatrixColumn(this, 3) }, setRotationFromQuaternion: function (t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function (t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector4: function (t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function (t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, crossVector: function (t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, translate: function () { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBufferAttribute: function (t) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function (t, e, n, i, r, o) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, o) }, getInverse: function (t) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert() } }), di.prototype.isIntersectionLine = function (t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, Object.assign(cn.prototype, { multiplyVector3: function (t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, inverse: function () { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() } }), Object.assign(zn.prototype, { isIntersectionBox: function (t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionPlane: function (t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) } }), Object.assign(Mi.prototype, { area: function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function (t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, midpoint: function (t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, normal: function (t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, plane: function (t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) } }), Object.assign(Mi, { barycoordFromPoint: function (t, e, n, i, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Mi.getBarycoord(t, e, n, i, r) }, normal: function (t, e, n, i) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Mi.getNormal(t, e, n, i) } }), Object.assign(Yl.prototype, { extractAllPoints: function (t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, extrude: function (t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Nc(this, t) }, makeGeometry: function (t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Fc(this, t) } }), Object.assign(Ke.prototype, { fromAttribute: function (t, e, n) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(ln.prototype, { setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, getScaleFromMatrix: function (t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, getColumnFromMatrix: function (t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, applyProjection: function (t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, fromAttribute: function (t, e, n) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(sn.prototype, { fromAttribute: function (t, e, n) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n) }, lengthManhattan: function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(ci.prototype, { getChildByName: function (t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, getWorldRotation: function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, applyMatrix: function (t) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.defineProperties(ci.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.assign(wr.prototype, { setDrawMode: function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } }), Object.defineProperties(wr.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), Object.defineProperties(wa.prototype, { objects: { get: function () { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(Ia.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), La.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(Tl.prototype, "__arcLengthDivisions", { get: function () { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function (t) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t } }), Ir.prototype.setLens = function (t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties(Zl.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function (t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function (t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function (t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function (t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function (t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function (t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function (t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(Bi.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === qe }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(qe) } } }), Object.assign(Bi.prototype, { setDynamic: function (t) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? qe : je), this }, copyIndicesArray: function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, setArray: function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(rr.prototype, { addIndex: function (t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, addAttribute: function (t, e) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Bi(arguments[1], arguments[2]))) }, addDrawCall: function (t, e, n) { void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, removeAttribute: function (t) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t) }, applyMatrix: function (t) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } }), Object.defineProperties(rr.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.defineProperties(uh.prototype, { maxInstancedCount: { get: function () { return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount }, set: function (t) { console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t } } }), Object.defineProperties(Vh.prototype, { linePrecision: { get: function () { return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold }, set: function (t) { console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t } } }), Object.defineProperties(ea.prototype, { dynamic: { get: function () { return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === qe }, set: function (t) { console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t) } } }), Object.assign(ea.prototype, { setDynamic: function (t) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? qe : je), this }, setArray: function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") } }), Object.assign(Nc.prototype, { getArrays: function () { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, addShapeList: function () { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, addShape: function () { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") } }), Object.assign(ta.prototype, { dispose: function () { console.error("THREE.Scene: .dispose() has been removed.") } }), Object.defineProperties(Fh.prototype, { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(Oi.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new Pi } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (t) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t } } }), Object.defineProperties(qc.prototype, { metal: { get: function () { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(jc.prototype, { transparency: { get: function () { return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission }, set: function (t) { console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t } } }), Object.defineProperties(Pr.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), Object.assign(Qs.prototype, { clearTarget: function (t, e, n, i) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i) }, animate: function (t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, getCurrentRenderTarget: function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, allocTextureUnit: function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, setTexture: function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, setTexture2D: function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, setTextureCube: function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, getActiveMipMapLevel: function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() } }), Object.defineProperties(Qs.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (t) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? Ie : Ce } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(ks.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(an.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), Object.defineProperties(Th.prototype, { load: { value: function (t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const e = this; return (new bh).load(t, function (t) { e.setBuffer(t) }), this } }, startTime: { set: function () { console.warn("THREE.Audio: .startTime is now .play( delay ).") } } }), class { constructor(t, e = 2048) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let t = 0; const e = this.getFrequencyData(); for (let n = 0; n < e.length; n++)t += e[n]; return t / e.length } }.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, Nr.prototype.updateCubeMap = function (t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) }, Nr.prototype.clear = function (t, e, n, i) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i) }; en.crossOrigin = void 0, en.loadTexture = function (t, e, n, i) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); const r = new El; r.setCrossOrigin(this.crossOrigin); const o = r.load(t, n, void 0, i); return e && (o.mapping = e), o }, en.loadTextureCube = function (t, e, n, i) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); const r = new Ml; r.setCrossOrigin(this.crossOrigin); const o = r.load(t, n, void 0, i); return e && (o.mapping = e), o }, en.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, en.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "125dev" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "125dev"); class hu extends uh { constructor(t = 1, e = 8) { super(), e = Math.max(e, 3); const n = 2 * Math.PI / e, i = []; for (let r = 0; r < e; r++)i.push(t * Math.cos(n * r), t * Math.sin(n * r), 0); const r = []; for (let t = 0; t < e - 2; t++)r.push(0, t + 1, t + 2); this.setIndex(r), this.addAttribute("position", new qi(i, 3)), this.type = "InstancedPointsGeometry", this.positionsArray = [] } static get isInstancedPointsGeometry() { return !0 } setPositions(t) { this.positionsArray = t; var e = new Float32Array(t); return this.addAttribute("instancePos", new dh(e, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this } applyMatrix(t) { var e = this.attributes.instancePos; return void 0 !== e && (t.applyToBufferAttribute(e), e.data.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } fromWireframeGeometry(t) { return this.setPositions(t.attributes.position.array), this } fromEdgesGeometry(t) { return this.setPositions(t.attributes.position.array), this } fromMesh(t) { return this.fromWireframeGeometry(new Gc(t.geometry)), this } fromLineSegements(t) { var e = t.geometry; return e.isGeometry ? this.setPositions(e.vertices) : e.isBufferGeometry && this.setPositions(e.position.array), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new dn); const t = this.attributes.instancePos; void 0 !== t && this.boundingBox.setFromBufferAttribute(t) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new Ln), null === this.boundingBox && this.computeBoundingBox(); const t = new ln; var e = this.attributes.instancePos; if (void 0 !== e) { var n = this.boundingSphere.center; this.boundingBox.getCenter(n); for (var i = 0, r = 0, o = e.count; r < o; r++)t.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(t)); this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("PointsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this) } } toJSON() { } clone() { const t = new this.constructor; return this.positionsArray.length && t.setPositions(this.positionsArray), t } copy() { return this } } const uu = "\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nattribute vec3 instancePos;\n\nuniform float uDeformation;\nuniform float uPlaneHeight;\nuniform float uRadiu;\n\nvarying float vRand;\n\nvec2 restoreLongAndLat(const in vec2 longAndLat) {\n  float latI = longAndLat.y + 15.0;\n  float k = 0.9 - latI * latI / 72900.0;\n  float longI = longAndLat.x / k;\n  return vec2(longI + 12.0, latI);\n}\n\nvec3 coordTrans(\n  const in vec2 longAndLat,\n  const in float radiu,\n  out mat3 tranX,\n  out mat3 tranY\n) {\n  float dk = saturate(uDeformation * 2.0 - rand(longAndLat));\n  float cosX = cos(radians(longAndLat.y * dk));\n  float sinX = sin(radians(longAndLat.y * dk));\n  float cosY = cos(radians(longAndLat.x * dk));\n  float sinY = sin(radians(longAndLat.x * dk));\n  float xz = radiu * cos(radians(longAndLat.y));\n  float y = radiu * sin(radians(longAndLat.y));\n  float x = xz * sin(radians(longAndLat.x));\n  float z = xz * cos(radians(longAndLat.x));\n  tranX = mat3(\n    1, 0, 0,\n    0, cosX, -sinX,\n    0, sinX, cosX\n  );\n  tranY = mat3(\n    cosY, 0, -sinY,\n    0, 1, 0,\n    sinY, 0, cosY\n  );\n  return mix(vec3(instancePos.xy, uPlaneHeight), vec3(x, y, z), dk);\n}\n\nvoid main() {\n  vec2 longAndLat = restoreLongAndLat(instancePos.xy);\n  mat3 tranX, tranY;\n  vec3 coord = coordTrans(longAndLat, uRadiu, tranX, tranY);\n  vec3 pos = tranY * tranX * position;\n  vec4 mvPosition = modelViewMatrix * vec4(coord + pos, 1.0);\n  // vec4 mvPosition = modelViewMatrix * vec4(instancePos + position + vec3(0, 0, 80), 1.0);\n  gl_Position = projectionMatrix * mvPosition;\n\n  vRand = rand(instancePos.xy);\n\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n  #include <fog_vertex>\n}\n", du = "\nuniform vec3 diffuse;\nuniform vec3 uHighlight;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nuniform float uTimer;\nvarying float vRand;\n\nvoid main() {\n\n  #include <clipping_planes_fragment>\n\n  // float flash = rand(vec2(uTimer, vRand));\n  float test = saturate(mod(uTimer * 0.5 + 100.0, vRand * 8.0 + 8.0));\n  float flash = 1.0 - sin(test * PI);\n  vec4 diffuseColor = vec4(mix(uHighlight, diffuse, flash), opacity);\n  // vec4 diffuseColor = vec4(diffuse, opacity * vRand);\n\n  #include <logdepthbuf_fragment>\n  #include <color_fragment>\n\n  gl_FragColor = diffuseColor;\n\n  #include <premultiplied_alpha_fragment>\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n}\n", pu = Ar.merge([qr.common, qr.fog, { uDeformation: { value: 0 }, uPlaneHeight: { value: 0 }, uRadiu: { value: 100 }, uTimer: { value: 0 }, uHighlight: { value: new Pi(16777215) } }]); class fu extends Pr { constructor(t) { super({ type: "InstancedPointsMaterial", uniforms: Ar.clone(pu), vertexShader: uu, fragmentShader: du }), this.setValues(t) } get color() { return this.uniforms.diffuse.value } set color(t) { this.uniforms.diffuse.value = t } get planeHeight() { return this.uniforms.uPlaneHeight.value } set planeHeight(t) { this.uniforms.uPlaneHeight.value = t } get radiu() { return this.uniforms.uRadiu.value } set radiu(t) { this.uniforms.uRadiu.value = t } get deformation() { return this.uniforms.uDeformation.value } set deformation(t) { this.uniforms.uDeformation.value = t } get timer() { return this.uniforms.uTimer.value } set timer(t) { this.uniforms.uTimer.value = t } get highlight() { return this.uniforms.uHighlight.value } set highlight(t) { this.uniforms.uHighlight.value.copy(t) } static get isInstancedPointsMaterial() { return !0 } clone() { return (new this.constructor).copy(this) } copy(t) { return Pr.prototype.copy.call(this, t), this.color.copy(t.color), this } } const mu = "\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nattribute vec2 aCoord;\n\nuniform float uDeformation;\nuniform float uPlaneHeight;\nuniform float uRadiu;\n\nvarying vec2 vUv;\n\nvec2 transLatAndLong(const in vec2 LatAndLong) {\n  float k = 0.9 - LatAndLong.x * LatAndLong.x / 72900.0;\n  float longI;\n  if (LatAndLong.y < -168.0) {\n    longI = (LatAndLong.y + 348.0) * k;\n  } else {\n    longI = (LatAndLong.y - 12.0) * k;\n  }\n  float latI = LatAndLong.x - 15.0;\n  return vec2(longI, latI);\n}\n\nvec3 coordTrans(\n  const in vec2 LatAndLong,\n  const in float radiu,\n  out mat3 tranX,\n  out mat3 tranY\n) {\n  float dk = saturate(uDeformation * 2.0 - rand(LatAndLong));\n  float cosX = cos(radians(LatAndLong.x * dk));\n  float sinX = sin(radians(LatAndLong.x * dk));\n  float cosY = cos(radians(LatAndLong.y * dk));\n  float sinY = sin(radians(LatAndLong.y * dk));\n  float xz = radiu * cos(radians(LatAndLong.x));\n  float y = radiu * sin(radians(LatAndLong.x));\n  float x = xz * sin(radians(LatAndLong.y));\n  float z = xz * cos(radians(LatAndLong.y));\n  tranX = mat3(\n    1, 0, 0,\n    0, cosX, -sinX,\n    0, sinX, cosX\n  );\n  tranY = mat3(\n    cosY, 0, -sinY,\n    0, 1, 0,\n    sinY, 0, cosY\n  );\n  return mix(vec3(transLatAndLong(aCoord), uPlaneHeight), vec3(x, y, z), dk);\n}\n\nvoid main() {\n  vUv = uv;\n\n  mat3 tranX, tranY;\n  vec3 coord = coordTrans(aCoord, uRadiu, tranX, tranY);\n  vec3 pos = tranY * tranX * position;\n  vec4 mvPosition = modelViewMatrix * vec4(coord + pos, 1.0);\n\n  gl_Position = projectionMatrix * mvPosition;\n\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n  #include <fog_vertex>\n}\n", gu = "\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nuniform sampler2D uLightMap;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n  #include <clipping_planes_fragment>\n\n  vec4 mapColor = texture2D(uLightMap, vUv);\n\n  vec4 diffuseColor = vec4(mix(diffuse, vec3(1.0, 1.0, 1.0), mapColor.b), opacity * mapColor.r);\n\n  #include <logdepthbuf_fragment>\n  #include <color_fragment>\n\n  gl_FragColor = diffuseColor;\n\n  #include <premultiplied_alpha_fragment>\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n}\n", vu = Ar.merge([qr.common, qr.fog, { uDeformation: { value: 0 }, uPlaneHeight: { value: 0 }, uRadiu: { value: 80 }, uLightMap: { value: null } }]); class yu extends wr { constructor(t) { const e = new uh; e.setIndex([0, 2, 1, 1, 2, 3, 4, 6, 5, 5, 6, 7, 8, 10, 9, 9, 10, 11]), e.addAttribute("position", new qi([-1, 0, 1, 1, 0, 1, -1, 0, 0, 1, 0, 0, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, -1.4, 1.4, 0, 1.4, 1.4, 0, -1.4, -1.4, 0, 1.4, -1.4, 0], 3)), e.addAttribute("uv", new qi([0, 1, 1, 1, 0, .5, 1, .5, 0, 1, 1, 1, 0, .5, 1, .5, 0, .5, 1, .5, 0, 0, 1, 0], 2)), e.addAttribute("aCoord", new dh(new Float32Array(t), 2)), e.scale(1.6, 1.6, 20), e.translate(0, 0, .5); const n = new Pr({ type: "EarthLightMaterial", uniforms: Ar.clone(vu), vertexShader: mu, fragmentShader: gu, side: u, fog: !0, transparent: !0, depthTest: !1, opacity: .6 }); n.uniforms.diffuse.value = new Pi(10277866), super(e, n) } set lightMap(t) { this.material.uniforms.uLightMap.value = t } get lightMap() { return this.material.uniforms.uLightMap.value } get planeHeight() { return this.material.uniforms.uPlaneHeight.value } set planeHeight(t) { this.material.uniforms.uPlaneHeight.value = t } get radiu() { return this.material.uniforms.uRadiu.value } set radiu(t) { this.material.uniforms.uRadiu.value = t } get deformation() { return this.material.uniforms.uDeformation.value } set deformation(t) { this.material.uniforms.uDeformation.value = t } } class xu { constructor(t) { const e = t.radius || 16, n = t.width || .5, i = new wr(new Uc(e, e + n, 32), new Di({ color: 16777215, side: u, transparent: !0 })); i.position.set(t.x, t.y, t.z), i.rotation.order = "YXZ", i.rotation.y = t.long, i.rotation.x = -t.lat, i.scale.set(.01, .01, .01), this.mesh = i, this.update = () => { const { done: t } = this.animator.next(); t ? "function" == typeof this.afterAnimation && this.afterAnimation() : requestAnimationFrame(this.update) } } *createAnimator() { for (; this.k < 1;) { this.k += .02; const t = this.k; this.mesh.scale.set(t, t, t), this.mesh.material.opacity = 1 - t * t, yield } } animate() { this.k = .01, this.animator = this.createAnimator(), requestAnimationFrame(this.update) } } const _u = new rr; _u.addAttribute("position", new qi([0, 0, 0], 3)); const bu = new Za({ size: 10, map: (new El).load(n(1)), blending: f, depthTest: !1, transparent: !0, color: 16777215 }); var wu = n(0); const Mu = Math.PI / 180, Su = (t, e) => { const n = new ln; return n.addVectors(t, e), n.multiplyScalar(110 / n.length()), n }; new class { constructor(t) { if (!(t.parent instanceof HTMLElement)) throw new Error("[Earth] A correct DOM node must be provided!"); this.parent = t.parent, this.rotateSpeed = t.rotateSpeed || .002, this.pointFlashSpeed = t.pointFlashSpeed || 1, this.coords = t.coords || [29.458349, 106.396826, 39.804935, 114.973428, 22.204878, 45.426417, 10.106263, 39.144935, 47.397837, 4.803222, 41.997906, -1.40588, 44.136586, 11.842139, 38.935887, 16.504146, 44.490049, 27.585049, 39.062638, -78.335972, 39.897687, -122.714527, 9.171568, -66.633754, -15.47, -47.55, -35.15, 149.08, -18.06, 178.3, -6.09, 106.49], this.linkAnimations = new Set, this.o = t, this.init() } init() { const t = new Ir(30, 1, .1, 1e3); t.position.set(0, 30, 220); const e = new ta; e.fog = new $s(this.o.fogColor || 1382952, 220, 320); const i = new Qs({ devicePixelRatio: window.devicePixelRatio, antialias: !0, alpha: !0 }), r = new hu(this.o.pointRadius || .45, this.o.pointSegments || 4), o = wu.reduce((t, e) => t.concat(...e, 0), []); r.setPositions(o); const s = new fu({ planeHeight: 0, deformation: 1, radiu: 80, color: this.o.pointColor || 6647417, highlight: this.o.pointHighlight || 13360368, fog: !0, side: u, depthTest: !1, blending: f }), a = new wr(r, s); a.rotation.x = .4, a.position.set(0, 0, 0), e.add(a); const c = new yu(this.coords); c.deformation = 1, a.add(c), (new El).load(n(2), t => { t.anisotropy = i.capabilities.getMaxAnisotropy(), c.lightMap = t }); const l = [], h = []; for (let t = 0; t < this.coords.length; t += 2) { const e = this.coords[t] * Mu, n = this.coords[t + 1] * Mu, i = 80.5 * Math.cos(e) * Math.sin(n), r = 80.5 * Math.sin(e), o = 80.5 * Math.cos(e) * Math.cos(n), s = new xu({ lat: e, long: n, x: i, y: r, z: o, radius: this.o.ringRadius, width: this.o.ringWidth }); s.afterAnimation = () => { this.locks[t / 2] = !1, this.freePointCoint++ }, l.push(s), h.push(new ln(i, r, o)), a.add(s.mesh) } const d = new wr(new Bc(76, 4), new Di({ color: 16777215, transparent: !0, opacity: .05 })); e.add(d), this.rings = l, this.points = h, this.locks = new Array(h.length).fill(!1), this.freePointCoint = h.length, this.earth = a, this.light = c, this.material = s, this.scene = e, this.renderer = i, this.camera = t, this.timer = 0, this.minLineSpacing = this.o.minLineSpacing || 30, this.maxLineSpacing = this.o.maxLineSpacing || 110, this.interval = this.minLineSpacing + Math.random() * (this.maxLineSpacing - this.minLineSpacing), this.onresize = () => { const t = this.parent.getBoundingClientRect(); this.camera.aspect = t.width / t.height, this.renderer.setSize(t.width, t.height), this.camera.updateProjectionMatrix(); const e = t.width < t.height ? 1.4 : 1, n = (220 + t.height / 7) * e; this.camera.position.set(0, 20, n), this.scene.fog.near = n, this.scene.fog.far = n + 80 }, this.render = t => { this.linkAnimations.forEach(t => { const { done: e } = t.next(); e && this.linkAnimations.delete(t) }), this.timer++, ++this.timer > this.interval && (this.timer = 0, this.interval = this.minLineSpacing + Math.random() * (this.maxLineSpacing - this.minLineSpacing), this.randomLinkAnimator()), this.earth.rotation.y += this.rotateSpeed, this.material.timer = t / 1e3 * this.pointFlashSpeed, this.renderer.render(this.scene, this.camera), this.raf = requestAnimationFrame(this.render) } } getAndLockPoint() { const t = this.locks.map((t, e) => t || e).filter(t => "number" == typeof t), e = t[Math.floor(t.length * Math.random())]; return this.locks[e] = !0, this.freePointCoint--, e } randomLinkAnimator() { if (this.freePointCoint < 2) return; const t = this.getAndLockPoint(), e = this.getAndLockPoint(); this.linkAnimations.add(this.linkAnimator(t, e)) } *linkAnimator(t, e) { const n = this.points[t], i = this.points[e], r = new Vl(n, Su(n, i), i), o = r.getLength(), s = (new rr).setFromPoints(r.getPoints(48)), a = new Qc({ color: 13360368, dashSize: 3, gapSize: o, scale: 6, transparent: !0, depthTest: !1 }), c = new Wa(s, a); c.computeLineDistances(); const l = (h = this.o.lineHighlightSize || 10, bu.size = h, new tc(_u, bu.clone())); var h; this.earth.add(l), l.position.set(n.x, n.y, n.z), this.earth.add(c), this.rings[t].animate(); let u = .5, d = 0; for (; u < o;) { u += 1.6, d++, a.scale = 3 / u, a.opacity = Math.min(1, (120 - d) / 60); const t = u / o, e = r.getPointAt(t); l.position.set(e.x, e.y, e.z), l.material.opacity = 1 - Math.pow(2 * t - 1, 2), yield } for (this.rings[e].animate(), this.earth.remove(l); d < 120;)d++, a.opacity = Math.min(1, (120 - d) / 60), yield; this.earth.remove(c) } start() { window.addEventListener("resize", this.onresize), this.onresize(), this.renderer.domElement.id = "webgl-world", this.parent.appendChild(this.renderer.domElement), this.raf = requestAnimationFrame(this.render) } stop() { this.raf && cancelAnimationFrame(this.raf), window.removeEventListener("resize", this.onresize), this.parent.removeChild(this.renderer.domElement) } }({ parent: document.querySelector(".navi-earth"), rotateSpeed: .002, lineHighlightSize: 12, minLineSpacing: 30, maxLineSpacing: 110, coords: [29.458349, 106.396826, 39.804935, 114.973428, 22.204878, 45.426417, 10.106263, 39.144935, 47.397837, 4.803222, 41.997906, -1.40588, 44.136586, 11.842139, 38.935887, 16.504146, 44.490049, 27.585049, 39.062638, -78.335972, 39.897687, -122.714527, 9.171568, -66.633754, -15.47, -47.55, -35.15, 149.08, -18.06, 178.3, -6.09, 106.49], pointFlashSpeed: 1, pointRadius: .45, pointSegments: 4, pointColor: 6647417, pointHighlight: 13360368, ringRadius: 16, ringWidth: .5, fogColor: 1382952 }).start() }]);